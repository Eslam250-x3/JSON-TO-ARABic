<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…ØªØ±Ø¬Ù… Ø§Ù„Ø£Ø³Ø¦Ù„Ø©</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- MathLive for LaTeX editing -->
    <script src="https://unpkg.com/@nagwa-limited/mathlive" defer></script>
    <!-- Fabric.js for simple image annotation/editor -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

    <!-- DOMPurify for security -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>

    <!-- Diff Match Patch for comparing text -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f3f4f6;
            --text-color: #1f2937;
            --card-bg: #ffffff;
            --card-border: #e5e7eb;
            --input-bg: #ffffff;
            --input-border: #d1d5db;
            --primary-color: #4f46e5;
            --primary-hover: #4338ca;
            --secondary-text: #6b7280;
            --success-color: #10b981;
            --error-color: #ef4444;
            --highlight-bg: #fef9c3;
            --diff-ins-bg: #ddfbe9;
            --diff-del-bg: #fce8e9;
        }

        [data-theme="dark"] {
            --bg-color: #111827;
            --text-color: #f9fafb;
            --card-bg: #1f2937;
            --card-border: #374151;
            --input-bg: #374151;
            --input-border: #4b5563;
            --primary-color: #6366f1;
            --primary-hover: #818cf8;
            --secondary-text: #9ca3af;
            --highlight-bg: #4d4318;
            --diff-ins-bg: #133825;
            --diff-del-bg: #411a1d;
        }

        body {
            font-family: 'Cairo', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        .main-card,
        .preview-card {
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        input,
        select,
        textarea {
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
        }

        .dragover {
            border-color: var(--primary-color);
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--bg-color));
        }

        .api-selector input[type="radio"]:checked+label {
            border-color: var(--primary-color);
            background-color: color-mix(in srgb, var(--primary-color) 15%, var(--card-bg));
            color: var(--primary-color);
        }

        .alert {
            transition: all 0.5s ease-in-out;
            opacity: 1;
            transform: translateX(0);
        }

        .alert.fade-out {
            opacity: 0;
            transform: translateX(100%);
        }

        .search-highlight,
        mark.search-highlight {
            background-color: var(--highlight-bg);
            color: var(--text-color);
            border-radius: 3px;
            padding: 0 2px;
        }

        #saveIndicator {
            font-size: 0.85rem;
            color: var(--secondary-text);
        }

        #saveIndicator.saved {
            color: var(--success-color);
        }

        #saveIndicator.error {
            color: var(--error-color);
        }

        /* Accordion Styles */
        .accordion-header {
            width: 100%;
            padding: 1rem 1.5rem;
            text-align: right;
            font-weight: 700;
            font-size: 1.125rem;
            border-radius: 0.75rem;
            background-color: color-mix(in srgb, var(--primary-color) 8%, var(--card-bg));
            transition: background-color 0.2s;
            cursor: pointer;
        }

        .accordion-header:hover {
            background-color: color-mix(in srgb, var(--primary-color) 15%, var(--card-bg));
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-in-out;
            background-color: var(--card-bg);
            border-top: 1px solid var(--card-border);
        }

        .accordion-content.open {
            padding: 1.5rem;
        }

        /* Diff View Styles */
        .diff-view {
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: var(--bg-color);
            border: 1px solid var(--card-border);
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .diff-view ins {
            background-color: var(--diff-ins-bg);
            text-decoration: none;
        }

        .diff-view del {
            background-color: var(--diff-del-bg);
            text-decoration: line-through;
        }

        /* Status Indicator */
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 8px;
        }

        .status-translated {
            background-color: var(--success-color);
        }
        
        /* Field State Colors */
        .field-warning {
            border-right: 4px solid var(--warning-color) !important;
        }
        
        .field-error {
            border-right: 4px solid var(--error-color) !important;
        }
        
        .field-success {
            border-right: 4px solid var(--success-color) !important;
        }
        
        .field-edited {
            background-color: color-mix(in srgb, var(--warning-color) 5%, var(--card-bg)) !important;
        }
        
        /* Quality Badges */
        .quality-badge {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            opacity: 0.3;
            cursor: help;
            transition: all 0.2s;
        }
        
        .quality-badge.valid {
            opacity: 1;
            background-color: #10b981;
            color: white;
        }
        
        .quality-badge.invalid {
            opacity: 1;
            background-color: #ef4444;
            color: white;
        }
        
        /* Action Buttons */
        .action-btn {
            padding: 4px 8px;
            border: 1px solid var(--card-border);
            border-radius: 6px;
            background: var(--card-bg);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        
        .action-btn:hover {
            background-color: var(--primary-color);
            color: white;
            transform: scale(1.1);
        }
        
        /* Progress Bars */
        .file-progress-bar {
            width: 100%;
            background-color: #e5e7eb;
            border-radius: 9999px;
            height: 0.5rem;
            margin-top: 0.5rem;
            overflow: hidden;
        }
        
        .file-progress-fill {
            background-color: #10b981;
            height: 100%;
            border-radius: 9999px;
            transition: width 0.3s ease;
        }
        
        /* Review Mode */
        .review-mode .translated-content {
            filter: blur(8px);
            transition: filter 0.3s;
        }
        
        .review-mode .translated-content:hover {
            filter: blur(0px);
        }

        .status-edited {
            background-color: #f59e0b;
        }

        /* Amber 500 */

        /* Styles for MathLive Fields */
        .editable-preview-field {
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            padding: 0.75rem;
            min-height: 80px;
        }

        math-field {
            position: relative;
        }

        .math-field-delete-btn {
            position: absolute;
            top: -10px;
            left: -10px;
            background-color: var(--error-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 10;
        }
        
        .math-field-copy-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 10;
        }
        
        math-field:hover .math-field-delete-btn,
        math-field:focus-within .math-field-delete-btn,
        math-field:hover .math-field-copy-btn,
        math-field:focus-within .math-field-copy-btn {
            opacity: 1;
            visibility: visible;
        }
        
        .math-field-delete-btn:hover {
            background-color: #dc2626;
            transform: scale(1.1);
        }
        
        .math-field-copy-btn:hover {
            background-color: var(--success-color);
            transform: scale(1.1);
        }
        /* MathLive default look (editable) */
        math-field {
            border: 1px solid var(--input-border);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 1.1em;
            display: inline-block;
            background: var(--input-bg);
            min-width: 20px;
            margin: 2px;
            max-width: 100%;
            white-space: nowrap;
            /* Force LTR for all math content - critical for equations */
            direction: ltr !important;
            unicode-bidi: embed;
        }

        /* Higher-fidelity preview to match source system: make formulas look inline and unboxed inside preview */
        .editable-preview-field math-field {
            border: 0;
            background: transparent;
            padding: 0 2px;
            box-shadow: none;
        }

        .editable-preview-field .content-root {
            line-height: 1.8;
        }

        .editable-preview-field .content-root p {
            margin: .25rem 0;
        }

        /* Approximate Lexical theme blocks so content spacing matches original */
        .LexicalTheme__paragraph {
            white-space: pre-wrap;
            margin: .25rem 0;
        }

        .LexicalTheme__image img {
            max-width: 100%;
            height: auto;
        }

        math-field:focus-within {
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--input-bg));
            box-shadow: 0 0 0 2px var(--primary-color);
            outline: none;
        }

        /* Enhanced MathLive keyboard styling for Arabic support */
        math-field {
            font-family: 'Cairo', 'Arial', sans-serif;
        }

        /* Arabic text in math fields */
        math-field[dir="rtl"] {
            text-align: right;
            direction: rtl;
        }

        /* English text in math fields */
        math-field[dir="ltr"] {
            text-align: left;
            direction: ltr;
        }

        /* Mixed content in math fields */
        math-field[dir="auto"] {
            text-align: start;
            direction: auto;
        }

        /* Virtual keyboard styling */
        .ML__keyboard {
            font-family: 'Cairo', 'Arial', sans-serif !important;
        }

        /* Arabic keys in keyboard */
        .ML__keyboard .ML__key[data-key*="\u0600"] {
            font-family: 'Cairo', 'Arial', sans-serif !important;
            font-size: 1.1em;
        }

        /* Language indicator */
        .ML__keyboard::before {
            content: attr(data-language);
            position: absolute;
            top: -25px;
            left: 10px;
            font-size: 12px;
            color: var(--secondary-text);
            font-family: 'Cairo', 'Arial', sans-serif;
        }

        /* Enhanced keyboard theme for Arabic */
        .ML__keyboard[data-language="ar"] {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }

        /* Arabic key styling */
        .ML__keyboard[data-language="ar"] .ML__key {
            border-radius: 6px;
            border: 1px solid #dee2e6;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .ML__keyboard[data-language="ar"] .ML__key:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }

        .ML__keyboard[data-language="ar"] .ML__key:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Visual blank for underscores in preview (does not persist to JSON) */
        .blank-slot {
            display: inline-block;
            min-width: 1.8em;
            border-bottom: 2px solid currentColor;
            vertical-align: baseline;
            line-height: 1.2;
            margin: 0 0.15em;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 2px;
            padding: 1px 2px;
        }

        /* Ensure blanks are visible in both original and translated text */
        .original-text-readonly .blank-slot,
        .editable-preview-field .blank-slot {
            border-bottom: 2px solid #666;
            background-color: rgba(0, 0, 0, 0.08);
        }

        /* Make blanks more prominent in original text */
        .original-text-readonly .blank-slot {
            border-bottom: 3px solid #333;
            background-color: rgba(0, 0, 0, 0.12);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        /* Ensure blanks are visible in read-only fields */
        .p-3.rounded-lg.text-sm .blank-slot {
            border-bottom: 2px solid #555;
            background-color: rgba(0, 0, 0, 0.1);
            min-width: 2em;
        }

        /* Make blanks more visible in different contexts */
        .blank-slot {
            position: relative;
            cursor: default;
        }

        .blank-slot::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 1px;
            background-color: rgba(0, 0, 0, 0.2);
        }

        /* Add hover effect to make blanks more interactive */
        .blank-slot:hover {
            background-color: rgba(0, 0, 0, 0.15) !important;
            border-bottom-color: #333 !important;
        }

        /* Ensure blanks are visible in dark mode */
        @media (prefers-color-scheme: dark) {
            .blank-slot {
                background-color: rgba(255, 255, 255, 0.1) !important;
                border-bottom-color: #ccc !important;
            }

            .blank-slot:hover {
                background-color: rgba(255, 255, 255, 0.2) !important;
                border-bottom-color: #fff !important;
            }
        }

        /* Add tooltip to show blank length on hover */
        .blank-slot[data-blank]:hover::before {
            content: attr(data-blank);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }

        /* Ensure tooltip is visible in dark mode */
        @media (prefers-color-scheme: dark) {
            .blank-slot[data-blank]:hover::before {
                background-color: #fff;
                color: #333;
            }
        }

        /* Add animation for better visual feedback */
        .blank-slot {
            transition: all 0.2s ease-in-out;
        }

        .blank-slot:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Ensure blanks are accessible */
        .blank-slot[data-blank] {
            aria-label: "ÙØ±Ø§Øº: " attr(data-blank);
        }

        /* Add focus styles for keyboard navigation */
        .blank-slot:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        /* Ensure blanks are visible in print */
        @media print {
            .blank-slot {
                border-bottom: 2px solid #000 !important;
                background-color: transparent !important;
                box-shadow: none !important;
            }
        }

        /* Add support for high contrast mode */
        @media (prefers-contrast: high) {
            .blank-slot {
                border-bottom: 3px solid #000 !important;
                background-color: #fff !important;
            }
        }

        /* Add support for reduced motion */
        @media (prefers-reduced-motion: reduce) {
            .blank-slot {
                transition: none !important;
            }

            .blank-slot:hover {
                transform: none !important;
            }
        }

        /* Advanced text direction support for mixed content */
        .text-mixed {
            direction: auto;
            text-align: start;
            unicode-bidi: embed;
        }

        /* Enhanced text direction for Arabic-English mixed content */
        .rtl-auto {
            direction: rtl;
            text-align: right;
            unicode-bidi: embed;
        }

        .ltr-auto {
            direction: ltr;
            text-align: left;
            unicode-bidi: embed;
        }

        /* Support for inline mixed text */
        .mixed-content {
            direction: auto;
            unicode-bidi: plaintext;
        }

        /* Improved support for numbers in Arabic text */
        .arabic-numerals {
            font-family: 'Arial Unicode MS', Arial, sans-serif;
            direction: ltr;
            unicode-bidi: embed;
            display: inline;
        }

        .english-numerals {
            font-family: Arial, sans-serif;
            direction: ltr;
            unicode-bidi: embed;
            display: inline;
        }

        /* Enhanced preview content direction */
        .original-text-readonly,
        .editable-preview-field {
            direction: auto;
            text-align: start;
            unicode-bidi: plaintext;
        }

        /* Special handling for mixed content in preview */
        .content-root {
            unicode-bidi: plaintext;
        }

        .content-root * {
            unicode-bidi: embed;
        }
        
        /* Ensure proper RTL direction for Arabic content */
        .editable-preview-field .content-root[dir="rtl"],
        .original-text-readonly .content-root[dir="rtl"] {
            direction: rtl;
            text-align: right;
        }
        
        /* Ensure proper LTR direction for English content */
        .editable-preview-field .content-root[dir="ltr"],
        .original-text-readonly .content-root[dir="ltr"] {
            direction: ltr;
            text-align: left;
        }

        /* Handle English phrases within Arabic text */
        .english-phrase {
            direction: ltr;
            unicode-bidi: embed;
            display: inline;
        }

        /* Handle Arabic phrases within English text */
        .arabic-phrase {
            direction: rtl;
            unicode-bidi: embed;
            display: inline;
        }

        /* Math and chemical formulas should always be LTR */
        math-field,
        .math-content,
        .chemical-formula {
            direction: ltr !important;
            unicode-bidi: embed;
            text-align: left;
        }

        /* Improved blank slots for mixed content */
        .blank-slot {
            direction: inherit;
            unicode-bidi: embed;
        }

        /* Add support for large text */
        @media (prefers-reduced-motion: reduce) {
            .blank-slot {
                min-width: 2.5em;
                font-size: 1.1em;
            }
        }

        /* Tables inside editable preview */
        .editable-preview-field table {
            width: 100%;
            border-collapse: collapse;
            direction: rtl;
        }

        .editable-preview-field th,
        .editable-preview-field td {
            border: 1px solid var(--card-border);
            padding: 6px 8px;
            vertical-align: top;
        }

        .editable-preview-field thead {
            background-color: color-mix(in srgb, var(--primary-color) 8%, var(--card-bg));
        }

        /* Make table cells editable */
        .editable-preview-field td,
        .editable-preview-field th {
            position: relative;
            min-height: 1.5em;
            cursor: text;
        }

        .editable-preview-field td:focus,
        .editable-preview-field th:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: -2px;
            background-color: color-mix(in srgb, var(--primary-color) 5%, var(--input-bg));
        }
    </style>
</head>

<body class="text-gray-800">
    <div id="alertContainer" class="fixed top-0 right-0 p-4 w-full max-w-md z-50 space-y-3"></div>

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-4xl md:text-5xl font-bold" style="color: var(--primary-color);">ğŸŒ Ù…ØªØ±Ø¬Ù… Ø§Ù„Ø£Ø³Ø¦Ù„Ø© 
            </h1>
            <div class="flex items-center gap-4">
                <span id="saveIndicator" aria-live="polite">â€”</span>
                <button id="theme-toggle" class="text-2xl">â˜€ï¸</button>
                <button id="newSessionBtn"
                    class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition">Ø¨Ø¯Ø¡
                    Ø¬Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
            </div>
        </div>
        <p class="mt-2 mb-8 text-center text-lg" style="color: var(--secondary-text);">ØªØ±Ø¬Ù…Ø© Ù…Ù„ÙØ§Øª JSONØŒ Ù…Ø¹ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
            ÙˆØ§Ù„ØªØ¹Ø¯ÙŠÙ„ØŒ ÙˆØ¯Ø¹Ù… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©.</p>

        <div id="setupSection" class="main-card p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4 border-b-2 pb-2"
                style="color: var(--primary-color); border-color: var(--primary-color-light);">Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ±ÙØ¹
                Ø§Ù„Ù…Ù„ÙØ§Øª</h3>
            <div class="grid md:grid-cols-2 gap-6">
                <div>
                    <div class="mb-6">
                        <label class="block mb-2 font-semibold">Ø§Ø®ØªØ± Ù…ÙØ²ÙˆÙ‘Ø¯ Ø§Ù„Ø®Ø¯Ù…Ø©:</label>
                        <div class="api-selector grid grid-cols-3 gap-4">
                            <div>
                                <input type="radio" id="geminiProvider" name="apiProvider" value="gemini" class="hidden"
                                    checked>
                                <label for="geminiProvider"
                                    class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span
                                        class="font-bold">ğŸ¤– Gemini</span></label>
                            </div>
                            <div>
                                <input type="radio" id="chatgptProvider" name="apiProvider" value="chatgpt"
                                    class="hidden">
                                <label for="chatgptProvider"
                                    class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span
                                        class="font-bold">ğŸ’¬ ChatGPT</span></label>
                            </div>
                            <div>
                                <input type="radio" id="localModelProvider" name="apiProvider" value="local"
                                    class="hidden">
                                <label for="localModelProvider"
                                    class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span
                                        class="font-bold">ğŸ–¥ï¸ Ù†Ù…ÙˆØ°Ø¬ Ù…Ø­Ù„ÙŠ</span></label>
                            </div>
                        </div>
                    </div>

                    <div id="geminiKeyGroup" class="mb-6">
                        <label for="geminiKey" class="block mb-2 font-semibold">Ù…ÙØªØ§Ø­ Gemini API:</label>
                        <input type="password" id="geminiKey" placeholder="ÙŠØ¨Ø¯Ø£ Ø¨Ù€ AIza..."
                            class="w-full p-3 rounded-lg focus:ring-2 transition"
                            style="border-color: var(--input-border);">
                    </div>
                    <div id="chatgptKeyGroup" class="mb-6 hidden">
                        <label for="chatgptKey" class="block mb-2 font-semibold">Ù…ÙØªØ§Ø­ OpenAI API:</label>
                        <input type="password" id="chatgptKey" placeholder="ÙŠØ¨Ø¯Ø£ Ø¨Ù€ sk-..."
                            class="w-full p-3 rounded-lg focus:ring-2 transition"
                            style="border-color: var(--input-border);">
                    </div>
                    <div id="localModelGroup" class="mb-6 hidden">
                        <label for="localModelUrl" class="block mb-2 font-semibold">Ø¹Ù†ÙˆØ§Ù† URL Ù„Ø®Ø§Ø¯Ù… Ollama:</label>
                        <input type="text" id="localModelUrl" placeholder="http://localhost:11434/api/generate"
                            class="w-full p-3 rounded-lg focus:ring-2 transition mb-2"
                            style="border-color: var(--input-border);">
                        <label for="localModelName" class="block mb-2 font-semibold">Ø§Ø³Ù… Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ (Ù…Ø«Ø§Ù„:
                            gemma:7b):</label>
                        <input type="text" id="localModelName" placeholder="gemma:7b"
                            class="w-full p-3 rounded-lg focus:ring-2 transition"
                            style="border-color: var(--input-border);">
                    </div>

                    <div class="mb-6">
                      <label for="translatorSelect" class="block mb-2 font-semibold">Ø§Ø³Ù… Ø§Ù„Ù…ØªØ±Ø¬Ù…:</label>
                      <select id="translatorSelect" class="w-full p-3 rounded-lg focus:ring-2 transition" style="border-color: var(--input-border);">
                        <option value="">Ø§Ø®ØªØ± Ù…ØªØ±Ø¬Ù…Ø§Ù‹</option>
                        <option value="Fatema Samy">Fatema Samy</option>
                        <option value="Samar Bahaaeldin">Samar Bahaaeldin</option>
                        <option value="Lobna Adel">Lobna Adel</option>
                        <option value="Shady Donia">Shady Donia</option>
                        <option value="Zeina Elsheikh">Zeina Elsheikh</option>
                        <option value="Aiat Saied">Aiat Saied</option>
                        <option value="Monica Sidhom">Monica Sidhom</option>
                        <option value="Yara Sobhy">Yara Sobhy</option>
                        <option value="Mariam Ghonaim">Mariam Ghonaim</option>
                        <option value="Hussein Mahmoud">Hussein Mahmoud</option>
                        <option value="Ahmed Sabra">Ahmed Sabra</option>
                        <option value="Ahmed Alhefny">Ahmed Alhefny</option>
                        <option value="Aya Abulmagd">Aya Abulmagd</option>
                        <option value="Gehan Khaled">Gehan Khaled</option>
                        <option value="Salma Hafez">Salma Hafez</option>
                        <option value="Hend El Husseiny">Hend El Husseiny</option>
                        <option value="Salma Zaki">Salma Zaki</option>
                        <option value="Esraa Shahien">Esraa Shahien</option>
                      </select>
                    </div>

                    <div class="mb-3">
                        <label class="inline-flex items-center gap-2">
                            <input id="ephemeralKeysCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2"
                                style="color: var(--primary-color);">
                            <span class="text-sm font-medium">Ø¹Ø¯Ù… Ø­ÙØ¸ Ù…ÙØ§ØªÙŠØ­ API Ù…Ø­Ù„ÙŠÙ‹Ø§ (Ø¬Ù„Ø³Ø© Ù…Ø¤Ù‚ØªØ© ÙÙ‚Ø·)</span>
                        </label>
                    </div>
                    <div class="mb-3">
                        <label class="inline-flex items-center gap-2">
                            <input id="useTmCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2" checked
                                style="color: var(--primary-color);">
                            <span class="text-sm font-medium">Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© (TM)</span>
                        </label>
                        <div class="mt-1 mr-6 flex items-center gap-2">
                            <span id="tmStats" class="text-xs" style="color: var(--secondary-text);">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</span>
                            <button id="clearTmBtn" type="button" class="text-xs px-2 py-1 rounded hover:opacity-75" style="background-color: var(--error-color); color: white;">Ù…Ø³Ø­ Ø§Ù„Ø°Ø§ÙƒØ±Ø©</button>
                        </div>
                    </div>
                    <div class="mb-6">
                        <label class="inline-flex items-center gap-2">
                            <input id="useProofreadCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2"
                                style="color: var(--primary-color);">
                            <span class="text-sm font-medium">ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ø§Ù„Ù„ØºÙˆÙŠ Ø§Ù„Ø¢Ù„ÙŠ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø©</span>
                        </label>
                    </div>

                    <div class="flex items-center justify-between mb-6 p-3 rounded-lg"
                        style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                        <button id="manageSubjectsBtn" type="button" class="font-semibold"
                            style="color: var(--primary-color);">ğŸ“š Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ§Ù„ØµÙÙˆÙ</button>
                    </div>

                    <div class="flex items-center justify-between p-3 rounded-lg"
                        style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                        <button id="manageIdsBtn" type="button" class="font-semibold"
                            style="color: var(--primary-color);">ğŸ†” Ø¥Ø¯Ø§Ø±Ø© Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (mapped_id)</button>
                    </div>
                </div>

                <div>
                    <div class="mb-4">
                        <label class="block mb-2 font-semibold">Ù…Ù„ÙØ§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (JSON):</label>
                        <div id="fileUpload"
                            class="border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition"
                            style="border-color: var(--input-border);">
                            <div style="color: var(--primary-color);" class="text-4xl mb-2">ğŸ“¤</div>
                            <p class="font-semibold">Ø§Ø³Ø­Ø¨ ÙˆØ£ÙÙ„Øª Ø§Ù„Ù…Ù„ÙØ§Øª Ù‡Ù†Ø§ Ø£Ùˆ Ø§Ù†Ù‚Ø± Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±</p>
                            <p class="text-sm mt-1" style="color: var(--secondary-text);">ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ù…Ù„ÙØ§Øª Ø¨ØµÙŠØºØ© JSON
                            </p>
                            <input type="file" id="fileInput" multiple accept=".json" class="hidden">
                        </div>
                    </div>
                    <div id="fileList" class="space-y-2 max-h-40 overflow-y-auto"></div>
                </div>
            </div>

            <button id="translateBtn"
                class="w-full text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none mt-8"
                style="background-color: var(--primary-color);">
                ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ù„ÙØ§Øª (Ctrl + Enter)
            </button>
        </div>

        <div id="progressContainer" class="hidden main-card p-6 rounded-2xl shadow-lg mb-6 text-center">
            <div class="w-16 h-16 border-4 border-dashed rounded-full animate-spin mx-auto"
                style="border-color: var (--primary-color); border-top-color: transparent;"></div>
            <p id="progressText" class="mt-4 text-lg font-semibold">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©...</p>
            <div class="mt-3">
                <button id="cancelTranslationBtn"
                    class="px-4 py-2 rounded-lg bg-red-500 text-white hover:bg-red-600">Ø¥Ù„ØºØ§Ø¡</button>
            </div>
        </div>

        <div id="analyticsSection" class="hidden main-card p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4" style="color: var(--primary-color);">ğŸ“Š ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¬Ù…Ø©</h3>
            <div id="statsContainer" class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center"></div>
        </div>

        <div id="previewSection" class="hidden">
            <div class="main-card p-4 rounded-2xl shadow-lg mb-6">
                <div class="flex flex-wrap gap-4 items-center justify-between">
                    <div>
                        <h3 class="text-2xl font-bold" style="color: var(--success-color);">Ø§Ù„Ø®Ø·ÙˆØ© 2: Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØªØ¹Ø¯ÙŠÙ„
                            Ø§Ù„ØªØ±Ø¬Ù…Ø©</h3>
                        <p class="mt-1" style="color: var(--secondary-text);">Ø±Ø§Ø¬Ø¹ Ø§Ù„ØªØ±Ø§Ø¬Ù…ØŒ Ø¹Ø¯Ù‘Ù„Ù‡Ø§ØŒ ÙˆÙ‚Ø§Ø±Ù†Ù‡Ø§ Ø¨Ø§Ù„Ù†Øµ
                            Ø§Ù„Ø£ØµÙ„ÙŠ.</p>
                    </div>
                    <div class="flex items-center gap-2">
                        <button id="undoBtn" disabled class="px-3 py-2 rounded-lg disabled:opacity-50">â†©ï¸ ØªØ±Ø§Ø¬Ø¹</button>
                        <button id="redoBtn" disabled class="px-3 py-2 rounded-lg disabled:opacity-50">â†ªï¸ Ø¥Ø¹Ø§Ø¯Ø©</button>
                        <button id="openAnnotatorBtn" class="px-3 py-2 rounded-lg"
                            title="ØªØ­Ø±ÙŠØ± Ø§Ù„Ù†Øµ ÙÙˆÙ‚ Ø§Ù„ØµÙˆØ± (Ø£Ø±Ù‚Ø§Ù…/Ø±Ù…ÙˆØ²)">ğŸ–Šï¸ Ù…Ø­Ø±Ø± Ø§Ù„ØµÙˆØ±</button>
                    </div>
                </div>
                <!-- Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø³Ø±ÙŠØ¹Ø© -->
                <div class="grid grid-cols-2 md:grid-cols-5 gap-3 my-4">
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--primary-color);" id="totalFieldsCount">0</div>
                        <div class="text-xs" style="color: var(--secondary-text);">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø­Ù‚ÙˆÙ„</div>
                    </div>
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--success-color);" id="completedFieldsCount">0</div>
                        <div class="text-xs" style="color: var(--secondary-text);">Ù…ÙƒØªÙ…Ù„Ø©</div>
                    </div>
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--warning-color);" id="editedFieldsCount">0</div>
                        <div class="text-xs" style="color: var(--secondary-text);">Ù…Ø¹Ø¯Ù‘Ù„Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹</div>
                    </div>
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--error-color);" id="warningsCount">0</div>
                        <div class="text-xs" style="color: var(--secondary-text);">ØªØ­Ø°ÙŠØ±Ø§Øª</div>
                    </div>
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--primary-color);" id="progressPercentage">0%</div>
                        <div class="text-xs" style="color: var(--secondary-text);">Ù†Ø³Ø¨Ø© Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²</div>
                    </div>
                </div>

                <div class="preview-controls my-4 p-4 rounded-lg"
                    style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                    <!-- Ø§Ù„Ø¨Ø­Ø« -->
                    <div class="flex flex-wrap gap-4 items-center mb-3">
                        <div class="flex-grow">
                            <input type="text" id="searchPreview" placeholder="Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ Ø£Ùˆ Ø§Ù„ØªØ±Ø¬Ù…Ø©..."
                                class="w-full p-2 border rounded-lg">
                        </div>
                    </div>
                    
                    <!-- Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© -->
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-3">
                        <select id="filterByType" class="p-2 border rounded-lg text-sm">
                            <option value="all">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†ÙˆØ§Ø¹</option>
                            <option value="mcq">Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† Ù…ØªØ¹Ø¯Ø¯</option>
                            <option value="input_box">ØµÙ†Ø¯ÙˆÙ‚ Ø¥Ø¯Ø®Ø§Ù„</option>
                            <option value="gap_match">Ù…Ù„Ø¡ Ø§Ù„ÙØ±Ø§ØºØ§Øª</option>
                            <option value="true_false">ØµØ­/Ø®Ø·Ø£</option>
                        </select>
                        
                        <select id="filterByStatus" class="p-2 border rounded-lg text-sm">
                            <option value="all">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø§Ù„Ø§Øª</option>
                            <option value="translated">Ù…ØªØ±Ø¬Ù…Ø© Ø¢Ù„ÙŠØ§Ù‹</option>
                            <option value="edited">Ù…Ø¹Ø¯Ù‘Ù„Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹</option>
                            <option value="warnings">Ø¨Ù‡Ø§ ØªØ­Ø°ÙŠØ±Ø§Øª</option>
                        </select>
                        
                        <select id="sortBy" class="p-2 border rounded-lg text-sm">
                            <option value="default">Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ</option>
                            <option value="warnings">Ø§Ù„Ø£ÙƒØ«Ø± ØªØ­Ø°ÙŠØ±Ø§Øª</option>
                            <option value="longest">Ø§Ù„Ø£Ø·ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹</option>
                            <option value="shortest">Ø§Ù„Ø£Ù‚ØµØ± Ø£ÙˆÙ„Ø§Ù‹</option>
                        </select>
                        
                        <button id="clearFiltersBtn" class="p-2 border rounded-lg text-sm hover:bg-gray-100">
                            ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†
                        </button>
                    </div>
                    
                    <!-- Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ø³Ø±ÙŠØ¹Ø© -->
                    <div class="flex flex-wrap gap-2">
                        <button id="validateAllBtn" class="text-xs px-3 py-2 rounded-lg" 
                                style="background-color: var(--primary-color); color: white;">
                            âœ“ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„
                        </button>
                        
                        <button id="expandAllBtn" class="text-xs px-3 py-2 rounded-lg border">
                            ğŸ“‚ ÙØªØ­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª
                        </button>
                        
                        <button id="collapseAllBtn" class="text-xs px-3 py-2 rounded-lg border">
                            ğŸ“ Ø¥ØºÙ„Ø§Ù‚ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª
                        </button>
                        
                        <button id="jumpToWarningsBtn" class="text-xs px-3 py-2 rounded-lg" 
                                style="background-color: var(--error-color); color: white;">
                            âš ï¸ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„ØªØ­Ø°ÙŠØ±Ø§Øª
                        </button>
                        
                        <button id="reviewModeBtn" class="text-xs px-3 py-2 rounded-lg border">
                            ğŸ‘ï¸ ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©
                        </button>
                    </div>
                </div>
            </div>

            <div id="previewContainer" class="space-y-4"></div>

            <div class="main-card mt-8 p-4 rounded-2xl shadow-lg">
                <div class="flex items-center justify-center gap-4 mb-4">
                    <div class="text-center">
                        <p class="font-semibold mb-2">ØªØµØ¯ÙŠØ± Ø¨ØµÙŠØºØ© JSON</p>
                        <p class="text-sm" style="color: var(--secondary-text);">ÙŠØ­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø£ØµÙ„ÙŠØ© Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø®ØµØ§Ø¦Øµ ÙˆØ§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª</p>
                    </div>
                    <button id="exportBtn"
                        class="text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105"
                        style="background-color: var(--success-color);">
                        ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ØªØ±Ø¬Ù…Ø©
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals (Glossary, Mapped IDs, Subjects) -->
    <!-- Image Annotator Modal -->
    <div id="imageAnnotatorModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-4 w-full max-w-4xl">
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-xl font-bold" style="color: var(--primary-color);">ØªØ­Ø±ÙŠØ± Ù†Øµ ÙÙˆÙ‚ Ø§Ù„ØµÙˆØ±Ø©</h3>
                <button id="imageAnnotatorClose" class="text-2xl">&times;</button>
            </div>
            <div class="w-full overflow-auto" style="max-height:70vh">
                <canvas id="imageAnnotatorCanvas" class="w-full border"
                    style="border-color: var(--card-border);"></canvas>
            </div>
            <div class="flex justify-end gap-2 mt-3">
                <button id="imageAnnotatorSave" class="px-4 py-2 rounded-lg text-white"
                    style="background-color: var(--success-color);">Ø­ÙØ¸</button>
            </div>
        </div>
    </div>
    <div id="mappedIdsModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-2xl transform transition-all" role="dialog"
            aria-labelledby="mappedIdsTitle">
            <div class="flex justify-between items-center">
                <h3 id="mappedIdsTitle" class="text-2xl font-bold" style="color: var(--primary-color);">Ø¥Ø¯Ø§Ø±Ø© Ù…Ø¹Ø±ÙØ§Øª
                    Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (mapped_id)</h3>
                <button id="closeMappedIdsModalBtn" class="text-2xl hover:opacity-75"
                    aria-label="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
            </div>
            <p class="text-sm mt-1 mb-4" style="color: var(--secondary-text);">Ø£Ø¯Ø®Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰
                Ø§Ù„Ø²Ø± Ù„Ø¬Ù„Ø¨Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ØŒ Ø£Ùˆ Ø£Ù„ØµÙ‚Ù‡Ø§ ÙŠØ¯ÙˆÙŠØ§Ù‹.</p>
            <div class="flex gap-2 mb-4">
                <input type="number" id="mappedIdsCount" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¹Ø¯Ø¯"
                    class="p-2 border rounded-lg w-1/3 text-center">
                <button id="fetchMappedIdsBtn" class="flex-1 px-4 py-2 text-sm text-white rounded-lg"
                    style="background-color: var(--primary-color);">Ø¬Ù„Ø¨ Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ Ù…Ù† Nagwa</button>
            </div>
            <textarea id="mappedIdsInput" rows="5" class="w-full p-2 rounded-lg mb-4"
                placeholder='["...","..."]'></textarea>
            <div class="flex items-center">
                <input id="useMappedIdsCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2"
                    style="color: var(--primary-color);">
                <label for="useMappedIdsCheckbox" class="mr-2 text-sm font-medium">ØªÙØ¹ÙŠÙ„ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ø¹Ù†Ø¯
                    Ø§Ù„ØªØµØ¯ÙŠØ±</label>
            </div>
        </div>
    </div>

    <div id="subjectsModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-3xl transform transition-all" role="dialog"
            aria-labelledby="subjectsTitle">
            <div class="flex justify-between items-center">
                <h3 id="subjectsTitle" class="text-2xl font-bold" style="color: var(--primary-color);">Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…ÙˆØ§Ø¯
                    ÙˆØ§Ù„ØµÙÙˆÙ</h3>
                <button id="closeSubjectsModalBtn" class="text-2xl hover:opacity-75" aria-label="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
            </div>
            <p class="text-sm mt-1 mb-4" style="color: var(--secondary-text);">Ø§Ø®ØªØ± Ø§Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„ØµÙ Ù„ØªØ·Ø¨ÙŠÙ‚ ØªØ¹Ù„ÙŠÙ…Ø§Øª ØªØ±Ø¬Ù…Ø© Ù…Ø®ØµØµØ© ÙˆØ¬Ù„Ø¨ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©.</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <select id="subjectSelect" class="p-2 border rounded-lg w-full"></select>
                <select id="gradeSelect" class="p-2 border rounded-lg w-full"></select>
            </div>
            <h4 class="text-lg font-semibold mb-2">Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª (Ø§Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª)</h4>
            <textarea id="promptPreview" rows="8" class="w-full p-2 rounded-lg mb-4" readonly></textarea>
            <button id="applyPromptBtn" class="w-full text-white font-bold py-2 px-4 rounded-lg"
                style="background-color: var(--success-color);">ØªØ·Ø¨ÙŠÙ‚ ÙˆØ­ÙØ¸</button>
        </div>
    </div>

    <script>

        const GOOGLE_SHEET_ID = '16-ant77j9ckFE7y48mOaqmMvUQrx8ZzM-ksWHaFNSUU';

        const TranslatorApp = {
            constants: {
                BATCH_SEPARATOR: "\\n|||---|||\\n",
                CONTEXT_SEPARATOR: "\\n<SEP>\\n",
                HISTORY_MAX: 20,
                CHUNK_SIZE: 40
            },

            state: {
                selectedFilesInfo: [],
                originalJsonData: [],
                translatedJsonData: [],
                initialTranslatedJsonData: [],
                activeScreen: 'setup',
                translationCache: new Map(),
                startTime: null,
                hasUnsavedChanges: false,
                selectedSubject: 'None',
                selectedGrade: 'None',
                fileStore: new Map(),
                isTranslating: false,
                translators: {
                  "Aya Abulmagd": "643164068106",
                  "Salma Hafez": "927169194769",
                  "Hend El Husseiny": "805189370751",
                  "Salma Zaki": "698106520137",
                  "Esraa Shahien": "937145789737",
                  "Fatema Samy": "719130548578",
                  "Samar Bahaaeldin": "694164363692",
                  "Lobna Adel": "925171517156",
                  "Shady Donia": "963163430437",
                  "Zeina Elsheikh": "154106968213",
                  "Aiat Saied": "942130798452",
                  "Monica Sidhom": "819178319024",
                  "Yara Sobhy": "618146184254",
                  "Mariam Ghonaim": "182136230818",
                  "Hussein Mahmoud": "676130390838",
                  "Gehan Khaled": "475149294140",
                  "Ahmed Sabra": "175196786128",
                  "Ahmed Alhefny": "120171982460"
                    },
                selectedTranslator: "",
            },

            dom: {},

            init() {
                try {
                    this.cacheDomElements();
                    this.bindEvents();
                    this.theme.init();
                    this.history.init();
                    this.subjects.init();
                    this.translationMemory.init();
                    this.session.load();
                    this.shortcuts.init();
                    this.autoSave.init();
                    this.addBeforeUnloadGuard();
                    // Initialize shared MathLive virtual keyboard if available
                    try {
                        if (window.MathfieldElement) {
                            // Configure MathLive defaults
                            if (window.MathfieldElement.defaultConfig) {
                                window.MathfieldElement.defaultConfig = {
                                    ...window.MathfieldElement.defaultConfig,
                                    virtualKeyboardMode: 'onfocus',
                                    virtualKeyboardTheme: 'material',
                                    virtualKeyboards: 'numeric symbols greek',
                                    inlineShortcuts: true,
                                    smartMode: true,
                                    smartFence: true,
                                    smartSuperscript: true,
                                    keypressVibration: true,
                                };
                            }
                            
                            // Create shared virtual keyboard
                            if (typeof MathfieldElement.makeSharedVirtualKeyboard === 'function') {
                                MathfieldElement.makeSharedVirtualKeyboard();
                            }
                        }
                    } catch (mathError) {
                        console.warn('MathLive initialization error:', mathError);
                    }
                    
                    // Validate translation requirements on init (disable translate button initially)
                    setTimeout(() => {
                        this.validateTranslationRequirements();
                    }, 100);
                } catch (error) {
                    console.error('Application initialization error:', error);
                    TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚. ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©.', 'error');
                }
            },

            cacheDomElements() {
                try {
                    const ids = {
                        alertContainer: 'alertContainer', newSessionBtn: 'newSessionBtn',
                        fileUpload: 'fileUpload', fileInput: 'fileInput', fileList: 'fileList',
                        translateBtn: 'translateBtn', geminiKeyInput: 'geminiKey', chatgptKeyInput: 'chatgptKey',
                        geminiKeyGroup: 'geminiKeyGroup', chatgptKeyGroup: 'chatgptKeyGroup',
                        localModelGroup: 'localModelGroup', localModelUrl: 'localModelUrl', localModelName: 'localModelName',
                        setupSection: 'setupSection', progressContainer: 'progressContainer', progressText: 'progressText',
                        previewSection: 'previewSection', previewContainer: 'previewContainer', exportBtn: 'exportBtn',
                        themeToggle: 'theme-toggle', analyticsSection: 'analyticsSection',
                        statsContainer: 'statsContainer',
                        searchPreview: 'searchPreview', undoBtn: 'undoBtn', redoBtn: 'redoBtn',
                        imageAnnotatorModal: 'imageAnnotatorModal',
                        imageAnnotatorCanvas: 'imageAnnotatorCanvas',
                        imageAnnotatorClose: 'imageAnnotatorClose',
                        imageAnnotatorSave: 'imageAnnotatorSave',
                        mappedIdsInput: 'mappedIdsInput', useMappedIdsCheckbox: 'useMappedIdsCheckbox',
                        manageIdsBtn: 'manageIdsBtn', mappedIdsModal: 'mappedIdsModal',
                        closeMappedIdsModalBtn: 'closeMappedIdsModalBtn',
                        mappedIdsCount: 'mappedIdsCount', fetchMappedIdsBtn: 'fetchMappedIdsBtn',
                        manageSubjectsBtn: 'manageSubjectsBtn', subjectsModal: 'subjectsModal',
                        closeSubjectsModalBtn: 'closeSubjectsModalBtn', subjectSelect: 'subjectSelect',
                        gradeSelect: 'gradeSelect', promptPreview: 'promptPreview', applyPromptBtn: 'applyPromptBtn',
                        cancelTranslationBtn: 'cancelTranslationBtn', saveIndicator: 'saveIndicator',
                        ephemeralKeysCheckbox: 'ephemeralKeysCheckbox',
                        useTmCheckbox: 'useTmCheckbox', useProofreadCheckbox: 'useProofreadCheckbox', translatorSelect: 'translatorSelect',
                        tmStats: 'tmStats', clearTmBtn: 'clearTmBtn',
                        totalFieldsCount: 'totalFieldsCount', completedFieldsCount: 'completedFieldsCount',
                        editedFieldsCount: 'editedFieldsCount', warningsCount: 'warningsCount', progressPercentage: 'progressPercentage',
                        filterByType: 'filterByType', filterByStatus: 'filterByStatus', sortBy: 'sortBy', clearFiltersBtn: 'clearFiltersBtn',
                        validateAllBtn: 'validateAllBtn', expandAllBtn: 'expandAllBtn', collapseAllBtn: 'collapseAllBtn',
                        jumpToWarningsBtn: 'jumpToWarningsBtn', reviewModeBtn: 'reviewModeBtn'
                    };
                    for (const k in ids) {
                        try {
                            this.dom[k] = document.getElementById(ids[k]);
                            if (!this.dom[k] && k !== 'glossaryCategory') {
                                console.warn(`DOM element not found: ${k}`);
                            }
                        } catch (elementError) {
                            console.warn(`Error caching DOM element ${k}:`, elementError);
                        }
                    }
                    this.dom.apiProviderRadios = document.querySelectorAll('input[name="apiProvider"]');
                } catch (error) {
                    console.error('Cache DOM elements error:', error);
                    throw new Error('ÙØ´Ù„ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ø¹Ù†Ø§ØµØ± ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…');
                }
            },

            bindEvents() {
                try {
                    this.dom.previewContainer.addEventListener('input', (e) => {
                        try {
                            if (e.target.classList.contains('editable-unit')) {
                                const fieldContainer = e.target.closest('.editable-preview-field');
                                if (fieldContainer) {
                                    this.preview.handleUnitUpdate(fieldContainer, e.target.textContent);
                                }
                            } else {
                                const fieldContainer = e.target.closest('.editable-preview-field');
                                if (fieldContainer) {
                                    this.preview.handlePreviewFieldUpdate(fieldContainer);
                                }
                            }
                        } catch (error) {
                            console.error('Preview input event error:', error);
                        }
                    });
                    this.dom.previewContainer.addEventListener('keydown', (e) => {
                        // Protect math-fields from accidental deletion
                        if (e.key === 'Backspace' || e.key === 'Delete') {
                            const selection = window.getSelection();
                            if (!selection.rangeCount) return;

                            const range = selection.getRangeAt(0);
                            const focusNode = range.startContainer;
                            
                            // Check if we're inside a math-field
                            const parentMathField = focusNode.parentNode?.closest('math-field');
                            
                            // Only delete math-field if it's empty AND user is inside it
                            if (parentMathField && parentMathField.value.trim() === '') {
                                e.preventDefault();
                                const fieldContainer = parentMathField.closest('.editable-preview-field');
                                parentMathField.remove();
                                if (fieldContainer) {
                                    TranslatorApp.preview.handlePreviewFieldUpdate(fieldContainer);
                                }
                                return;
                            }
                            
                            // Prevent deletion of math-field when deleting adjacent text
                            const editableField = focusNode.parentNode?.closest('.editable-preview-field');
                            if (!editableField) return;
                            
                            // Enhanced protection: Check all possible sibling scenarios
                            if (e.key === 'Backspace') {
                                // Check direct previous sibling
                                const prevSibling = range.startContainer.previousSibling;
                                // Check if parent's previous sibling is math-field
                                const parentPrevSibling = range.startContainer.parentNode?.previousSibling;
                                
                                if ((prevSibling?.tagName === 'MATH-FIELD' && range.startOffset === 0) ||
                                    (parentPrevSibling?.tagName === 'MATH-FIELD' && range.startOffset === 0)) {
                                    // Place cursor before math-field instead of deleting it
                                    e.preventDefault();
                                    const mathField = prevSibling?.tagName === 'MATH-FIELD' ? prevSibling : parentPrevSibling;
                                    const newRange = document.createRange();
                                    newRange.setStartBefore(mathField);
                                    newRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                    return;
                                }
                            } else if (e.key === 'Delete') {
                                // Check direct next sibling
                                const nextSibling = range.startContainer.nextSibling;
                                // Check if parent's next sibling is math-field
                                const parentNextSibling = range.startContainer.parentNode?.nextSibling;
                                
                                if (nextSibling?.tagName === 'MATH-FIELD' || parentNextSibling?.tagName === 'MATH-FIELD') {
                                    // Place cursor after math-field instead of deleting it
                                    e.preventDefault();
                                    const mathField = nextSibling?.tagName === 'MATH-FIELD' ? nextSibling : parentNextSibling;
                                    const newRange = document.createRange();
                                    newRange.setStartAfter(mathField);
                                    newRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                    return;
                                }
                            }
                        }
                    }, true);
                    
                    this.dom.newSessionBtn.addEventListener('click', (e) => {
                        try {
                            this.session.clear.bind(this.session)();
                        } catch (error) {
                            console.error('New session error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø¨Ø¯Ø¡ Ø¬Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©.', 'error');
                        }
                    });
                    this.dom.apiProviderRadios.forEach(radio => radio.addEventListener('change', (e) => {
                        try {
                            this.events.onApiProviderChange.bind(this)(e);
                        } catch (error) {
                            console.error('API provider radio change error:', error);
                        }
                    }));
                    this.dom.fileUpload.addEventListener('click', (e) => {
                        try {
                            this.dom.fileInput.click();
                        } catch (error) {
                            console.error('File upload click error:', error);
                        }
                    });
                    this.dom.fileUpload.addEventListener('dragover', (e) => {
                        try {
                            this.events.onDragOver(e);
                        } catch (error) {
                            console.error('Drag over error:', error);
                        }
                    });
                    this.dom.previewContainer.addEventListener('keydown', (e) => {
                        try {
                            const isEditable = e.target.closest('.editable-preview-field');
                            if (!isEditable) return;
                    
                            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'm') {
                                e.preventDefault();
                                const selection = window.getSelection();
                                if (!selection.rangeCount) return;
                                const range = selection.getRangeAt(0);
                                
                                // Create a new math-field element
                                const newMathField = document.createElement('math-field');
                                newMathField.setAttribute('default-mode', 'inline-math');
                                newMathField.setAttribute('value', '');
                                newMathField.setAttribute('virtual-keyboard-mode', 'onfocus');
                                newMathField.setAttribute('use-shared-virtual-keyboard', '');
                                newMathField.setAttribute('dir', 'ltr');
                                
                                // Insert the new math field
                                range.insertNode(newMathField);
                                
                                // Focus the cursor inside the new math field
                                newMathField.focus();
                    
                                TranslatorApp.preview.handlePreviewFieldUpdate(isEditable);
                            }
                        } catch (error) {
                            console.error('Math field shortcut error:', error);
                        }
                    }, true); // Use `true` for capture phase to ensure it runs before other handlers
                    
                    this.dom.fileUpload.addEventListener('dragleave', (e) => {
                        try {
                            this.events.onDragLeave(e);
                        } catch (error) {
                            console.error('Drag leave error:', error);
                        }
                    });
                    this.dom.fileUpload.addEventListener('drop', (e) => {
                        try {
                            this.events.onFileDrop.bind(this)(e);
                        } catch (error) {
                            console.error('File drop error:', error);
                        }
                    });
                    this.dom.fileInput.addEventListener('change', (e) => {
                        try {
                            this.events.onFileSelect.bind(this)(e);
                        } catch (error) {
                            console.error('File input change error:', error);
                        }
                    });
                    this.dom.translateBtn.addEventListener('click', (e) => {
                        try {
                            this.startTranslationProcess.bind(this)();
                        } catch (error) {
                            console.error('Start translation error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ±Ø¬Ù…Ø©.', 'error');
                        }
                    });
                    this.dom.cancelTranslationBtn.addEventListener('click', (e) => {
                        try {
                            this.api.cancel.bind(this.api)();
                        } catch (error) {
                            console.error('Cancel translation error:', error);
                        }
                    });
                    this.dom.exportBtn.addEventListener('click', (e) => {
                        try {
                            this.export.exportAs('json');
                        } catch (error) {
                            console.error('Export error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ù„ÙØ§Øª.', 'error');
                        }
                    });
                    
                    // New feature: Expand/Collapse All
                    this.dom.expandAllBtn?.addEventListener('click', () => {
                        try {
                            document.querySelectorAll('.accordion-content').forEach(content => {
                                content.style.maxHeight = content.scrollHeight + "px";
                                const parent = content.closest('.preview-card');
                                if (parent) parent.classList.add('open');
                            });
                        } catch (error) {
                            console.error('Expand all error:', error);
                        }
                    });
                    
                    this.dom.collapseAllBtn?.addEventListener('click', () => {
                        try {
                            document.querySelectorAll('.accordion-content').forEach(content => {
                                content.style.maxHeight = null;
                                const parent = content.closest('.preview-card');
                                if (parent) parent.classList.remove('open');
                            });
                        } catch (error) {
                            console.error('Collapse all error:', error);
                        }
                    });
                    
                    // Jump to warnings
                    this.dom.jumpToWarningsBtn?.addEventListener('click', () => {
                        try {
                            const firstWarning = document.querySelector('.field-error, .field-warning');
                            if (firstWarning) {
                                firstWarning.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                firstWarning.style.animation = 'pulse 1s ease-in-out 3';
                            } else {
                                TranslatorApp.ui.showAlert('Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ­Ø°ÙŠØ±Ø§Øª', 'success', 2000);
                            }
                        } catch (error) {
                            console.error('Jump to warnings error:', error);
                        }
                    });
                    
                    // Validate all fields
                    this.dom.validateAllBtn?.addEventListener('click', () => {
                        try {
                            TranslatorApp.preview.validateAllFields();
                        } catch (error) {
                            console.error('Validate all error:', error);
                        }
                    });
                    
                    // Review mode toggle
                    this.dom.reviewModeBtn?.addEventListener('click', () => {
                        try {
                            const previewSection = document.getElementById('previewSection');
                            previewSection?.classList.toggle('review-mode');
                            const isReviewMode = previewSection?.classList.contains('review-mode');
                            this.dom.reviewModeBtn.textContent = isReviewMode ? 'âœ“ Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©' : 'ğŸ‘ï¸ ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©';
                        } catch (error) {
                            console.error('Review mode toggle error:', error);
                        }
                    });
                    
                    // Filters
                    this.dom.filterByType?.addEventListener('change', () => {
                        try {
                            TranslatorApp.preview.applyFilters();
                        } catch (error) {
                            console.error('Filter by type error:', error);
                        }
                    });
                    
                    this.dom.filterByStatus?.addEventListener('change', () => {
                        try {
                            TranslatorApp.preview.applyFilters();
                        } catch (error) {
                            console.error('Filter by status error:', error);
                        }
                    });
                    
                    this.dom.sortBy?.addEventListener('change', () => {
                        try {
                            TranslatorApp.preview.applyFilters();
                        } catch (error) {
                            console.error('Sort by error:', error);
                        }
                    });
                    
                    this.dom.clearFiltersBtn?.addEventListener('click', () => {
                        try {
                            if (this.dom.filterByType) this.dom.filterByType.value = 'all';
                            if (this.dom.filterByStatus) this.dom.filterByStatus.value = 'all';
                            if (this.dom.sortBy) this.dom.sortBy.value = 'default';
                            TranslatorApp.preview.applyFilters();
                        } catch (error) {
                            console.error('Clear filters error:', error);
                        }
                    });
                    this.dom.geminiKeyInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Gemini key input error:', error);
                        }
                    });
                    this.dom.chatgptKeyInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('ChatGPT key input error:', error);
                        }
                    });
                    this.dom.localModelUrl.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Local model URL input error:', error);
                        }
                    });
                    this.dom.localModelName.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Local model name input error:', error);
                        }
                    });
                    this.dom.themeToggle.addEventListener('click', (e) => {
                        try {
                            this.theme.toggle.bind(this.theme)();
                        } catch (error) {
                            console.error('Theme toggle error:', error);
                        }
                    });
                    this.dom.mappedIdsInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Mapped IDs input error:', error);
                        }
                    });
                    this.dom.useMappedIdsCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Use mapped IDs checkbox error:', error);
                        }
                    });
                    this.dom.ephemeralKeysCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Ephemeral keys checkbox error:', error);
                        }
                    });
                    this.dom.useTmCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                            this.translationMemory.updateUI();
                        } catch (error) {
                            console.error('Use TM checkbox error:', error);
                        }
                    });
                    this.dom.useProofreadCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Use proofread checkbox error:', error);
                        }
                    });
                    
                    this.dom.clearTmBtn.addEventListener('click', (e) => {
                        try {
                            if (confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ±Ø¬Ù…Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©ØŸ\nÙ„Ù† ØªØªÙ…ÙƒÙ† Ù…Ù† Ø§Ø³ØªØ¹Ø§Ø¯ØªÙ‡Ø§ Ø¨Ø¹Ø¯ Ø§Ù„Ø­Ø°Ù.')) {
                                this.translationMemory.clear();
                                this.translationMemory.updateUI();
                                this.ui.showAlert('ØªÙ… Ù…Ø³Ø­ Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­', 'success');
                            }
                        } catch (error) {
                            console.error('Clear TM error:', error);
                        }
                    });

                    this.dom.searchPreview.addEventListener('input', (e) => {
                        try {
                            this.preview.filter.bind(this.preview)();
                        } catch (error) {
                            console.error('Search preview error:', error);
                        }
                    });
                    this.dom.undoBtn.addEventListener('click', (e) => {
                        try {
                            this.history.undo.bind(this.history)();
                        } catch (error) {
                            console.error('Undo error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø§Ù„ØªØ±Ø§Ø¬Ø¹.', 'error');
                        }
                    });
                    this.dom.redoBtn.addEventListener('click', (e) => {
                        try {
                            this.history.redo.bind(this.history)();
                        } catch (error) {
                            console.error('Redo error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø¥Ø¹Ø§Ø¯Ø©.', 'error');
                        }
                    });

                    this.dom.manageIdsBtn.addEventListener('click', () => {
                        try {
                            this.ui.showMappedIdsModal(true);
                        } catch (error) {
                            console.error('Show mapped IDs modal error:', error);
                        }
                    });
                    this.dom.closeMappedIdsModalBtn.addEventListener('click', () => {
                        try {
                            this.ui.showMappedIdsModal(false);
                        } catch (error) {
                            console.error('Close mapped IDs modal error:', error);
                        }
                    });
                    this.dom.fetchMappedIdsBtn.addEventListener('click', (e) => {
                        try {
                            this.mappedIds.fetch.bind(this.mappedIds)();
                        } catch (error) {
                            console.error('Fetch mapped IDs error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª.', 'error');
                        }
                    });

                    this.dom.manageSubjectsBtn.addEventListener('click', () => {
                        try {
                            this.ui.showSubjectsModal(true);
                        } catch (error) {
                            console.error('Show subjects modal error:', error);
                        }
                    });
                    this.dom.closeSubjectsModalBtn.addEventListener('click', () => {
                        try {
                            this.ui.showSubjectsModal(false);
                        } catch (error) {
                            console.error('Close subjects modal error:', error);
                        }
                    });
                    this.dom.subjectSelect.addEventListener('change', (e) => {
                        try {
                            this.subjects.onSubjectChange.bind(this.subjects)();
                            // Check if all required fields are selected
                            TranslatorApp.validateTranslationRequirements();
                        } catch (error) {
                            console.error('Subject change error:', error);
                        }
                    });
                    this.dom.gradeSelect.addEventListener('change', (e) => {
                        try {
                            this.subjects.onGradeChange.bind(this.subjects)();
                            // Check if all required fields are selected
                            TranslatorApp.validateTranslationRequirements();
                        } catch (error) {
                            console.error('Grade change error:', error);
                        }
                    });
                    this.dom.applyPromptBtn.addEventListener('click', (e) => {
                        try {
                            this.subjects.apply.bind(this.subjects)();
                        } catch (error) {
                            console.error('Apply prompt error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª.', 'error');
                        }
                    });

                    // Image annotator events
                    const openAnnotatorBtn = document.getElementById('openAnnotatorBtn');
                    if (openAnnotatorBtn) {
                        openAnnotatorBtn.addEventListener('click', (e) => {
                            try {
                                this.annotator.open.bind(this.annotator)();
                            } catch (error) {
                                console.error('Open annotator error:', error);
                                TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ÙØªØ­ Ù…Ø­Ø±Ø± Ø§Ù„ØµÙˆØ±.', 'error');
                            }
                        });
                    }
                    this.dom.imageAnnotatorClose.addEventListener('click', (e) => {
                        try {
                            this.annotator.close.bind(this.annotator)();
                        } catch (error) {
                            console.error('Close annotator error:', error);
                        }
                    });
                    this.dom.imageAnnotatorSave.addEventListener('click', (e) => {
                        try {
                            this.annotator.save.bind(this.annotator)();
                        } catch (error) {
                            console.error('Save annotator error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±Ø©.', 'error');
                        }
                    });

                    // Event delegation for all preview field updates
                    this.dom.previewContainer.addEventListener('input', (e) => {
                        try {
                            const fieldContainer = e.target.closest('.editable-preview-field');
                            if (fieldContainer) {
                                this.preview.handlePreviewFieldUpdate(fieldContainer);
                            }
                        } catch (error) {
                            console.error('Preview field update error:', error);
                        }
                    });
                    this.dom.previewContainer.addEventListener('copy', (e) => {
                        try {
                            this.preview.handleCopyEvent(e);
                        } catch (error) {
                            console.error('Copy event error:', error);
                        }
                    });

                    this.dom.previewContainer.addEventListener('paste', (e) => {
                        try {
                            this.preview.handlePasteEvent(e);
                        } catch (error) {
                            console.error('Paste event error:', error);
                        }
                    });
                    
                    // Ensure MathLive keyboard opens for inline chemistry/math on focus
                    this.dom.previewContainer.addEventListener('pointerdown', (e) => {
                        try {
                            const mf = e.target && e.target.closest && e.target.closest('math-field');
                            if (mf) {
                                try {
                                    mf.removeAttribute('read-only');
                                    mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                    mf.setAttribute('use-shared-virtual-keyboard', '');
                                    if (typeof mf.executeCommand === 'function') {
                                        setTimeout(() => {
                                            try {
                                                mf.executeCommand('showVirtualKeyboard');
                                                mf.focus();
                                            } catch (err) {
                                                console.warn('MathLive keyboard error:', err);
                                            }
                                        }, 100);
                                    }
                                    e.stopPropagation();
                                } catch (err) {
                                    console.warn('MathLive setup error:', err);
                                }
                            }
                        } catch (error) {
                            console.error('MathLive pointerdown error:', error);
                        }
                    });
                    this.dom.translatorSelect.addEventListener('change', (e) => {
                      try {
                        const selectedName = e.target.value;
                        // Update the global state with the selected translator's name
                        TranslatorApp.state.selectedTranslator = selectedName;
                        TranslatorApp.state.hasUnsavedChanges = true;
                        
                        // Check if all required fields are selected
                        TranslatorApp.validateTranslationRequirements();
                        
                        if (selectedName) {
                          const sourceId = TranslatorApp.state.translators[selectedName];
                          TranslatorApp.ui.showAlert(`ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…ØªØ±Ø¬Ù…: ${selectedName} (ID: ${sourceId}).`, 'info', 3000);
                        } else {
                          TranslatorApp.ui.showAlert('Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù…ØªØ±Ø¬Ù…. Ù„Ù† ØªØªÙ… Ø¥Ø¶Ø§ÙØ© source_id.', 'warning', 3000);
                        }
                      } catch (error) {
                          console.error('Translator select change error:', error);
                          TranslatorApp.ui.showAlert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…ØªØ±Ø¬Ù….', 'error');
                      }
                    });
                    this.dom.mappedIdsInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                            // Re-render the preview to show the new mapped ID
                            this.preview.render();
                        } catch (error) {
                            console.error('Mapped IDs input error:', error);
                        }
                    });
                    this.dom.useMappedIdsCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                            // Re-render the preview to show/hide the mapped ID
                            this.preview.render();
                        } catch (error) {
                            console.error('Use mapped IDs checkbox error:', error);
                        }
                    });
                } catch (error) {
                    console.error('bindEvents error:', error);
                    try { TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø±Ø¨Ø· Ø§Ù„Ø£Ø­Ø¯Ø§Ø«.', 'error'); } catch { }
                }
            },

            events: {
                onApiProviderChange(e) {
                    try {
                        const provider = e.target.value;
                        TranslatorApp.dom.geminiKeyGroup.classList.toggle('hidden', provider !== 'gemini');
                        TranslatorApp.dom.chatgptKeyGroup.classList.toggle('hidden', provider !== 'chatgpt');
                        TranslatorApp.dom.localModelGroup.classList.toggle('hidden', provider !== 'local');
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('API provider change error:', error);
                    }
                },
                onDragOver(e) {
                    try {
                        e.preventDefault();
                        e.currentTarget.classList.add('dragover');
                    } catch (error) {
                        console.error('Drag over error:', error);
                    }
                },
                onDragLeave(e) {
                    try {
                        e.preventDefault();
                        e.currentTarget.classList.remove('dragover');
                    } catch (error) {
                        console.error('Drag leave error:', error);
                    }
                },
                onFileDrop(e) {
                    try {
                        e.preventDefault();
                        TranslatorApp.dom.fileUpload.classList.remove('dragover');
                        TranslatorApp.fileHandler.addFiles(e.dataTransfer.files);
                    } catch (error) {
                        console.error('File drop error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù„ÙØ§Øª.', 'error');
                    }
                },
                onFileSelect(e) {
                    try {
                        TranslatorApp.fileHandler.addFiles(e.target.files);
                    } catch (error) {
                        console.error('File select error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù„ÙØ§Øª.', 'error');
                    }
                }
            },

            theme: {
                init() {
                    const savedTheme = localStorage.getItem('translatorTheme') || 'light';
                    this.set(savedTheme);
                },
                toggle() {
                    const current = document.documentElement.getAttribute('data-theme');
                    this.set(current === 'dark' ? 'light' : 'dark');
                },
                set(themeName) {
                    document.documentElement.setAttribute('data-theme', themeName);
                    localStorage.setItem('translatorTheme', themeName);
                    TranslatorApp.dom.themeToggle.textContent = themeName === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
                }
            },

            shortcuts: {
                init() {
                    document.addEventListener('keydown', (e) => {
                        try {
                            if (e.ctrlKey || e.metaKey) {
                                const isEditable = e.target.closest('[contenteditable="true"]');
                                const isMathField = e.target.closest('math-field');
                                if (isEditable || isMathField) {
                                    return; // Exit and let the browser's native undo handle it.
                                }
                                switch (e.key.toLowerCase()) {
                                    case 's':
                                        e.preventDefault();
                                        TranslatorApp.session.save();
                                        TranslatorApp.ui.setSaveIndicator('saved');
                                        break;
                                    case 'o':
                                        e.preventDefault();
                                        TranslatorApp.dom.fileInput.click();
                                        break;
                                    case 'enter':
                                        if (TranslatorApp.state.activeScreen === 'setup') {
                                            e.preventDefault();
                                            TranslatorApp.dom.translateBtn.click();
                                        }
                                        break;
                                    case 'z':
                                        e.preventDefault();
                                        TranslatorApp.history.undo();
                                        break;
                                    case 'y':
                                        e.preventDefault();
                                        TranslatorApp.history.redo();
                                        break;
                                    case 'm':
                                    case 'M': // Support both lowercase and uppercase
                                        if (isEditable) {
                                            e.preventDefault();
                                            const selection = window.getSelection();
                                            if (!selection.rangeCount) return;
                                            const range = selection.getRangeAt(0);
                                    
                                            // Create and configure a new math-field element
                                            const newMathField = document.createElement('math-field');
                                            newMathField.setAttribute('default-mode', 'inline-math');
                                            newMathField.setAttribute('value', '');
                                            newMathField.setAttribute('virtual-keyboard-mode', 'onfocus');
                                            newMathField.setAttribute('use-shared-virtual-keyboard', '');
                                            newMathField.setAttribute('dir', 'ltr');
                                            
                                            // Insert math field
                                            range.insertNode(newMathField);
                                            
                                            // Add a zero-width space after the math field to allow cursor placement
                                            const zwsp = document.createTextNode('\u200B');
                                            newMathField.parentNode.insertBefore(zwsp, newMathField.nextSibling);
                                            
                                            // Place cursor inside the new math field
                                            newMathField.focus();
                                    
                                            TranslatorApp.preview.handlePreviewFieldUpdate(isEditable.closest('.editable-preview-field'));
                                        }
                                        break;
                                }
                            }

                            // MathLive language toggle shortcut (Alt + L)
                            if (e.ctrlKey && e.altKey && e.key === 'k') {
                                e.preventDefault();
                                TranslatorApp.utils.mathLive.toggleLanguage();
                            }

                            // Alt+M as alternative for inserting math field (for keyboards where Ctrl+M doesn't work)
                            if (e.altKey && !e.ctrlKey && (e.key === 'm' || e.key === 'M')) {
                                const isEditable = e.target.closest('.editable-preview-field');
                                if (isEditable && isEditable.isContentEditable) {
                                    e.preventDefault();
                                    const selection = window.getSelection();
                                    if (!selection.rangeCount) return;
                                    const range = selection.getRangeAt(0);
                            
                                    // Create and configure a new math-field element
                                    const newMathField = document.createElement('math-field');
                                    newMathField.setAttribute('default-mode', 'inline-math');
                                    newMathField.setAttribute('value', '');
                                    newMathField.setAttribute('virtual-keyboard-mode', 'onfocus');
                                    newMathField.setAttribute('use-shared-virtual-keyboard', '');
                                    newMathField.setAttribute('dir', 'ltr');
                                    
                                    // Insert math field
                                    range.insertNode(newMathField);
                                    
                                    // Add a zero-width space after the math field to allow cursor placement
                                    const zwsp = document.createTextNode('\u200B');
                                    newMathField.parentNode.insertBefore(zwsp, newMathField.nextSibling);
                                    
                                    // Place cursor inside the new math field
                                    newMathField.focus();
                            
                                    TranslatorApp.preview.handlePreviewFieldUpdate(isEditable.closest('.editable-preview-field'));
                                }
                            }

                        } catch (error) {
                            console.error('Shortcut error:', error);
                        }
                    });
                }
            },

            addBeforeUnloadGuard() {
                window.addEventListener('beforeunload', (e) => {
                    try {
                        if (TranslatorApp.state.hasUnsavedChanges) {
                            e.preventDefault();
                            e.returnValue = '';
                        }
                    } catch (error) {
                        console.error('Before unload error:', error);
                    }
                });
            },

            utils: {
                collectAllTextsFromFiles(filesArr) {
                    const bag = new Set();
                    const toPlain = (html) => {
                        if (typeof html !== 'string') return '';
                        const div = document.createElement('div');
                        div.innerHTML = html;
                        return (div.textContent || div.innerText || '').trim();
                    };

                    const traverse = (obj) => {
                        if (!obj) return;
                        if (Array.isArray(obj)) {
                            obj.forEach(item => traverse(item));
                        } else if (typeof obj === 'object') {
                            Object.keys(obj).forEach(key => {
                                const value = obj[key];
                                // **IMPROVEMENT**: More specific keys to check for translatable content
                                const translatableKeys = ['stem', 'html_content', 'answer', 'statement', 'student_answer', 'comment'];
                                if (translatableKeys.includes(key) && typeof value === 'string') {
                                    const plain = toPlain(value);
                                    if (plain) bag.add(plain);
                                } else if (key === 'gap_text_keys' && Array.isArray(value)) {
                                    value.forEach(item => {
                                        if (item && typeof item.value === 'string') {
                                            const plain = toPlain(item.value);
                                            if (plain) bag.add(plain);
                                        }
                                    });
                                }
                                else {
                                    traverse(value);
                                }
                            });
                        }
                    };

                    filesArr.forEach(f => {
                        if (f.data) traverse(f.data);
                    });

                    return Array.from(bag);
                },
                escapeRegex(str) { return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); },

                // MathLive language utilities
                mathLive: {
                    // Toggle language for all math fields
                    toggleLanguage() {
                        try {
                            const mathFields = document.querySelectorAll('math-field');
                            mathFields.forEach(mf => {
                                const currentLang = mf.getAttribute('virtual-keyboard-default-language') || 'ar';
                                const newLang = currentLang === 'ar' ? 'en' : 'ar';
                                mf.setAttribute('virtual-keyboard-default-language', newLang);
                                mf.setAttribute('dir', newLang === 'ar' ? 'rtl' : 'ltr');
                            });

                            const langText = newLang === 'ar' ? 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©' : 'English';
                            TranslatorApp.ui.showAlert(`ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ ${langText} Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©`, 'info', 2000);
                        } catch (error) {
                            console.error('Toggle language error:', error);
                        }
                    },

                    // Set language for specific math field
                    setLanguage(mathField, language) {
                        try {
                            if (!mathField || !language) return;

                            mathField.setAttribute('virtual-keyboard-default-language', language);
                            mathField.setAttribute('dir', language === 'ar' ? 'rtl' : 'ltr');

                            const langText = language === 'ar' ? 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©' : 'English';
                            TranslatorApp.ui.showAlert(`ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ ${langText}`, 'info', 1500);
                        } catch (error) {
                            console.error('Set language error:', error);
                        }
                    },

                    // Get current language of math field
                    getLanguage(mathField) {
                        try {
                            if (!mathField) return 'ar';
                            return mathField.getAttribute('virtual-keyboard-default-language') || 'ar';
                        } catch (error) {
                            console.error('Get language error:', error);
                            return 'ar';
                        }
                    },

                    // Detect language from text content
                    detectLanguage(text) {
                        try {
                            if (!text || typeof text !== 'string') return 'ar';

                            const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(text);
                            const hasEnglish = /[a-zA-Z]/.test(text);

                            if (hasArabic && !hasEnglish) return 'ar';
                            if (hasEnglish && !hasArabic) return 'en';
                            return 'ar'; // Default to Arabic
                        } catch (error) {
                            console.error('Detect language error:', error);
                            return 'ar';
                        }
                    }
                },

                // Advanced text direction detection and processing
                textDirection: {
                    // Detect if text is primarily Arabic
                    isArabic(text) {
                        if (!text || typeof text !== 'string') return false;
                        const arabicRegex = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
                        return arabicRegex.test(text);
                    },

                    // Detect if text is primarily English/Latin
                    isLatin(text) {
                        if (!text || typeof text !== 'string') return false;
                        const latinRegex = /[a-zA-Z]/;
                        return latinRegex.test(text);
                    },

                    // Detect if text contains numbers
                    hasNumbers(text) {
                        if (!text || typeof text !== 'string') return false;
                        return /[\dÙ -Ù©]/.test(text);
                    },

                    // Detect if text is mixed (Arabic + Latin)
                    isMixed(text) {
                        if (!text || typeof text !== 'string') return false;
                        return this.isArabic(text) && this.isLatin(text);
                    },

                    // Get dominant text direction
                    getDominantDirection(text) {
                        if (!text || typeof text !== 'string') return 'rtl';

                        const arabicChars = (text.match(/[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/g) || []).length;
                        const latinChars = (text.match(/[a-zA-Z]/g) || []).length;

                        if (arabicChars > latinChars) return 'rtl';
                        if (latinChars > arabicChars) return 'ltr';
                        return 'rtl'; // Default to RTL for Arabic interface
                    },

                    // Process mixed content and add appropriate markup
                    processMixedContent(text) {
                        if (!text || typeof text !== 'string') return text;

                        try {
                            let processed = text;

                            // Handle Arabic numerals (Ù -Ù©)
                            

                            // Handle English numerals in Arabic context
                            

                            // Handle English words/phrases in Arabic text
                            if (this.isArabic(text) && this.isLatin(text)) {
                                processed = processed.replace(/([a-zA-Z][a-zA-Z0-9\s\-_]*[a-zA-Z0-9]|[a-zA-Z])/g, (match) => {
                                    // Don't wrap if it's already wrapped
                                    if (match.includes('<span')) return match;
                                    return `<span class="english-phrase" dir="ltr">${match}</span>`;
                                });
                            }

                            return processed;
                        } catch (error) {
                            console.error('Process mixed content error:', error);
                            return text;
                        }
                    },

                    // Apply smart direction classes to element
                    applySmartDirection(element, text) {
                        if (!element || !text) return;

                        try {
                            const direction = this.getDominantDirection(text);
                            const isMixed = this.isMixed(text);

                            // Remove existing direction classes
                            element.classList.remove('rtl-auto', 'ltr-auto', 'text-mixed', 'mixed-content');

                            if (isMixed) {
                                element.classList.add('mixed-content');
                                element.setAttribute('dir', 'auto');
                            } else if (direction === 'rtl') {
                                element.classList.add('rtl-auto');
                                element.setAttribute('dir', 'rtl');
                            } else {
                                element.classList.add('ltr-auto');
                                element.setAttribute('dir', 'ltr');
                            }

                            // Add unicode-bidi for better rendering
                            if (isMixed) {
                                element.style.unicodeBidi = 'plaintext';
                            } else {
                                element.style.unicodeBidi = 'embed';
                            }
                        } catch (error) {
                            console.error('Apply smart direction error:', error);
                        }
                    },

                    // Enhanced content processing for preview
                    enhancePreviewContent(htmlString) {
                        if (!htmlString || typeof htmlString !== 'string') return htmlString;

                        try {
                            // Create a temporary container to work with DOM
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = htmlString;

                            // Process all text nodes
                            const walker = document.createTreeWalker(
                                tempDiv,
                                NodeFilter.SHOW_TEXT,
                                null,
                                false
                            );

                            const textNodes = [];
                            let node;
                            while (node = walker.nextNode()) {
                                textNodes.push(node);
                            }

                            textNodes.forEach(textNode => {
                                const text = textNode.textContent;
                                if (text && text.trim()) {
                                    const processedText = this.processMixedContent(text);
                                    if (processedText !== text) {
                                        const wrapper = document.createElement('span');
                                        wrapper.innerHTML = processedText;
                                        this.applySmartDirection(wrapper, text);
                                        textNode.parentNode.replaceChild(wrapper, textNode);
                                    }
                                }
                            });

                            // Apply direction to container elements
                            const elements = tempDiv.querySelectorAll('p, div, span, h1, h2, h3, h4, h5, h6');
                            elements.forEach(el => {
                                const text = el.textContent;
                                if (text && text.trim()) {
                                    this.applySmartDirection(el, text);
                                }
                            });

                            return tempDiv.innerHTML;
                        } catch (error) {
                            console.error('Enhance preview content error:', error);
                            return htmlString;
                        }
                    }
                },
                /**
                 * Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù„ÙŠÙ„ Ù†Øµ HTMLØŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ±Ø¬Ù…Ø©ØŒ ÙˆØªÙˆÙ„ÙŠØ¯ Ù‡ÙŠÙƒÙ„ HTML Ù…Ø¹ Ù†ØµÙˆØµ Ù†Ø§Ø¦Ø¨Ø©.
                 * @param {string} htmlString - ÙƒÙˆØ¯ HTML Ø§Ù„Ù…Ø±Ø§Ø¯ ØªØ­Ù„ÙŠÙ„Ù‡.
                 * @param {object} basePointer - Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù„ØªØ­Ø¯ÙŠØ¯ Ù…ØµØ¯Ø± Ø§Ù„Ù†Øµ (Ø±Ù‚Ù… Ø§Ù„Ù…Ù„ÙØŒ Ø§Ù„Ø¬Ø²Ø¡ØŒ Ø¥Ù„Ø®).
                 * @returns {{jobs: Array, parsedBody: HTMLElement}} - ÙƒØ§Ø¦Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ù…Ù‡Ø§Ù… Ø§Ù„ØªØ±Ø¬Ù…Ø© ÙˆØ§Ù„Ù‡ÙŠÙƒÙ„.
                 */
                parseHtmlAndCreateJobs(htmlString, basePointer) {
                    const jobs = [];
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(`<!DOCTYPE html><body>${htmlString}</body>`, 'text/html');
                    const body = doc.body;

                    function traverse(node) {
                        if (!node) return;
                        if (node.nodeType === 3) { // Text node
                            const text = (node.nodeValue || '').trim();
                            if (text) {
                                jobs.push({
                                    type: 'text_node',
                                    originalText: text,
                                    pointer: { ...(basePointer || {}) },
                                    domNode: node
                                });
                            }
                            return;
                        }
                        if (node.nodeType === 1) { // Element
                            const tag = (node.tagName || '').toUpperCase();
                            if (tag === 'SCRIPT' || tag === 'STYLE') return;
                            for (const child of Array.from(node.childNodes || [])) traverse(child);
                        }
                    }

                    traverse(body);
                    return { jobs, parsedBody: body };
                }
            },

            translationMemory: {
                storage: new Map(),
                maxEntries: 10000, // Maximum number of translations to store
                
                init() {
                    this.load();
                    // Update UI after a short delay to ensure DOM is ready
                    setTimeout(() => this.updateUI(), 100);
                },
                
                load() {
                    try {
                        const saved = localStorage.getItem('translationMemoryCache');
                        if (saved) {
                            const data = JSON.parse(saved);
                            this.storage = new Map(data);
                            console.log(`TM loaded: ${this.storage.size} entries`);
                        }
                    } catch (error) {
                        console.warn('Failed to load TM:', error);
                        this.storage = new Map();
                    }
                },
                
                save() {
                    try {
                        // Convert Map to array for JSON serialization
                        const data = Array.from(this.storage.entries());
                        
                        // If too many entries, keep only the most recent ones
                        if (data.length > this.maxEntries) {
                            const trimmed = data.slice(-this.maxEntries);
                            this.storage = new Map(trimmed);
                        }
                        
                        localStorage.setItem('translationMemoryCache', JSON.stringify(Array.from(this.storage.entries())));
                        console.log(`TM saved: ${this.storage.size} entries`);
                    } catch (error) {
                        console.warn('Failed to save TM:', error);
                    }
                },
                
                get(originalText) {
                    if (!TranslatorApp.dom.useTmCheckbox.checked) return null;
                    const key = this.createKey(originalText);
                    return this.storage.get(key) || null;
                },
                
                set(originalText, translatedText) {
                    if (!TranslatorApp.dom.useTmCheckbox.checked) return;
                    const key = this.createKey(originalText);
                    this.storage.set(key, {
                        translation: translatedText,
                        timestamp: Date.now(),
                        subject: TranslatorApp.state.selectedSubject,
                        grade: TranslatorApp.state.selectedGrade
                    });
                },
                
                createKey(text) {
                    // Normalize text for consistent matching
                    return (text || '').trim().toLowerCase();
                },
                
                clear() {
                    this.storage.clear();
                    localStorage.removeItem('translationMemoryCache');
                    console.log('TM cleared');
                },
                
                getStats() {
                    return {
                        totalEntries: this.storage.size,
                        maxEntries: this.maxEntries,
                        enabled: TranslatorApp.dom.useTmCheckbox.checked
                    };
                },
                
                updateUI() {
                    try {
                        const stats = this.getStats();
                        if (TranslatorApp.dom.tmStats) {
                            const statusText = stats.enabled ? 'âœ“ Ù…ÙØ¹Ù‘Ù„' : 'âœ— Ù…Ø¹Ø·Ù‘Ù„';
                            TranslatorApp.dom.tmStats.textContent = `${statusText} | Ø¹Ø¯Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©: ${stats.totalEntries.toLocaleString('ar-EG')} / ${stats.maxEntries.toLocaleString('ar-EG')}`;
                        }
                    } catch (error) {
                        console.warn('TM UI update error:', error);
                    }
                }
            },

            remoteGlossary: {
                map: {},
                async fetchApproved(subject, grade, texts) {
                    this.map = {};
                    if (!subject || subject === 'None') return this.map;
                    
                    try {
                        // Extract grid number from grade (e.g., "Grade 5" -> "5")
                        const gradeNumber = grade.replace(/[^0-9]/g, '');
                        
                        console.log(`Fetching termbase for Subject: ${subject}, Grade: ${gradeNumber}`);
                        
                        // Query based on new structure: Subject (Column A), grid (Column B), English Term (Column D), Arabic Term (Column E)
                        // Filter by Subject and grid
                        let tq = `select D,E where A = '${(subject || '').replace(/'/g, "\\'")}' and B = '${gradeNumber}'`;
                        let url = `https://docs.google.com/spreadsheets/d/${GOOGLE_SHEET_ID}/gviz/tq?tqx=out:json&headers=1&tq=${encodeURIComponent(tq)}`;
                        
                        let res = await fetch(url, { cache: 'no-cache' });
                        
                        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        
                        const raw = await res.text();
                        const match = raw.match(/google\.visualization\.Query\.setResponse\(([\s\S]+)\);/);
                        if (!match) throw new Error('ØªØ¹Ø°Ù‘Ø± Ù‚Ø±Ø§Ø¡Ø© Ø§Ø³ØªØ¬Ø§Ø¨Ø© gviz.');
                        
                        const data = JSON.parse(match[1]);
                        const rows = data.table?.rows || [];
                        
                        // Column D (index 0) = English Term, Column E (index 1) = Arabic Term
                        const allPairs = rows.map(r => ({
                            term: (r.c?.[0]?.v || '').toString().trim(),
                            translation: (r.c?.[1]?.v || '').toString().trim()
                        })).filter(x => x.term && x.translation);

                        console.log(`Fetched ${allPairs.length} terms for ${subject} - Grade ${gradeNumber}`);

                        const loweredTexts = Array.isArray(texts) ? texts.map(t => (t || '').toString().toLowerCase()) : [];
                        const map = {};
                        if (loweredTexts.length > 0) {
                            allPairs.forEach(({ term, translation }) => {
                                const tl = term.toLowerCase();
                                if (loweredTexts.some(tx => tx.includes(tl))) map[term] = translation;
                            });
                        } else {
                            allPairs.forEach(({ term, translation }) => { map[term] = translation; });
                        }
                        this.map = map;
                        
                        console.log(`Applied ${Object.keys(map).length} terms from termbase`);
                        return this.map;
                    } catch (e) {
                        console.warn('GVIZ fetch failed:', e);
                        TranslatorApp.ui.showAlert('ØªØ¹Ø°Ù‘Ø± Ø¬Ù„Ø¨ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø© (Ø³ÙŠØªÙ… Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø¨Ø¯ÙˆÙ†Ù‡Ø§).', 'info', 4000);
                        this.map = {};
                        return this.map;
                    }
                },
                applyWithPlaceholders(text) {
                    if (!text || !this.map || Object.keys(this.map).length === 0) {
                        return { modifiedText: text, placeholders: {} };
                    }
                    let modifiedText = text;
                    const placeholders = {};
                    let i = 0;
                    const terms = Object.keys(this.map).filter(Boolean).sort((a, b) => b.length - a.length);
                    for (const term of terms) {
                        const translation = this.map[term];
                        if (!translation) continue;
                        const esc = TranslatorApp.utils.escapeRegex(term.trim());
                        const useWordBoundary = /^[A-Za-z0-9 _-]+$/.test(term);
                        const re = new RegExp(useWordBoundary ? `\\b${esc}\\b` : esc, 'gi');
                        if (re.test(modifiedText)) {
                            const ph = `__GLOSSARY_${i++}__`;
                            placeholders[ph] = translation;
                            modifiedText = modifiedText.replace(re, ph);
                        }
                    }
                    return { modifiedText, placeholders };
                },
                revertPlaceholders(text, placeholders) {
                    if (!placeholders || !text) return text;
                    let out = text;
                    for (const [ph, tr] of Object.entries(placeholders)) out = out.split(ph).join(tr);
                    return out;
                }
            },

            security: {
                SALT: "a-secure-static-salt-for-obfuscation",
                encrypt(key) {
                    try {
                        if (!key || typeof key !== 'string') return '';
                        return btoa(key + this.SALT);
                    } catch (error) {
                        console.warn('Encryption error:', error);
                        return '';
                    }
                },
                decrypt(encryptedKey) {
                    try {
                        if (!encryptedKey || typeof encryptedKey !== 'string') return '';
                        const decoded = atob(encryptedKey);
                        return decoded.endsWith(this.SALT) ? decoded.slice(0, -this.SALT.length) : '';
                    } catch (error) {
                        console.warn('Decryption error:', error);
                        return '';
                    }
                },
                escapeHtml(text) {
                    if (typeof text !== 'string') return text;
                    const map = {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#039;'
                    };
                    return text.replace(/[&<>"']/g, m => map[m]);
                },
                sanitize(html) {
                    if (typeof html !== 'string') return html;
                    try {
                        if (window.DOMPurify) {
                            return DOMPurify.sanitize(html, {
                                ALLOWED_TAGS: ['b', 'i', 'u', 'em', 'strong', 'sub', 'sup', 'br', 'span', 'p', 'ul', 'ol', 'li', 'img', 'a', 'code', 'pre', 'table', 'tr', 'td', 'th', 'thead', 'tbody', 'math', 'div', 'math-field', 'audio'],
                                ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'class', 'style', 'dir', 'value', 'default-mode', 'data-path', 'data-file-index', 'data-blank', 'read-only', 'controls', 'virtual-keyboard-mode', 'use-shared-virtual-keyboard', 'data-node-type', 'data-node-variation', 'locale', 'data-question-id', 'data-part-index', 'data-field-type', 'data-choice-index', 'data-math-index', 'white-space']
                            });
                        }
                        // Fallback sanitization
                        return html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                    } catch (error) {
                        console.warn('HTML sanitization error:', error);
                        // Return a safe fallback
                        return html ? html.replace(/<[^>]*>/g, '') : '';
                    }
                }
            },

            quality: {
                unitsMap: {
                    'pounds': 'Ø¬Ù†ÙŠÙ‡',
                    'pound': 'Ø¬Ù†ÙŠÙ‡',
                    'cm': 'Ø³Ù…',
                    'mm': 'Ù…Ù…',
                    'km': 'ÙƒÙ…',
                    'm': 'Ù…',
                    'kg': 'ÙƒØ¬Ù…',
                    'g': 'Ø¬Ù…',
                    'l': 'Ù„',
                    'L': 'Ù„',
                    'ml': 'Ù…Ù„',
                    's': 'Ø«',
                    'min': 'Ø¯',
                    'h': 'Ø³'
                },
                wantsArabicIndicDigits(subject, grade) {
                    if (subject === 'Mathematics' && ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'].includes(grade)) return true;
                    if (subject === 'Science' && grade === 'Grade 9') return true;
                    return false;
                },
                cleanLatexArabic(text) {
                    if (typeof text !== 'string') return text;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // This is a simple but effective fix for the specific issue
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return text.replace(/\\alt{\\alef}\\prime/g, '')
                               .replace(/\\lam/g, 'ÙˆØ§Ù„Ø¨Ø§Ù‚ÙŠ ');
                },
                
                protectSegments(text) {
                    const placeholders = {};
                    let idx = 0;
                    const patterns = [
                        /<math-field[\s\S]*?<\/math-field>/g,
                        /<audio[\s\S]*?<\/audio>/g,
                        /<img[^>]*>/g,
                        // Don't protect tables - let their content be translated
                        // /<table[\s\S]*?<\/table>/g,
                        /_{3,}/g,
                        /```[\s\S]*?```/g,
                        /`[^`]*`/g,
                        /\$\$[\s\S]*?\$\$/g,
                        /\$[^$]*\$/g,
                        /\\\[[\s\S]*?\\]/g,
                        /\\\([\s\S]*?\\\)/g,
                        /https?:\/\/\S+/g,
                        // Protect Lexical theme elements that might interfere with translation
                        /<span[^>]*class="[^"]*LexicalTheme[^"]*"[^>]*>[\s\S]*?<\/span>/g,
                        /<p[^>]*class="[^"]*LexicalTheme[^"]*"[^>]*>[\s\S]*?<\/p>/g
                    ];
                    let protectedText = String(text || '');
                    for (const re of patterns) {
                        protectedText = protectedText.replace(re, (m) => { const ph = `__LOCK_${idx++}__`; placeholders[ph] = m; return ph; });
                    }
                    return { protectedText, placeholders };
                },
                restoreSegments(text, placeholders) {
                    if (!placeholders) return text;
                    let out = text || '';
                    for (const [ph, val] of Object.entries(placeholders)) out = out.split(ph).join(val);
                    return out;
                },
                convertDigits(str, toArabicIndic) {
                    const en = '0123456789'.split(''); const ar = 'Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©'.split('');
                    if (toArabicIndic) return (str || '').replace(/[0-9]/g, ch => ar[+ch]);
                    return (str || '').replace(/[Ù -Ù©]/g, ch => en[ar.indexOf(ch)]);
                },
                normalizeArabicPunct(str) {
                    return (str || '')
                        .replace(/ ,/g, 'ØŒ')
                        .replace(/, /g, 'ØŒ ')
                        .replace(/,/g, 'ØŒ')
                        .replace(/;/g, 'Ø›')
                        .replace(/\?/g, 'ØŸ')
                        .replace(/["""]/g, 'Â»')
                        .replace(/'/g, 'Ê¼')
                        .replace(/\s+([ØŒØ›ØŸ])/g, '$1')
                        .replace(/([ØŒØ›])(?=[^\s])/g, '$1 ')
                        .replace(/\s+/g, ' ');
                },
                enforceUnits(str, ctx = { subject: 'None', grade: 'None' }) {
                    const map = { cm: 'Ø³Ù…', mm: 'Ù…Ù…', km: 'ÙƒÙ…', m: 'Ù…', kg: 'ÙƒØ¬Ù…', g: 'Ø¬Ù…', l: 'Ù„', L: 'Ù„', ml: 'Ù…Ù„', s: 'Ø«', min: 'Ø¯', h: 'Ø³' };
                    
                    // For Math Grades 4-8, units should be translated but keep English digits
                    const mathEnglishGrades = ['Grade 4', 'Grade 5', 'Grade 6', 'Grade 7', 'Grade 8'];
                    if (ctx.subject === 'Mathematics' && mathEnglishGrades.includes(ctx.grade)) {
                        // Keep English digits, translate units
                        return (str || '').replace(/([0-9.,]+)\s*(cm|mm|km|m|kg|g|l|L|ml|s|min|h)\b/g, (m, num, u) => `${num}\u00A0${map[u] || u}`);
                    }
                    
                    // For other grades, work with both English and Arabic digits
                    return (str || '').replace(/(\d[0-9Ù -Ù©.,]*)\s*(cm|mm|km|m|kg|g|l|L|ml|s|min|h)\b/g, (m, num, u) => `${num}\u00A0${map[u] || u}`);
                },
                convertAndToComma(str, ctx = { subject: 'None', grade: 'None' }) {
                    // For Math Grades 1-3 and 9-12, convert "and" between symbols/numbers to Arabic comma
                    const mathArabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                    if (ctx.subject === 'Mathematics' && mathArabicGrades.includes(ctx.grade)) {
                        // Convert "and" or "Ùˆ" between numbers or symbols to comma
                        let result = str || '';
                        // Match patterns like "x and y" or "3 and 5" and convert to comma
                        result = result.replace(/([0-9Ù -Ù©a-zA-ZØ¡-ÙŠ]+)\s+and\s+([0-9Ù -Ù©a-zA-ZØ¡-ÙŠ]+)/gi, '$1ØŒ $2');
                        // Also handle if "and" was already translated to "Ùˆ" (for both numbers and Arabic letters)
                        result = result.replace(/([0-9Ù -Ù©Ø¡-ÙŠ]+)\s+Ùˆ\s+([0-9Ù -Ù©Ø¡-ÙŠ]+)/g, '$1ØŒ $2');
                        return result;
                    }
                    return str;
                },
                ensureRTLDirection(htmlString) {
                    // Ensure all HTML elements with Arabic text have proper RTL direction
                    if (!htmlString || typeof htmlString !== 'string') return htmlString;
                    
                    try {
                        // Create a temporary container
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = htmlString;
                        
                        // Function to check if text is primarily Arabic
                        const isArabicText = (text) => {
                            if (!text) return false;
                            const arabicChars = (text.match(/[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/g) || []).length;
                            const totalChars = text.replace(/\s/g, '').length;
                            return arabicChars > totalChars * 0.3; // If more than 30% Arabic, consider it Arabic
                        };
                        
                        // Process all elements that can contain text
                        const elements = tempDiv.querySelectorAll('p, div, span, td, th, li, h1, h2, h3, h4, h5, h6');
                        elements.forEach(el => {
                            // Skip SVG and math elements
                            if (el.closest('svg, math-field')) return;
                            
                            const textContent = el.textContent || '';
                            if (textContent.trim() && isArabicText(textContent)) {
                                // Only add dir if not already set
                                if (!el.hasAttribute('dir')) {
                                    el.setAttribute('dir', 'rtl');
                                }
                            }
                        });
                        
                        return tempDiv.innerHTML;
                    } catch (error) {
                        console.error('Ensure RTL direction error:', error);
                        return htmlString;
                    }
                },
                postProcess(text, ctx = { subject: 'None', grade: 'None' }) {
                    let out = text || '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Add a new rule to replace the remainder symbol
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  out = out.replace(/R\s*(\d+)/g, ' ÙˆØ§Ù„Ø¨Ø§Ù‚ÙŠ $1');
                    
                    // Convert "and" to comma for specific grades
                    out = this.convertAndToComma(out, ctx);
                    
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const toArabic = this.wantsArabicIndicDigits(ctx.subject, ctx.grade);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  out = this.convertDigits(out, toArabic);
                    out = this.enforceUnits(out, ctx);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  out = this.normalizeArabicPunct(out);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  out = out.replace(/Â»([^Â»Â«]+)Â»/g, 'Â«$1Â»');
                    
                    // Ensure RTL direction for Arabic content
                    out = this.ensureRTLDirection(out);
                    
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return out;
                },
                qa: {
                    extractPlain(html) { const div = document.createElement('div'); div.innerHTML = html || ''; return (div.textContent || div.innerText || '').trim(); },
                    unifyDigits(s) { const ar = 'Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©'; return (s || '').replace(/[Ù -Ù©]/g, d => String(ar.indexOf(d))); },
                    extractNumbers(s) { return Array.from((s || '').matchAll(/[0-9Ù -Ù©]+(?:[.,][0-9Ù -Ù©]+)?/g)).map(m => m[0]); },
                    sameNumberSet(srcArr, dstArr) {
                        const a = srcArr.map(this.unifyDigits).sort().join('|');
                        const b = dstArr.map(this.unifyDigits).sort().join('|');
                        return a === b;
                    },
                    checkNumbers(srcHtml, dstHtml) {
                        const s = this.extractPlain(srcHtml); const d = this.extractPlain(dstHtml);
                        const srcNums = this.extractNumbers(s); const dstNums = this.extractNumbers(d);
                        return this.sameNumberSet(srcNums, dstNums) ? [] : [`ØªØ­Ø°ÙŠØ±: ØªØºÙŠØ±Øª/Ø§Ø®ØªÙØª Ø£Ø±Ù‚Ø§Ù… (${srcNums.join(',')}) â†’ (${dstNums.join(',')}).`];
                    },
                    checkSeparator(dstText, sep) {
                        if (!dstText) return [];
                        const want = (dstText.match(new RegExp(sep.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g')) || []).length;
                        const legacy = (dstText.match(/<SEP>/g) || []).length;
                        if (legacy > 0 && want === 0) return ['ØªØ­Ø°ÙŠØ±: Ù„Ù… ÙŠÙØ­ÙØ¸ Ø§Ù„ÙØ§ØµÙ„ <SEP> ÙƒÙ…Ø§ Ù‡Ùˆ.'];
                        return [];
                    },
                    checkHtmlBalance(dstHtml) {
                        const tags = ['b', 'i', 'u', 'strong', 'em', 'sub', 'sup', 'span', 'p', 'ul', 'ol', 'li'];
                        const errs = [];
                        tags.forEach(t => {
                            const open = (dstHtml.match(new RegExp(`<${t}\\b`, 'gi')) || []).length;
                            const close = (dstHtml.match(new RegExp(`</${t}>`, 'gi')) || []).length;
                            if (open !== close) errs.push(`ØªØ­Ø°ÙŠØ±: Ø§Ù„ÙˆØ³Ù… <${t}> ØºÙŠØ± Ù…ØªÙˆØ§Ø²Ù† (${open}/${close}).`);
                        });
                        return errs;
                    }
                }
            },

            tm: {
                KEY: 'translatorTMv1',
                getStore() { try { return JSON.parse(localStorage.getItem(this.KEY) || '{}'); } catch { return {}; } },
                saveStore(obj) { localStorage.setItem(this.KEY, JSON.stringify(obj)); },
                plain(html) { const div = document.createElement('div'); div.innerHTML = html || ''; return (div.textContent || div.innerText || '').trim().toLowerCase(); },
                key(text, ctx) { return `${ctx.subject}||${ctx.grade}||${this.plain(text)}`; },
                get(text, ctx) { const store = this.getStore(); return store[this.key(text, ctx)] || null; },
                put(text, ctx, translated) {
                    const store = this.getStore();
                    const k = this.key(text, ctx);
                    store[k] = translated;
                    this.saveStore(store);
                }
            },

            session: {
                save() {
                    try {
                        const ephemeral = TranslatorApp.dom.ephemeralKeysCheckbox.checked;
                        const sessionData = {
                            apiKeys: ephemeral ? null : {
                                gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                                chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value),
                            },
                            localModelUrl: TranslatorApp.dom.localModelUrl.value,
                            localModelName: TranslatorApp.dom.localModelName.value,
                            selectedProvider: document.querySelector('input[name="apiProvider"]:checked').value,
                            selectedFilesInfo: TranslatorApp.state.selectedFilesInfo,
                            originalJsonData: TranslatorApp.state.originalJsonData,
                            translatedJsonData: TranslatorApp.state.translatedJsonData,
                            initialTranslatedJsonData: TranslatorApp.state.initialTranslatedJsonData,
                            glossary: TranslatorApp.state.glossary,
                            activeScreen: TranslatorApp.state.activeScreen,
                            mappedIds: TranslatorApp.dom.mappedIdsInput.value,
                            useMappedIds: TranslatorApp.dom.useMappedIdsCheckbox.checked,
                            selectedSubject: TranslatorApp.state.selectedSubject,
                            selectedGrade: TranslatorApp.state.selectedGrade,
                            ephemeralKeys: ephemeral,
                            useTM: TranslatorApp.dom.useTmCheckbox.checked,
                            useProofread: TranslatorApp.dom.useProofreadCheckbox.checked
                        };
                        localStorage.setItem('translatorSession', JSON.stringify(sessionData));

                        // Always save API keys to sessionStorage for persistence across browser sessions
                        if (TranslatorApp.dom.geminiKeyInput.value || TranslatorApp.dom.chatgptKeyInput.value) {
                            sessionStorage.setItem('translatorPersistentKeys', JSON.stringify({
                                gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                                chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value),
                                provider: document.querySelector('input[name="apiProvider"]:checked').value
                            }));
                        }

                        if (ephemeral) {
                            sessionStorage.setItem('translatorEphemeralKeys', JSON.stringify({
                                gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                                chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value)
                            }));
                        } else {
                            sessionStorage.removeItem('translatorEphemeralKeys');
                        }

                        TranslatorApp.state.hasUnsavedChanges = false;
                    } catch (error) {
                        console.error('Session save error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ø¬Ù„Ø³Ø©.', 'error');
                    }
                },
                load() {
                    const saved = localStorage.getItem('translatorSession');
                    if (!saved) return;
                    try {
                        const s = JSON.parse(saved);
                        TranslatorApp.dom.ephemeralKeysCheckbox.checked = !!s.ephemeralKeys;

                        // Load API keys with fallback to persistent storage
                        let keysLoaded = false;
                        if (s.apiKeys && !s.ephemeralKeys) {
                            TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(s.apiKeys?.gemini || '');
                            TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(s.apiKeys?.chatgpt || '');
                            keysLoaded = true;
                        } else if (s.ephemeralKeys) {
                            const sk = JSON.parse(sessionStorage.getItem('translatorEphemeralKeys') || '{}');
                            TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(sk?.gemini || '');
                            TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(sk?.chatgpt || '');
                            keysLoaded = true;
                        }

                        // Fallback to persistent keys if no keys loaded from session
                        if (!keysLoaded) {
                            const persistentKeys = JSON.parse(sessionStorage.getItem('translatorPersistentKeys') || '{}');
                            if (persistentKeys.gemini || persistentKeys.chatgpt) {
                                TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(persistentKeys.gemini || '');
                                TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(persistentKeys.chatgpt || '');
                                if (persistentKeys.provider) {
                                    const radio = document.querySelector(`input[name="apiProvider"][value="${persistentKeys.provider}"]`);
                                    if (radio) { radio.checked = true; TranslatorApp.events.onApiProviderChange({ target: { value: persistentKeys.provider } }); }
                                }
                            }
                        }

                        TranslatorApp.dom.localModelUrl.value = s.localModelUrl || 'http://localhost:11434/api/generate';
                        TranslatorApp.dom.localModelName.value = s.localModelName || 'gemma:7b';
                        TranslatorApp.state.selectedFilesInfo = s.selectedFilesInfo || [];
                        TranslatorApp.state.originalJsonData = s.originalJsonData || [];
                        TranslatorApp.state.translatedJsonData = s.translatedJsonData || [];
                        TranslatorApp.state.initialTranslatedJsonData = s.initialTranslatedJsonData || [];
                        TranslatorApp.state.glossary = s.glossary || [];
                        TranslatorApp.state.activeScreen = s.activeScreen || 'setup';
                        TranslatorApp.dom.mappedIdsInput.value = s.mappedIds || '[]';
                        TranslatorApp.dom.useMappedIdsCheckbox.checked = s.useMappedIds || false;
                        TranslatorApp.state.selectedSubject = s.selectedSubject || 'None';
                        TranslatorApp.state.selectedGrade = s.selectedGrade || 'None';
                        TranslatorApp.dom.useTmCheckbox.checked = s.useTM ?? true;
                        TranslatorApp.dom.useProofreadCheckbox.checked = s.useProofread ?? false;

                        if (s.selectedProvider && !keysLoaded) {
                            const radio = document.querySelector(`input[name="apiProvider"][value="${s.selectedProvider}"]`);
                            if (radio) { radio.checked = true; TranslatorApp.events.onApiProviderChange({ target: { value: s.selectedProvider } }); }
                        }

                        TranslatorApp.ui.renderFileList();
                        TranslatorApp.subjects.updateUI();
                        
                        // Validate translation requirements after loading session
                        TranslatorApp.validateTranslationRequirements();

                        if (TranslatorApp.state.activeScreen === 'preview' && TranslatorApp.state.translatedJsonData.length > 0) {
                            TranslatorApp.ui.showScreen('preview');
                            TranslatorApp.preview.render();
                            const stats = TranslatorApp.statistics.calculate();
                            TranslatorApp.ui.renderStatistics(stats);
                            TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        } else {
                            TranslatorApp.ui.showScreen('setup');
                        }

                        TranslatorApp.ui.showAlert('ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                    } catch (e) {
                        console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„Ø³Ø©:', e);
                        TranslatorApp.ui.showAlert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©. Ø³ÙŠØªÙ… Ø¨Ø¯Ø¡ Ø¬Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©.', 'error');

                        // Clear corrupted session data
                        try {
                            localStorage.removeItem('translatorSession');
                            sessionStorage.removeItem('translatorEphemeralKeys');
                        } catch (clearError) {
                            console.error('Error clearing corrupted session:', clearError);
                        }
                    }
                },
                clear() {
                    const btn = TranslatorApp.dom.newSessionBtn;
                    if (btn.dataset.confirm === 'true') {
                        try {
                            localStorage.removeItem('translatorSession');
                            sessionStorage.removeItem('translatorEphemeralKeys');
                            // Keep persistent API keys unless user explicitly wants to clear everything
                            // sessionStorage.removeItem('translatorPersistentKeys');
                            location.reload();
                        } catch (error) {
                            console.error('Session clear error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ù…Ø³Ø­ Ø§Ù„Ø¬Ù„Ø³Ø©. ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹.', 'error');
                        }
                    } else {
                        btn.dataset.confirm = 'true';
                        btn.textContent = 'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ØŸ Ø§Ù†Ù‚Ø± Ù…Ø¬Ø¯Ø¯Ø§Ù‹';
                        btn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                        btn.classList.remove('bg-red-500', 'hover:bg-red-600');
                        setTimeout(() => {
                            btn.dataset.confirm = 'false';
                            btn.textContent = 'Ø¨Ø¯Ø¡ Ø¬Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©';
                            btn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                            btn.classList.add('bg-red-500', 'hover:bg-red-600');
                        }, 3000);
                    }
                }
            },

            autoSave: {
                init() {
                    setInterval(() => {
                        try {
                            if (TranslatorApp.state.hasUnsavedChanges) {
                                TranslatorApp.session.save();
                                TranslatorApp.ui.setSaveIndicator('saving');
                                setTimeout(() => TranslatorApp.ui.setSaveIndicator('saved'), 400);
                            }
                        } catch (error) {
                            console.error('Auto-save error:', error);
                            TranslatorApp.ui.setSaveIndicator('error');
                            setTimeout(() => TranslatorApp.ui.setSaveIndicator(''), 2000);
                        }
                    }, 8000);
                }
            },

            validation: {
                validateJsonStructure(data, fileName) {
                    if (typeof data !== 'object' || data === null) {
                        throw new Error(`Ù…Ù„Ù ${fileName} ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† ÙƒØ§Ø¦Ù† JSON ØµØ§Ù„Ø­.`);
                    }
                    if (!data.hasOwnProperty('parts')) {
                        throw new Error(`Ù…Ù„Ù ${fileName} ÙŠÙØªÙ‚Ø¯ Ù„Ù„Ø­Ù‚Ù„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ (parts).`);
                    }
                    if (!Array.isArray(data.parts)) {
                        throw new Error(`Ø­Ù‚Ù„ parts ÙÙŠ Ù…Ù„Ù ${fileName} ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù…ØµÙÙˆÙØ©.`);
                    }
                    return true;
                },
                validateApiKey(key, provider) {
                    if (!key || typeof key !== 'string') return false;
                    const trimmedKey = key.trim();
                    if (trimmedKey.length === 0) return false;

                    if (provider === 'gemini') {
                        return trimmedKey.startsWith('AIza') && trimmedKey.length > 30;
                    }
                    if (provider === 'chatgpt') {
                        return trimmedKey.startsWith('sk-') && trimmedKey.length >= 20;
                    }
                    if (provider === 'local') {
                        // For local models, we validate URL and model name separately
                        return true;
                    }
                    return false;
                },
                validateLocalModelSettings(url, modelName) {
                    if (!url || typeof url !== 'string' || url.trim().length === 0) {
                        return { valid: false, message: 'Ø¹Ù†ÙˆØ§Ù† URL Ù„Ù„Ø®Ø§Ø¯Ù… Ø§Ù„Ù…Ø­Ù„ÙŠ Ù…Ø·Ù„ÙˆØ¨.' };
                    }
                    if (!modelName || typeof modelName !== 'string' || modelName.trim().length === 0) {
                        return { valid: false, message: 'Ø§Ø³Ù… Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ø­Ù„ÙŠ Ù…Ø·Ù„ÙˆØ¨.' };
                    }
                    return { valid: true };
                }
            },

            fileHandler: {
                addFiles(files) {
                    const incoming = Array.from(files).filter(f => {
                        if (!f) return false;
                        const isJson = f.type === 'application/json' || f.name.toLowerCase().endsWith('.json');
                        if (!isJson) {
                            TranslatorApp.ui.showAlert(`Ø§Ù„Ù…Ù„Ù ${f.name} Ù„ÙŠØ³ Ù…Ù„Ù JSON ØµØ§Ù„Ø­.`, 'error');
                            return false;
                        }
                        return true;
                    });

                    if (incoming.length === 0) {
                        TranslatorApp.ui.showAlert('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„ÙØ§Øª JSON ØµØ§Ù„Ø­Ø©.', 'error');
                        return;
                    }

                    incoming.forEach(file => {
                        TranslatorApp.state.fileStore.set(file.name, file);
                        if (!TranslatorApp.state.selectedFilesInfo.some(f => f.name === file.name)) {
                            TranslatorApp.state.selectedFilesInfo.push({ name: file.name, size: file.size });
                        } else {
                            const idx = TranslatorApp.state.selectedFilesInfo.findIndex(f => f.name === file.name);
                            if (idx > -1) TranslatorApp.state.selectedFilesInfo[idx].size = file.size;
                        }
                    });
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.state.hasUnsavedChanges = true;
                    TranslatorApp.ui.showAlert(`ØªÙ… Ø¥Ø¶Ø§ÙØ© ${incoming.length} Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­.`, 'success');
                },
                removeFile(index) {
                    const info = TranslatorApp.state.selectedFilesInfo[index]; if (!info) return;
                    const name = info.name;
                    TranslatorApp.state.selectedFilesInfo.splice(index, 1);
                    if (TranslatorApp.state.fileStore.has(name)) TranslatorApp.state.fileStore.delete(name);
                    const origIdx = TranslatorApp.state.originalJsonData.findIndex(d => d.name === name);
                    if (origIdx > -1) TranslatorApp.state.originalJsonData.splice(origIdx, 1);
                    const transIdx = TranslatorApp.state.translatedJsonData.findIndex(d => d.name === name);
                    if (transIdx > -1) TranslatorApp.state.translatedJsonData.splice(transIdx, 1);
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.state.hasUnsavedChanges = true;
                },
                async readFilesFromInput() {
                    if (TranslatorApp.state.selectedFilesInfo.length === 0) throw new Error("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„ÙØ§Øª Ù…Ø­Ø¯Ø¯Ø©.");
                    TranslatorApp.state.originalJsonData = [];
                    const inputFiles = Array.from(TranslatorApp.dom.fileInput.files || []);

                    for (const { name } of TranslatorApp.state.selectedFilesInfo) {
                        try {
                            const file = TranslatorApp.state.fileStore.get(name) || inputFiles.find(f => f.name === name);
                            if (!file) throw new Error(`Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù ${name}. ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ø¯ÙŠØ¯Ù‡.`);

                            const content = await file.text();
                            if (!content || content.trim() === '') {
                                throw new Error(`Ø§Ù„Ù…Ù„Ù ${name} ÙØ§Ø±Øº.`);
                            }

                            let jsonData;
                            try {
                                jsonData = JSON.parse(content);
                            } catch (parseError) {
                                throw new Error(`Ø§Ù„Ù…Ù„Ù ${name} ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ JSON ØºÙŠØ± ØµØ§Ù„Ø­: ${parseError.message}`);
                            }

                            TranslatorApp.validation.validateJsonStructure(jsonData, name);
                            TranslatorApp.state.originalJsonData.push({ name, data: jsonData });

                        } catch (fileError) {
                            console.error(`Error reading file ${name}:`, fileError);
                            throw new Error(`Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù ${name}: ${fileError.message}`);
                        }
                    }
                }
            },

            mappedIds: {
                async fetch() {
                    const count = TranslatorApp.dom.mappedIdsCount.value;
                    if (!count || count <= 0) return TranslatorApp.ui.showAlert('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ø¯Ø¯ ØµØ­ÙŠØ­.', 'error');
                    const url = `https://12digit.nagwa.com/get.bulk.codes/${count}/cps/cps.system/`;
                    TranslatorApp.ui.showAlert(`Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ ${count} ÙƒÙˆØ¯...`, 'info', 3000);
                    try {
                        const response = await fetch(url, {
                            method: 'GET',
                            mode: 'cors',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            }
                        });
                        if (!response.ok) throw new Error(`ÙØ´Ù„ Ø§Ù„Ø·Ù„Ø¨. Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø§Ø¯Ù…: ${response.status}`);
                        const data = await response.json();
                        if (Array.isArray(data)) {
                            TranslatorApp.dom.mappedIdsInput.value = JSON.stringify(data, null, 2);
                            TranslatorApp.ui.showAlert('ØªÙ… Ø¬Ù„Ø¨ Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                            TranslatorApp.state.hasUnsavedChanges = true;
                        } else {
                            throw new Error('Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙŠØ³Øª Ù…ØµÙÙˆÙØ©.');
                        }
                    } catch (error) {
                        console.error("Fetch Mapped IDs Error:", error);
                        TranslatorApp.ui.showAlert(`ÙØ´Ù„ Ø§Ù„Ø¬Ù„Ø¨ Ø¨Ø³Ø¨Ø¨ Ù‚ÙŠÙˆØ¯ CORS. Ø³ÙŠØªÙ… ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· Ù„Ù„Ù†Ø³Ø® Ø§Ù„ÙŠØ¯ÙˆÙŠ.`, 'error', 8000);
                        window.open(url, '_blank');
                    }
                }
            },

            subjects: {
                data: {
                    'None': { grades: ['None'], prompt: 'Translate to Arabic accurately. Preserve HTML/LaTeX and special placeholders (e.g., __LOCK_0__, __GLOSSARY_0__). If a text contains the separator \\n<SEP>\\n, translate each segment separately and preserve the separator exactly.' },
                    'Mathematics': {
                        grades: ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 4', 'Grade 5', 'Grade 6', 'Grade 7', 'Grade 8', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'], 
                        prompts: {
                            'Grade 1': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.\n7. Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ø¹Ù…Ø± Ø§Ù„Ø·Ù„Ø§Ø¨.',
                            'Grade 2': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù†ÙŠ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.\n7. Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ø¹Ù…Ø± Ø§Ù„Ø·Ù„Ø§Ø¨.',
                            'Grade 3': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù„Ø« Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.\n7. Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ø¹Ù…Ø± Ø§Ù„Ø·Ù„Ø§Ø¨.',
                            'Grade 4': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø±Ø§Ø¨Ø¹ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (0123456789) ÙˆØ§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (x, y, z).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† (LTR).\n3. **Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ù…Ù‡Ù… Ù„Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª Ù‚ÙŠØ§Ø³:**\n   - Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¹Ø¨ÙŠØ± ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø© (Ù…Ø«Ù„: cm, m, kg, km):\n     * Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL)\n     * Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©\n     * ØªØ±Ø¬Ù… Ø§Ù„ÙˆØ­Ø¯Ø© ÙÙ‚Ø· Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (cm â†’ Ø³Ù…ØŒ m â†’ Ù…ØŒ kg â†’ ÙƒØ¬Ù…)\n   - Ù…Ø«Ø§Ù„: "5 cm" â†’ "5 Ø³Ù…" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n   - Ù…Ø«Ø§Ù„: "x meters" â†’ "x Ù…ØªØ±" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n4. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n5. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø›).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 5': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø®Ø§Ù…Ø³ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (0123456789) ÙˆØ§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (x, y, z).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† (LTR).\n3. **Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ù…Ù‡Ù… Ù„Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª Ù‚ÙŠØ§Ø³:**\n   - Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¹Ø¨ÙŠØ± ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø© (Ù…Ø«Ù„: cm, m, kg, km):\n     * Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL)\n     * Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©\n     * ØªØ±Ø¬Ù… Ø§Ù„ÙˆØ­Ø¯Ø© ÙÙ‚Ø· Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (cm â†’ Ø³Ù…ØŒ m â†’ Ù…ØŒ kg â†’ ÙƒØ¬Ù…)\n   - Ù…Ø«Ø§Ù„: "5 cm" â†’ "5 Ø³Ù…" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n   - Ù…Ø«Ø§Ù„: "x meters" â†’ "x Ù…ØªØ±" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n4. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n5. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø›).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 6': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø³Ø§Ø¯Ø³ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (0123456789) ÙˆØ§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (x, y, z).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† (LTR).\n3. **Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ù…Ù‡Ù… Ù„Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª Ù‚ÙŠØ§Ø³:**\n   - Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¹Ø¨ÙŠØ± ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø© (Ù…Ø«Ù„: cm, m, kg, km):\n     * Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL)\n     * Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©\n     * ØªØ±Ø¬Ù… Ø§Ù„ÙˆØ­Ø¯Ø© ÙÙ‚Ø· Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (cm â†’ Ø³Ù…ØŒ m â†’ Ù…ØŒ kg â†’ ÙƒØ¬Ù…)\n   - Ù…Ø«Ø§Ù„: "5 cm" â†’ "5 Ø³Ù…" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n   - Ù…Ø«Ø§Ù„: "x meters" â†’ "x Ù…ØªØ±" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n4. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n5. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø›).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 7': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (0123456789) ÙˆØ§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (x, y, z).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† (LTR).\n3. **Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ù…Ù‡Ù… Ù„Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª Ù‚ÙŠØ§Ø³:**\n   - Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¹Ø¨ÙŠØ± ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø© (Ù…Ø«Ù„: cm, m, kg, km):\n     * Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL)\n     * Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©\n     * ØªØ±Ø¬Ù… Ø§Ù„ÙˆØ­Ø¯Ø© ÙÙ‚Ø· Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (cm â†’ Ø³Ù…ØŒ m â†’ Ù…ØŒ kg â†’ ÙƒØ¬Ù…)\n   - Ù…Ø«Ø§Ù„: "5 cm" â†’ "5 Ø³Ù…" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n   - Ù…Ø«Ø§Ù„: "x meters" â†’ "x Ù…ØªØ±" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n4. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n5. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø›).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 8': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù†ÙŠ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (0123456789) ÙˆØ§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (x, y, z).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† (LTR).\n3. **Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ù…Ù‡Ù… Ù„Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª Ù‚ÙŠØ§Ø³:**\n   - Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¹Ø¨ÙŠØ± ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø© (Ù…Ø«Ù„: cm, m, kg, km):\n     * Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL)\n     * Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©\n     * ØªØ±Ø¬Ù… Ø§Ù„ÙˆØ­Ø¯Ø© ÙÙ‚Ø· Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (cm â†’ Ø³Ù…ØŒ m â†’ Ù…ØŒ kg â†’ ÙƒØ¬Ù…)\n   - Ù…Ø«Ø§Ù„: "5 cm" â†’ "5 Ø³Ù…" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n   - Ù…Ø«Ø§Ù„: "x meters" â†’ "x Ù…ØªØ±" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n4. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n5. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø›).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 9': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù„Ø« Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 10': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 11': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù†ÙŠ Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 12': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù„Ø« Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.'
                        }
                    },
                    'Physics': {
                        grades: ['Grades 10â€“12'], prompts: {
                            'Grades 10â€“12': 'Translate Physics questions.\nRules:\n1) Use official MoE phrasing.\n2) Use English numerals.\n3) Keep physical formulas (e.g., F=ma), variables, and units (cm, m, kg) in their original LTR format. Do NOT wrap them in any HTML tags.\n4) Keep subscripts and variables exact.\n5) If text contains \\n<SEP>\\n, translate parts separately and preserve separator.'
                        }
                    },
                    'Chemistry': {
                        grades: ['Grades 10â€“12'], prompts: {
                            'Grades 10â€“12': 'Translate Chemistry questions.\nRules:\n1) Use English numerals.\n2) Keep chemical formulas, symbols, and equations in their original LTR format. Do NOT wrap them in any HTML tags.\n3) Keep units in English abbreviations.\n4) If text contains \\n<SEP>\\n, preserve separator.'
                        }
                    },
                    'Biology': {
                        grades: ['Grades 10â€“12'], prompts: {
                            'Grades 10â€“12': 'Translate Biology questions.\nUse English numerals; Arabic labels (Ø£ØŒ Ø¨ØŒ Ø¬); translate text within figures; preserve \\n<SEP>\\n.'
                        }
                    },
                    'Science': {
                        grades: ['Grade 4', 'Grade 5', 'Grade 6', 'Grade 7', 'Grade 8', 'Grade 9'], 
                        prompts: {
                            'Grade 4': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ù„Ù„ØµÙ Ø§Ù„Ø±Ø§Ø¨Ø¹.\nØ§Ù„Ù‚ÙˆØ§Ø¹Ø¯:\n1) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n2) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬).\n3) Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n4) Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¹Ù…Ø±.\n5) Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n.',
                            'Grade 5': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ù„Ù„ØµÙ Ø§Ù„Ø®Ø§Ù…Ø³.\nØ§Ù„Ù‚ÙˆØ§Ø¹Ø¯:\n1) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n2) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬).\n3) Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n4) Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¹Ù…Ø±.\n5) Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n.',
                            'Grade 6': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ù„Ù„ØµÙ Ø§Ù„Ø³Ø§Ø¯Ø³.\nØ§Ù„Ù‚ÙˆØ§Ø¹Ø¯:\n1) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n2) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬).\n3) Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n4) Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¹Ù…Ø±.\n5) Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n.',
                            'Grade 7': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ù„Ù„ØµÙ Ø§Ù„Ø³Ø§Ø¨Ø¹.\nØ§Ù„Ù‚ÙˆØ§Ø¹Ø¯:\n1) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n2) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬).\n3) Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n4) Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¹Ù…Ø±.\n5) Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n.',
                            'Grade 8': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù…Ù†.\nØ§Ù„Ù‚ÙˆØ§Ø¹Ø¯:\n1) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n2) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬).\n3) Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n4) Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¹Ù…Ø±.\n5) Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n.',
                            'Grade 9': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ù„Ù„ØµÙ Ø§Ù„ØªØ§Ø³Ø¹.\nØ§Ù„Ù‚ÙˆØ§Ø¹Ø¯:\n1) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ©.\n2) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬).\n3) Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n4) Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¹Ù…Ø±.\n5) Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n.'
                        }
                    },
                    'Integrated Science': {
                        grades: ['Grades 10â€“12'], prompts: {
                            'Grades 10â€“12': 'Translate Integrated Science.\nUse English numerals; Arabic labels; keep units; preserve \\n<SEP>\\n.'
                        }
                    },
                    'ICT': {
                        grades: ['Grade 4', 'Grade 5'], prompts: {
                            'Grade 4': 'Translate ICT (Grade 4).\nUse Arabic-Indic numerals; product names bilingual; preserve \\n<SEP>\\n.',
                            'Grade 5': 'Translate ICT (Grade 5).\nUse English numerals; Arabic labels; preserve \\n<SEP>\\n.'
                        }
                    },
                    'Discover': {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  grades: ['Grades 1â€“3'], prompts: {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'Grades 1â€“3': 'Translate Discover (1-3).\nUse Arabic-Indic numerals; Arabic labels; preserve \\n<SEP>\\n.'
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
                },
                init() { this.populateSubjects(); this.updateUI(); },
                populateSubjects() {
                    TranslatorApp.dom.subjectSelect.innerHTML = '';
                    Object.keys(this.data).forEach(subject => {
                        const opt = document.createElement('option'); opt.value = subject; opt.textContent = subject;
                        TranslatorApp.dom.subjectSelect.appendChild(opt);
                    });
                },
                populateGrades(subject) {
                    TranslatorApp.dom.gradeSelect.innerHTML = '';
                    const subjectData = this.data[subject];
                    if (subjectData && subjectData.grades) subjectData.grades.forEach(grade => {
                        const opt = document.createElement('option'); opt.value = grade; opt.textContent = grade;
                        TranslatorApp.dom.gradeSelect.appendChild(opt);
                    });
                },
                onSubjectChange() { const s = TranslatorApp.dom.subjectSelect.value; this.populateGrades(s); this.updatePromptPreview(); },
                onGradeChange() { this.updatePromptPreview(); },
                updatePromptPreview() { TranslatorApp.dom.promptPreview.value = this.buildSystemPrompt(); },
                getCurrentPrompt() {
                    const subject = TranslatorApp.dom.subjectSelect.value;
                    const grade = TranslatorApp.dom.gradeSelect.value;
                    if (subject === 'None' || !this.data[subject]) return this.data['None'].prompt;
                    return this.data[subject].prompts?.[grade] || Object.values(this.data[subject].prompts)[0] || '';
                },
                buildSystemPrompt() {
                    const base = this.getCurrentPrompt();
                    const subject = TranslatorApp.dom.subjectSelect.value;
                    const grade = TranslatorApp.dom.gradeSelect.value;
                    
                    // Add subject and grade info to the prompt
                    const subjectInfo = subject !== 'None' && grade !== 'None' 
                        ? `\n\n--- Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„Ø¬Ø±ÙŠØ¯ ---\nØ§Ù„Ù…Ø§Ø¯Ø©: ${subject}\nØ§Ù„Ø¬Ø±ÙŠØ¯: ${grade}\n--- Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ---\n\n`
                        : '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const wantArabic = TranslatorApp.quality.wantsArabicIndicDigits(subject, grade);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const digitsRule = wantArabic ? 'Use Arabic-Indic numerals (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©).' : 'Use English numerals (0123456789).';
                    
                    // Special rules for Mathematics based on grade
                    let mathRules = '';
                    if (subject === 'Mathematics') {
                        const arabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                        const englishGrades = ['Grade 4', 'Grade 5', 'Grade 6', 'Grade 7', 'Grade 8'];
                        
                        if (arabicGrades.includes(grade)) {
                            mathRules = `\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø®Ø§ØµØ© Ù„Ù„ØµÙÙˆÙ (${grade}):**
- ÙŠØ¬Ø¨ ØªØ±Ø¬Ù…Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² ÙˆØ§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©).
- ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§ØªØ¬Ø§Ù‡Ø§Øª Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).
- Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).
- **Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹**: Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ ÙˆØ§Ù„Ø±Ù…ÙˆØ²ØŒ ÙŠØ¬Ø¨ ØªØ­ÙˆÙŠÙ„ ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø§Ù„Ø±Ù…ÙˆØ² Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ Ø¥Ù„Ù‰ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).
  Ù…Ø«Ø§Ù„: "x and y" ÙŠØ¬Ø¨ Ø£Ù† ØªØµØ¨Ø­ "Ø³ØŒ Øµ" ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ"
  Ù…Ø«Ø§Ù„: "3 and 5" ÙŠØ¬Ø¨ Ø£Ù† ØªØµØ¨Ø­ "Ù£ØŒ Ù¥" ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥"\n`;
                        } else if (englishGrades.includes(grade)) {
                            mathRules = `\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø®Ø§ØµØ© Ù„Ù„ØµÙÙˆÙ (${grade}):**
- ÙŠØ¬Ø¨ Ø¹Ø¯Ù… ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø±Ù…ÙˆØ² ÙˆØ§Ù„Ø£Ø¹Ø¯Ø§Ø¯ (Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© 0123456789).
- ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§ØªØ¬Ø§Ù‡Ø§Øª Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† (LTR).
- **Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ù…Ù‡Ù… Ù„Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª Ù‚ÙŠØ§Ø³:**
  * Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¹Ø¨ÙŠØ± ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø© Ù‚ÙŠØ§Ø³ (Ù…Ø«Ù„ cm, m, kg)ØŒ ÙŠØ¬Ø¨:
    1. ÙƒØªØ§Ø¨Ø© Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL)
    2. Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² ÙˆØ§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©
    3. ØªØ±Ø¬Ù…Ø© Ø§Ù„ÙˆØ­Ø¯Ø© ÙÙ‚Ø· Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
  * Ù…Ø«Ø§Ù„: "5 cm" ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒØªØ¨ "5 Ø³Ù…" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±ØŒ Ø±Ù‚Ù… Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ ÙˆÙˆØ­Ø¯Ø© Ø¹Ø±Ø¨ÙŠØ©)
  * Ù…Ø«Ø§Ù„: "x meters" ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒØªØ¨ "x Ù…ØªØ±" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±ØŒ Ø±Ù…Ø² Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ ÙˆÙˆØ­Ø¯Ø© Ø¹Ø±Ø¨ÙŠØ©)
  * Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ Ù„Ø§ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª ØªØ¨Ù‚Ù‰ LTR Ù…Ø¹ Ø£Ø±Ù‚Ø§Ù… ÙˆØ±Ù…ÙˆØ² Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n`;
                        }
                    }
                    
                    const core = [
                        // Move the critical rule to the top for emphasis
                        '**CRITICAL: Do NOT output any LaTeX commands for Arabic text. For example, the word "Ø·Ø§Ù„Ø¨" should be rendered exactly as "Ø·Ø§Ù„Ø¨" and NOT as "\\alt{\\ta}\\prime \\alt{\\alef}\\prime \\alt{\\la}\\prime \\alt{\\ba}\\prime".**',
                        '',
                        '**CRITICAL RULES FOR HTML TAGS:**',
                        '1. NEVER add any HTML tags (including <span>, <div>, <p>, etc.) to the translation.',
                        '2. NEVER wrap variables, units, or formulas in <span dir="ltr"> or any other HTML tags.',
                        '3. Keep all text content plain text without any HTML markup.',
                        '4. If you see <math-field> in the original, keep it exactly as-is with its LaTeX value.',
                        '5. DO NOT add irrelevant LaTeX inside math-field values.',
                        '6. DO NOT add English punctuation marks (?, !, .) inside <math-field> tags unless they are part of the original mathematical expression.',
                        '',
                        'Core rules:',
                        '- Do NOT add or remove content.',
                        '- Translate text content inside of HTML tags. Preserve the HTML tags themselves (e.g., <table>, <b>, <img>) and all LaTeX markup exactly as-is.',
                        '- If a text segment contains no translatable prose (e.g., it is only a table of numbers, a chemical formula, or a URL), you MUST return the original text segment completely unchanged.',
                        '- If present, keep placeholders __LOCK_n__ and __GLOSSARY_n__ unchanged.',
                        `- ${digitsRule}`,
                        `- If text contains the separator ${TranslatorApp.constants.CONTEXT_SEPARATOR}, translate each segment and preserve the separator exactly.`,
                        '- Keep the order of choices unchanged.',
                        '- Output in Arabic (MSA), formal tone.'
                    ].join('\n');
                    return `${subjectInfo}${base}${mathRules}\n\n${core}`;
                },
                async apply() {
                    TranslatorApp.state.selectedSubject = TranslatorApp.dom.subjectSelect.value;
                    TranslatorApp.state.selectedGrade = TranslatorApp.dom.gradeSelect.value;
                    TranslatorApp.state.hasUnsavedChanges = true;
                    TranslatorApp.ui.showSubjectsModal(false);
                    
                    // Show detailed success message
                    const subjectName = TranslatorApp.state.selectedSubject;
                    const gradeName = TranslatorApp.state.selectedGrade;
                    let message = `ØªÙ… ØªØ·Ø¨ÙŠÙ‚: ${subjectName} - ${gradeName}`;
                    
                    if (subjectName !== 'None' && gradeName !== 'None') {
                        message += `\nØ³ÙŠØªÙ… Ø¬Ù„Ø¨ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù…Ø®ØµØµØ© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø±ÙŠØ¯ Ø¹Ù†Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø©.`;
                    }
                    
                    TranslatorApp.ui.showAlert(message, 'success', 5000);
                },
                updateUI() {
                    TranslatorApp.dom.subjectSelect.value = TranslatorApp.state.selectedSubject;
                    this.populateGrades(TranslatorApp.state.selectedSubject);
                    TranslatorApp.dom.gradeSelect.value = TranslatorApp.state.selectedGrade;
                    this.updatePromptPreview();
                }
            },

            api: {
                abortController: null,
                createAbortController() { if (this.abortController) this.abortController.abort(); this.abortController = new AbortController(); return this.abortController; },
                cancel() { if (this.abortController) { this.abortController.abort(); TranslatorApp.ui.showAlert('ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ±Ø¬Ù…Ø©.', 'info'); TranslatorApp.state.isTranslating = false; TranslatorApp.ui.showScreen('setup'); } },

                async translateInChunks(jobs, apiKeyOrUrl, provider, localModelName = '', systemPrompt = '') {
                    const CHUNK_SIZE = TranslatorApp.constants.CHUNK_SIZE;
                    const total = jobs.length;
                    let done = 0;
                    jobs.forEach((job, idx) => job.uid = idx);

                    for (let i = 0; i < jobs.length; i += CHUNK_SIZE) {
                        const chunk = jobs.slice(i, i + CHUNK_SIZE);
                        const items = chunk.map(j => ({ id: j.uid, text: j.originalText }));
                        TranslatorApp.ui.updateProgress(`Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©... (${Math.min(done + items.length, total)}/${total})`);
                        const outItems = await this.translateItemsBatch(items, apiKeyOrUrl, provider, localModelName, systemPrompt);
                        outItems.forEach(obj => {
                            const job = chunk.find(j => j.uid === obj.id);
                            if (!job) return;

                            // Get the translated text (which might still contain placeholders like __GLOSSARY_0__)
                            let translatedText = (obj.text || '').toString().trim();

                            // Revert the placeholders using the map we stored on the job object
                            if (job.placeholders) {
                                translatedText = TranslatorApp.remoteGlossary.revertPlaceholders(translatedText, job.placeholders);
                            }

                            // Apply post-processing (convert "and" to comma, enforce units, etc.)
                            const ctx = {
                                subject: TranslatorApp.state.selectedSubject,
                                grade: TranslatorApp.state.selectedGrade
                            };
                            translatedText = TranslatorApp.quality.postProcess(translatedText, ctx);

                            // Use the REAL original text as the key for the cache
                            const cacheKey = job.realOriginalText || job.originalText;
                            TranslatorApp.state.translationCache.set(cacheKey, translatedText);
                            
                            // Save to Translation Memory
                            if (TranslatorApp.dom.useTmCheckbox.checked) {
                                TranslatorApp.translationMemory.set(cacheKey, translatedText);
                            }
                        });
                        done += items.length;
                    }
                },

                async translateItemsBatch(items, apiKeyOrUrl, provider, localModelName = '', systemPrompt = '') {
                    const CONTEXT_SEPARATOR = TranslatorApp.constants.CONTEXT_SEPARATOR;
                    const userInstruction = `Translate all provided text to Modern Standard Arabic. Preserve HTML/LaTeX and placeholders.\nYou will receive a JSON object with an array "items": [{"id": number, "text": string}].\n- If "text" contains the exact separator "${CONTEXT_SEPARATOR}", translate each segment to Arabic and preserve the separator unchanged.\n- Preserve any HTML/LaTeX markup exactly.\n- Do NOT modify placeholders of the form __LOCK_n__ or __GLOSSARY_n__.\nReturn ONLY a valid JSON object: {"items":[{"id": number, "text": "translated"}]}.`;
                    const payload = { items };
                    const signal = this.abortController?.signal;

                    let responseText;
                    if (provider === 'gemini') responseText = await this.withGeminiJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, signal);
                    else if (provider === 'chatgpt') responseText = await this.withChatGPTJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, signal);
                    else responseText = await this.withLocalModelJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, localModelName, signal);

                    try {
                        const data = JSON.parse(responseText);
                        if (!data || !Array.isArray(data.items)) throw new Error('Invalid JSON structure from model.');
                        return data.items.map(x => ({ id: x.id, text: x.text }));
                    } catch (e) {
                        console.warn('JSON parse failed, falling back to delimiter mode.', e);
                        const BATCH_SEPARATOR = TranslatorApp.constants.BATCH_SEPARATOR;
                        const flat = items.map(it => `${it.id}:::${it.text}`).join(BATCH_SEPARATOR);
                        const fallbackPrompt = `${userInstruction}\nNow process items separated by "${BATCH_SEPARATOR}". Each starts with "<id>:::". Return ONLY valid JSON as specified.\n\n${flat}`;
                        let resp;
                        if (provider === 'gemini') resp = await this.withGeminiText(systemPrompt, fallbackPrompt, apiKeyOrUrl, signal);
                        else if (provider === 'chatgpt') resp = await this.withChatGPTText(systemPrompt, fallbackPrompt, apiKeyOrUrl, signal);
                        else resp = await this.withLocalModelText(systemPrompt, fallbackPrompt, apiKeyOrUrl, localModelName, signal);
                        const data2 = JSON.parse(resp);
                        if (!data2 || !Array.isArray(data2.items)) throw new Error('Invalid JSON structure from model (fallback).');
                        return data2.items.map(x => ({ id: x.id, text: x.text }));
                    }
                },

                async proofreadInChunks(items, apiKeyOrUrl, provider, localModelName = '') {
                    const CHUNK_SIZE = TranslatorApp.constants.CHUNK_SIZE;
                    const total = items.length;
                    let done = 0;
                    const allOut = [];
                    for (let i = 0; i < items.length; i += CHUNK_SIZE) {
                        const chunk = items.slice(i, i + CHUNK_SIZE);
                        TranslatorApp.ui.updateProgress(`ØªØ¯Ù‚ÙŠÙ‚ Ù„ØºÙˆÙŠ... (${Math.min(done + chunk.length, total)}/${total})`);
                        const out = await this.proofreadItemsBatch(chunk, apiKeyOrUrl, provider, localModelName);
                        allOut.push(...out);
                        done += chunk.length;
                    }
                    return allOut;
                },

                async proofreadItemsBatch(items, apiKeyOrUrl, provider, localModelName = '') {
                    const userInstruction = `You will receive JSON {"items":[{"id":number,"text":string}]}. Proofread Arabic grammar/style only.
- Do not add/remove content.
- Do not change digits, units, HTML, LaTeX, or any placeholders like __LOCK_n__ or __GLOSSARY_n__.
- Return ONLY {"items":[{"id":number,"text":"polished"}]}.`;
                    const payload = { items };
                    const signal = this.abortController?.signal;
                    let responseText;
                    if (provider === 'gemini') responseText = await this.withGeminiJSON('', userInstruction, payload, apiKeyOrUrl, signal);
                    else if (provider === 'chatgpt') responseText = await this.withChatGPTJSON('', userInstruction, payload, apiKeyOrUrl, signal);
                    else responseText = await this.withLocalModelJSON('', userInstruction, payload, apiKeyOrUrl, localModelName, signal);

                    const data = JSON.parse(responseText);
                    return data.items;
                },

                async withGeminiJSON(systemPrompt, userInstruction, payload, apiKey, signal) {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
                    const fullPrompt = `${systemPrompt || ''}\n\n${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}`;
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        signal,
                        body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }], generationConfig: { response_mime_type: "application/json" } })
                    });
                    if (!response.ok) { let err; try { err = await response.json(); } catch { } throw new Error(`Gemini API Error: ${err?.error?.message || response.statusText}`); }
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                },
                async withChatGPTJSON(systemPrompt, userInstruction, payload, apiKey, signal) {
                    const apiUrl = 'https://api.openai.com/v1/chat/completions';
                    const messages = [];
                    if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
                    messages.push({ role: 'user', content: `${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}` });
                    const candidateModels = ['gpt-4.1', 'gpt-4o-mini', 'gpt-4o', 'gpt-4.1-mini'];
                    let lastError = null;
                    for (const model of candidateModels) {
                        try {
                            const response = await fetch(apiUrl, {
                                method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, signal,
                                body: JSON.stringify({ model, messages, temperature: 0.2, response_format: { type: "json_object" } })
                            });
                            if (!response.ok) {
                                let err; try { err = await response.json(); } catch { }
                                lastError = new Error(`ChatGPT API Error: ${err?.error?.message || response.statusText}`);
                                continue;
                            }
                            const data = await response.json();
                            return data.choices?.[0]?.message?.content || '';
                        } catch (e) { lastError = e; }
                    }
                    throw lastError || new Error('ChatGPT API Error: Unable to complete request');
                },
                async withLocalModelJSON(systemPrompt, userInstruction, payload, url, modelName, signal) {
                    const fullPrompt = `${systemPrompt || ''}\n\n${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}\n\nReturn ONLY JSON.`;
                    const response = await fetch(url, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                        body: JSON.stringify({ model: modelName, prompt: fullPrompt, system: '', stream: false, format: 'json' })
                    });
                    if (!response.ok) throw new Error(`Local server error: ${response.status} ${response.statusText}`);
                    const data = await response.json();
                    return data.response || '';
                },
                async withGeminiText(systemPrompt, userPrompt, apiKey, signal) {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
                    const fullPrompt = systemPrompt ? `${systemPrompt}\n\n---\n\n${userPrompt}` : userPrompt;
                    const response = await fetch(apiUrl, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                        body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }] })
                    });
                    if (!response.ok) { const err = await response.json(); throw new Error(`Gemini API Error: ${err.error?.message || response.statusText}`); }
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                },
                async withChatGPTText(systemPrompt, userPrompt, apiKey, signal) {
                    const apiUrl = 'https://api.openai.com/v1/chat/completions';
                    const messages = []; if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
                    messages.push({ role: 'user', content: userPrompt });
                    const candidateModels = ['gpt-4.1', 'gpt-4o-mini', 'gpt-4o', 'gpt-4.1-mini'];
                    let lastError = null;
                    for (const model of candidateModels) {
                        try {
                            const response = await fetch(apiUrl, {
                                method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, signal,
                                body: JSON.stringify({ model, messages, temperature: 0.2 })
                            });
                            if (!response.ok) { const err = await response.json(); lastError = new Error(`ChatGPT API Error: ${err.error?.message || response.statusText}`); continue; }
                            const data = await response.json();
                            return data.choices?.[0]?.message?.content || '';
                        } catch (e) { lastError = e; }
                    }
                    throw lastError || new Error('ChatGPT API Error: Unable to complete request');
                },
                async withLocalModelText(systemPrompt, userPrompt, url, modelName, signal) {
                    const response = await fetch(url, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                        body: JSON.stringify({ model: modelName, prompt: userPrompt, system: systemPrompt, stream: false })
                    });
                    if (!response.ok) throw new Error(`Local server error: ${response.status} ${response.statusText}`);
                    const data = await response.json();
                    return data.response || '';
                }
            },

            history: {
                stack: [],
                currentIndex: -1,
                timeout: null,


                init() {
                    this.updateButtons();
                },

                push(state) {
                    const MAX_HISTORY = TranslatorApp.constants.HISTORY_MAX;
                    if (this.timeout) clearTimeout(this.timeout);

                    this.timeout = setTimeout(() => {
                        try {
                            this.stack = this.stack.slice(0, this.currentIndex + 1);
                            const snapshot = (window.structuredClone ? structuredClone(state) : JSON.parse(JSON.stringify(state)));
                            this.stack.push(snapshot);

                            if (this.stack.length > MAX_HISTORY) {
                                this.stack.shift();
                            } else {
                                this.currentIndex++;
                            }

                            this.updateButtons();
                        } catch (error) {
                            console.error('History push error:', error);
                            // Reset history if there's an error
                            this.stack = [];
                            this.currentIndex = -1;
                            this.updateButtons();
                        }
                    }, 400);
                },

                undo() {
                    if (this.currentIndex > 0) {
                        this.currentIndex--;
                        this.restore(this.stack[this.currentIndex]);
                    }
                },

                redo() {
                    if (this.currentIndex < this.stack.length - 1) {
                        this.currentIndex++;
                        this.restore(this.stack[this.currentIndex]);
                    }
                },

                restore(state) {
                    try {
                        TranslatorApp.state.translatedJsonData = (window.structuredClone ? structuredClone(state) : JSON.parse(JSON.stringify(state)));
                        TranslatorApp.preview.render();
                        this.updateButtons();
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('History restore error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©.', 'error');
                    }
                },

                updateButtons() {
                    TranslatorApp.dom.undoBtn.disabled = this.currentIndex <= 0;
                    TranslatorApp.dom.redoBtn.disabled = this.currentIndex >= this.stack.length - 1;
                },

            },
            // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø¯Ø§Ù„Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ø¨Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© (ØªØ­Ù„ÙŠÙ„ HTML ÙˆØªÙˆÙ„ÙŠØ¯ Ù…Ù‡Ø§Ù… Ù„Ø¹ÙÙ‚Ø¯ Ø§Ù„Ù†Øµ)
            async startTranslationProcess() {
                const apiProvider = document.querySelector('input[name="apiProvider"]:checked').value;
                let apiKeyOrUrl;
                let localModelName;
            
                try {
                    if (apiProvider === 'gemini') {
                        apiKeyOrUrl = this.dom.geminiKeyInput.value.trim();
                        if (!this.validation.validateApiKey(apiKeyOrUrl, 'gemini')) {
                            return this.ui.showAlert(`Ù…ÙØªØ§Ø­ API Ù„Ù€ Gemini ØºÙŠØ± ØµØ§Ù„Ø­.`, 'error');
                        }
                    } else if (apiProvider === 'chatgpt') {
                        apiKeyOrUrl = this.dom.chatgptKeyInput.value.trim();
                        if (!this.validation.validateApiKey(apiKeyOrUrl, 'chatgpt')) {
                            return this.ui.showAlert(`Ù…ÙØªØ§Ø­ API Ù„Ù€ ChatGPT ØºÙŠØ± ØµØ§Ù„Ø­.`, 'error');
                        }
                    } else if (apiProvider === 'local') {
                        apiKeyOrUrl = this.dom.localModelUrl.value.trim();
                        localModelName = this.dom.localModelName.value.trim();
                        const validation = this.validation.validateLocalModelSettings(apiKeyOrUrl, localModelName);
                        if (!validation.valid) {
                            return this.ui.showAlert(validation.message, 'error');
                        }
                    } else {
                        return this.ui.showAlert('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù…Ø²ÙˆØ¯ Ø®Ø¯Ù…Ø© ØµØ§Ù„Ø­.', 'error');
                    }
            
                    if (this.state.selectedFilesInfo.length === 0) {
                        return this.ui.showAlert('Ø§Ø®ØªØ± Ù…Ù„Ù JSON ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„.', 'error');
                    }
                } catch (validationError) {
                    return this.ui.showAlert('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø©.', 'error');
                }
            
                this.ui.showScreen('progress');
                this.dom.translateBtn.disabled = true;
                this.state.translationCache.clear();
                this.state.startTime = Date.now();
                this.api.createAbortController();
                this.state.isTranslating = true;
            
                try {
                    this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„ÙØ§Øª...');
                    await this.fileHandler.readFilesFromInput();
                    this.state.translatedJsonData = JSON.parse(JSON.stringify(this.state.originalJsonData));
                    this.state.initialTranslatedJsonData = [];
            
                    const allJobs = [];
                    const parsedDataMap = new Map();
            
                    const processField = (htmlString, basePointer) => {
                        if (!htmlString || typeof htmlString !== 'string') return;
                        const { jobs, parsedBody } = this.utils.parseHtmlAndCreateJobs(htmlString, basePointer);
                        allJobs.push(...jobs);
                        const mapKey = JSON.stringify(basePointer);
                        parsedDataMap.set(mapKey, parsedBody);
                    };
                    
                    this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ÙˆØªØ¬Ù‡ÙŠØ² Ø§Ù„Ù†ØµÙˆØµ...');
            
                    this.state.originalJsonData.forEach((file, fileIndex) => {
                        // Process statement field
                        processField(file.data.statement, { fileIndex, key: 'statement' });
                        
                        // Process parts
                        file.data.parts?.forEach((part, partIndex) => {
                            const originalPart = TranslatorApp.state.originalJsonData[fileIndex].data.parts[partIndex];
                            
                            // Process stem field
                            processField(part.stem, { fileIndex, partIndex, key: 'stem' });
            
                            // Process answer field
                            if (originalPart.answer) {
                                if (Array.isArray(originalPart.answer)) {
                                    originalPart.answer.forEach((answerItem, answerIndex) => {
                                        processField(answerItem, { fileIndex, partIndex, answerIndex, key: 'answer', isArray: true });
                                    });
                                } else if (typeof originalPart.answer === 'string') {
                                    processField(originalPart.answer, { fileIndex, partIndex, key: 'answer' });
                                } else if (typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('value')) {
                                    processField(originalPart.answer.value, { fileIndex, partIndex, key: 'answer', subKey: 'value' });
                                } else if (typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('key') && originalPart.answer.hasOwnProperty('value') && originalPart.answer.hasOwnProperty('unit')) {
                                    // Special case for a more complex object answer type
                                    processField(originalPart.answer.key, { fileIndex, partIndex, key: 'answer', subKey: 'key' });
                                    processField(originalPart.answer.value, { fileIndex, partIndex, key: 'answer', subKey: 'value' });
                                    // Translate unit directly using unitsMap instead of sending to AI
                                    const originalUnit = originalPart.answer.unit || '';
                                    const translatedUnit = TranslatorApp.quality.unitsMap[originalUnit.toLowerCase()] || originalUnit;
                                    this.state.translatedJsonData[fileIndex].data.parts[partIndex].answer.unit = translatedUnit;
                                }
                            }
                            
                            // Process choices
                            originalPart.choices?.forEach((choice, choiceIndex) => {
                                processField(choice.html_content, { fileIndex, partIndex, choiceIndex, key: 'choice' });
                            });
                            
                            // Process gap_text_keys
                            if (originalPart.gap_text_keys) {
                                originalPart.gap_text_keys.forEach((keyItem, keyIndex) => {
                                    processField(keyItem.value, { fileIndex, partIndex, key: 'gap_text_keys', keyIndex: keyIndex, subKey: 'value' });
                                });
                            }
                            
                            // Process ai.guidelines (for string type questions)
                            if (originalPart.ai && originalPart.ai.guidelines && Array.isArray(originalPart.ai.guidelines)) {
                                originalPart.ai.guidelines.forEach((guideline, guidelineIndex) => {
                                    // Translate student_answer
                                    if (guideline.student_answer && typeof guideline.student_answer === 'string') {
                                        processField(guideline.student_answer, { fileIndex, partIndex, key: 'ai_guideline', guidelineIndex, subKey: 'student_answer' });
                                    }
                                    // Translate comment
                                    if (guideline.comment && typeof guideline.comment === 'string') {
                                        processField(guideline.comment, { fileIndex, partIndex, key: 'ai_guideline', guidelineIndex, subKey: 'comment' });
                                    }
                                });
                            }
                        });
                    });
                    
                    const uniqueJobs = [];
                    const seen = new Set();
                    for (const job of allJobs) {
                        if (!seen.has(job.originalText)) {
                            seen.add(job.originalText);
                            uniqueJobs.push(job);
                        }
                    }
                    
                    // Check Translation Memory first
                    let tmHits = 0;
                    let jobsToTranslate = [];
                    
                    if (this.dom.useTmCheckbox.checked) {
                        this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ ÙØ­Øµ Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø©...');
                        const ctx = {
                            subject: this.state.selectedSubject,
                            grade: this.state.selectedGrade
                        };
                        uniqueJobs.forEach(job => {
                            const tmEntry = this.translationMemory.get(job.originalText);
                            if (tmEntry && tmEntry.translation) {
                                // Use cached translation and apply post-processing for current context
                                let processedTranslation = this.quality.postProcess(tmEntry.translation, ctx);
                                this.state.translationCache.set(job.originalText, processedTranslation);
                                tmHits++;
                            } else {
                                // Need to translate this
                                jobsToTranslate.push(job);
                            }
                        });
                        
                        if (tmHits > 0) {
                            console.log(`TM hits: ${tmHits}/${uniqueJobs.length}`);
                            this.ui.updateProgress(`ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ ${tmHits} ØªØ±Ø¬Ù…Ø© Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø©...`);
                        }
                    } else {
                        jobsToTranslate = uniqueJobs;
                    }
                    
                    this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø©...');
                    const allTextsForGlossary = jobsToTranslate.map(j => j.originalText);
                    await this.remoteGlossary.fetchApproved(this.state.selectedSubject, this.state.selectedGrade, allTextsForGlossary);
            
                    jobsToTranslate.forEach(job => {
                        const { modifiedText, placeholders } = this.remoteGlossary.applyWithPlaceholders(job.originalText);
                        job.realOriginalText = job.originalText;
                        job.originalText = modifiedText;
                        job.placeholders = placeholders;
                    });
            
                    if (jobsToTranslate.length > 0) {
                        this.ui.updateProgress(`Ø¬Ø§Ø±ÙŠ ØªØ±Ø¬Ù…Ø© ${jobsToTranslate.length} Ù†Øµ Ø¬Ø¯ÙŠØ¯...`);
                        const systemPrompt = this.subjects.buildSystemPrompt();
                        await this.api.translateInChunks(jobsToTranslate, apiKeyOrUrl, apiProvider, localModelName, systemPrompt);
                    }
            
                    this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…ØªØ±Ø¬Ù…...');
            
                    allJobs.forEach(job => {
                        const cacheKey = job.realOriginalText || job.originalText;
                        let translatedText = this.state.translationCache.get(cacheKey);
                        if (translatedText && job.domNode) {
                            translatedText = this.quality.cleanLatexArabic(translatedText);
                            job.domNode.nodeValue = translatedText;
                        }
                    });
            
                    for (const [mapKey, parsedBody] of parsedDataMap.entries()) {
                        const pointer = JSON.parse(mapKey);
                        const finalHtml = parsedBody.innerHTML;
                        let cleanedHtml = TranslatorApp.quality.cleanLatexArabic(finalHtml);
                        // Ensure RTL direction for Arabic content
                        cleanedHtml = TranslatorApp.quality.ensureRTLDirection(cleanedHtml);
                        const { fileIndex, partIndex, choiceIndex, key, keyIndex, subKey, answerIndex, isArray } = pointer;
                        let target = this.state.translatedJsonData[fileIndex].data;
            
                        if (key === 'statement') {
                            target.statement = cleanedHtml;
                        } else if (key === 'stem') {
                            target.parts[partIndex].stem = cleanedHtml;
                        } else if (key === 'answer') {
                            if (isArray) { // Check if the original was an array
                                if (target.parts?.[partIndex]?.answer && target.parts[partIndex].answer.length > answerIndex) {
                                     target.parts[partIndex].answer[answerIndex] = cleanedHtml;
                                }
                            } else if (subKey === 'value') {
                                target.parts[partIndex].answer.value = cleanedHtml;
                            } else if (subKey === 'key') {
                                 target.parts[partIndex].answer.key = cleanedHtml;
                            } else if (subKey === 'unit') {
                                 target.parts[partIndex].answer.unit = cleanedHtml;
                            } else {
                                target.parts[partIndex].answer = cleanedHtml;
                            }
                        } else if (key === 'choice') {
                            target.parts[partIndex].choices[choiceIndex].html_content = cleanedHtml;
                        } else if (key === 'gap_text_keys' && subKey === 'value') {
                            if (target.parts[partIndex].gap_text_keys && target.parts[partIndex].gap_text_keys[keyIndex]) {
                                target.parts[partIndex].gap_text_keys[keyIndex].value = cleanedHtml;
                            }
                        } else if (key === 'ai_guideline') {
                            // Handle ai.guidelines translation
                            const guidelineIndex = pointer.guidelineIndex;
                            if (target.parts[partIndex].ai && target.parts[partIndex].ai.guidelines && target.parts[partIndex].ai.guidelines[guidelineIndex]) {
                                if (subKey === 'student_answer') {
                                    target.parts[partIndex].ai.guidelines[guidelineIndex].student_answer = cleanedHtml;
                                } else if (subKey === 'comment') {
                                    target.parts[partIndex].ai.guidelines[guidelineIndex].comment = cleanedHtml;
                                }
                            }
                        }
                    }
            
                    this.state.activeScreen = 'preview';
                    // Save initial translation for diff comparison
                    this.state.initialTranslatedJsonData = JSON.parse(JSON.stringify(this.state.translatedJsonData));
                    this.history.push(this.state.translatedJsonData);
                    
                    // Save Translation Memory to localStorage
                    if (this.dom.useTmCheckbox.checked) {
                        this.translationMemory.save();
                        this.translationMemory.updateUI();
                    }
                    
                    this.session.save();
                    this.ui.showScreen('preview');
                    this.preview.render();
                    const stats = this.statistics.calculate();
                    this.ui.renderStatistics(stats);
                    
                    // Show success message with TM stats
                    let successMessage = 'ØªÙ…Øª Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­';
                    if (this.dom.useTmCheckbox.checked && tmHits > 0) {
                        successMessage += ` (ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… ${tmHits} ØªØ±Ø¬Ù…Ø© Ù…Ø­ÙÙˆØ¸Ø©)`;
                    }
                    this.ui.showAlert(successMessage, 'success');
            
                } catch (error) {
                    if (error?.name !== 'AbortError') {
                        console.error('Translation process failed:', error);
                        this.ui.showAlert(error.message, 'error');
                        this.ui.showScreen('setup');
                    }
                } finally {
                    this.dom.translateBtn.disabled = false;
                    this.state.isTranslating = false;
                }
            },

            statistics: {
                calculate() {
                    let totalTexts = 0, totalWords = 0;
                    const count = (text) => {
                        if (text && typeof text === 'string') {
                            totalTexts++;
                            const div = document.createElement('div'); div.innerHTML = text;
                            totalWords += (div.textContent || div.innerText || "").split(/\s+/).filter(Boolean).length;
                        }
                    };
                    TranslatorApp.state.originalJsonData.forEach(file => {
                        count(file.data.statement);
                        file.data.parts?.forEach(part => {
                            count(part.stem);
                            if (typeof part.answer === 'string') count(part.answer);
                            part.choices?.forEach(choice => count(choice.html_content));
                            part.gap_text_keys?.forEach(keyItem => count(keyItem.value));
                        });
                    });
                    const timeElapsed = TranslatorApp.state.startTime ? ((Date.now() - TranslatorApp.state.startTime) / 1000).toFixed(1) : 0;
                    return { totalFiles: TranslatorApp.state.selectedFilesInfo.length, totalTexts, totalWords, timeElapsed };
                }
            },

            ui: {
                showScreen(screen) {
                    try {
                        TranslatorApp.state.activeScreen = screen;
                        ['setupSection', 'progressContainer', 'previewSection', 'analyticsSection'].forEach(id => {
                            try {
                                TranslatorApp.dom[id]?.classList.add('hidden');
                            } catch (error) {
                                console.warn(`Error hiding ${id}:`, error);
                            }
                        });

                        if (screen === 'setup') {
                            try {
                                TranslatorApp.dom.setupSection.classList.remove('hidden');
                            } catch (error) {
                                console.warn('Error showing setup section:', error);
                            }
                        }
                        if (screen === 'progress') {
                            try {
                                TranslatorApp.dom.progressContainer.classList.remove('hidden');
                            } catch (error) {
                                console.warn('Error showing progress container:', error);
                            }
                        }
                        if (screen === 'preview') {
                            try {
                                TranslatorApp.dom.previewSection.classList.remove('hidden');
                                TranslatorApp.dom.analyticsSection.classList.remove('hidden');
                            } catch (error) {
                                console.warn('Error showing preview section:', error);
                            }
                        }

                        // Reset any error states
                        if (screen === 'setup') {
                            try {
                                TranslatorApp.dom.translateBtn.disabled = false;
                                TranslatorApp.state.isTranslating = false;
                            } catch (error) {
                                console.warn('Error resetting translate button:', error);
                            }
                        }
                    } catch (error) {
                        console.error('Show screen error:', error);
                    }
                },
                updateProgress(text) {
                    try {
                        TranslatorApp.dom.progressText.textContent = text;
                    } catch (error) {
                        console.error('Update progress error:', error);
                    }
                },
                showAlert(message, type = 'error', duration = 5000) {
                    const colors = { error: 'bg-red-500', success: 'bg-green-500', info: 'bg-blue-500', warning: 'bg-yellow-500' };
                    const alertBox = document.createElement('div');
                    alertBox.className = `alert flex justify-between items-center text-white p-4 rounded-lg shadow-xl ${colors[type] || 'bg-gray-500'}`;

                    // Sanitize message to prevent XSS
                    const sanitizedMessage = TranslatorApp.security.sanitize(message);
                    alertBox.innerHTML = `<span>${sanitizedMessage}</span><button class="mr-2 text-xl font-bold" aria-label="Ø¥ØºÙ„Ø§Ù‚">&times;</button>`;

                    alertBox.querySelector('button').onclick = () => alertBox.remove();
                    TranslatorApp.dom.alertContainer.appendChild(alertBox);

                    // Auto-remove after duration
                    if (duration) {
                        setTimeout(() => {
                            alertBox.classList.add('fade-out');
                            alertBox.addEventListener('transitionend', () => alertBox.remove());
                        }, duration);
                    }

                    // Log to console for debugging
                    console.log(`[${type.toUpperCase()}] ${message}`);
                },
                renderFileList() {
                    try {
                        const { fileList } = TranslatorApp.dom;
                        fileList.innerHTML = '';
                        if (TranslatorApp.state.selectedFilesInfo.length === 0) return;
                        const ul = document.createElement('ul');
                        ul.className = 'my-4 space-y-2';
                        TranslatorApp.state.selectedFilesInfo.forEach((fileInfo, index) => {
                            const li = document.createElement('li');
                            li.className = 'flex justify-between items-center p-2 rounded-lg';
                            li.style.backgroundColor = 'color-mix(in srgb, var (--primary-color) 5%, var(--card-bg))';
                            li.innerHTML = `<span class="font-medium">${TranslatorApp.security.sanitize(fileInfo.name)}</span><button data-index="${index}" class="remove-file-btn text-red-500 hover:text-red-700 font-bold text-xl" aria-label="Ø¥Ø²Ø§Ù„Ø©">&times;</button>`;
                            ul.appendChild(li);
                        });
                        fileList.appendChild(ul);
                        fileList.querySelectorAll('.remove-file-btn').forEach(btn => {
                            btn.onclick = (e) => {
                                try {
                                    TranslatorApp.fileHandler.removeFile(parseInt(btn.dataset.index));
                                } catch (error) {
                                    console.error('Remove file error:', error);
                                    TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ù„Ù.', 'error');
                                }
                            };
                        });
                    } catch (error) {
                        console.error('Render file list error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù„ÙØ§Øª.', 'error');
                    }
                },
                showGlossaryModal(show) {
                    try {
                        TranslatorApp.dom.glossaryModal.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show glossary modal error:', error);
                    }
                },
                showMappedIdsModal(show) {
                    try {
                        TranslatorApp.dom.mappedIdsModal.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show mapped IDs modal error:', error);
                    }
                },
                showSubjectsModal(show) {
                    try {
                        TranslatorApp.dom.subjectsModal.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show subjects modal error:', error);
                    }
                },
                showModal(id, show) {
                    try {
                        const el = TranslatorApp.dom[id];
                        if (el) el.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show modal error:', error);
                    }
                },
                renderStatistics(stats) {
                    try {
                        const { statsContainer } = TranslatorApp.dom;
                        statsContainer.innerHTML = '';
                        const map = {
                            'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ù„ÙØ§Øª': stats.totalFiles,
                            'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù†ØµÙˆØµ': stats.totalTexts,
                            'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙƒÙ„Ù…Ø§Øª': stats.totalWords,
                            'Ø²Ù…Ù† Ø§Ù„ØªØ±Ø¬Ù…Ø© (Ø«)': stats.timeElapsed
                        };
                        Object.entries(map).forEach(([label, value]) => {
                            const card = document.createElement('div');
                            card.className = 'p-4 rounded-lg';
                            card.style.backgroundColor = 'color-mix(in srgb, var (--primary-color) 10%, var (--card-bg))';
                            card.innerHTML = `<div class="text-2xl font-bold" style="color: var (--primary-color);">${value}</div><div class="text-sm" style="color: var (--secondary-text);">${label}</div>`;
                            statsContainer.appendChild(card);
                        });
                    } catch (error) {
                        console.error('Render statistics error:', error);
                    }
                },
                setSaveIndicator(state) {
                    try {
                        const el = TranslatorApp.dom.saveIndicator;
                        if (!el) return;

                        if (state === 'saving') {
                            el.textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...';
                            el.classList.remove('saved', 'error');
                        }
                        else if (state === 'saved') {
                            el.textContent = 'âœ“ Ù…Ø­ÙÙˆØ¸';
                            el.classList.add('saved');
                            el.classList.remove('error');
                            setTimeout(() => {
                                el.textContent = 'â€”';
                                el.classList.remove('saved');
                            }, 2000);
                        }
                        else if (state === 'error') {
                            el.textContent = 'âœ— Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸';
                            el.classList.add('error');
                            el.classList.remove('saved');
                        }
                        else {
                            el.textContent = 'â€”';
                            el.classList.remove('saved', 'error');
                        }
                    } catch (error) {
                        console.error('Save indicator error:', error);
                    }
                }
            },

            preview: {
                dmp: new diff_match_patch(),

                processBlankTags(htmlString) {
                    try {
                        if (!htmlString || typeof htmlString !== 'string') return htmlString;
                        
                        let processed = htmlString;
                        
                        // Handle data-node-type="blank-line" tags (like in the JSON file)
                        processed = processed.replace(
                            /<span\s+data-node-type=["']blank-line["'][^>]*>(.*?)<\/span>/gi,
                            (match, content) => {
                                // Convert &nbsp; to actual space and create a blank slot
                                const blankContent = content.replace(/&nbsp;/g, ' ').trim() || '___';
                                // Escape quotes in data-blank attribute
                                const escapedBlank = blankContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<span class="blank-slot rtl-auto" data-blank="${escapedBlank}" dir="rtl">${blankContent}</span>`;
                            }
                        );
                        
                        // Handle data-node-type="blank" tags
                        processed = processed.replace(
                            /<span\s+data-node-type=["']blank["'][^>]*>(.*?)<\/span>/gi,
                            (match, content) => {
                                const blankContent = content.replace(/&nbsp;/g, ' ').trim() || '___';
                                const escapedBlank = blankContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<span class="blank-slot rtl-auto" data-blank="${escapedBlank}" dir="rtl">${blankContent}</span>`;
                            }
                        );
                        
                        // Handle any span with data-node-variation="space"
                        processed = processed.replace(
                            /<span[^>]*data-node-variation=["']space["'][^>]*>(.*?)<\/span>/gi,
                            (match, content) => {
                                const blankContent = content.replace(/&nbsp;/g, ' ').trim() || '___';
                                const escapedBlank = blankContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<span class="blank-slot rtl-auto" data-blank="${escapedBlank}" dir="rtl">${blankContent}</span>`;
                            }
                        );
                        
                        // Handle any other blank-related attributes
                        processed = processed.replace(
                            /<span[^>]*data-blank[^>]*>(.*?)<\/span>/gi,
                            (match, content) => {
                                const blankContent = content.replace(/&nbsp;/g, ' ').trim() || '___';
                                const escapedBlank = blankContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<span class="blank-slot rtl-auto" data-blank="${escapedBlank}" dir="rtl">${blankContent}</span>`;
                            }
                        );
                        
                        return processed;
                    } catch (error) {
                        console.error('Process blank tags error:', error);
                        return htmlString;
                    }
                },
                
                processMathFieldTags(htmlString) {
                    try {
                        if (!htmlString || typeof htmlString !== 'string') return htmlString;
                        
                        let processed = htmlString;
                        
                        // First, remove ONLY LexicalTheme__math wrapper spans
                        // Be very specific to avoid removing other spans
                        processed = processed.replace(
                            /<span\s+class=["']LexicalTheme__math--inline["']\s+data-node-type=["']math["']\s+data-node-variation=["']inline["'][^>]*>(<math-field[^>]*>.*?<\/math-field>)<\/span>/gi,
                            '$1'
                        );
                        
                        // Remove ALL dir="ltr" spans FIRST - these are AI-generated and should be removed
                        // This is the most common issue, so handle it first
                        const beforeDirRemoval = processed;
                        processed = processed.replace(
                            /<span\s+dir=["']ltr["'][^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // Debug: log if we removed any dir="ltr" spans
                        if (beforeDirRemoval !== processed) {
                            console.log('Removed dir="ltr" spans:', beforeDirRemoval, 'â†’', processed);
                        }
                        
                        // Also handle spans with dir="ltr" and other attributes
                        processed = processed.replace(
                            /<span[^>]*dir=["']ltr["'][^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // Remove white-space: pre-wrap spans (they're just wrappers for text)
                        processed = processed.replace(
                            /<span[^>]*style=["'][^"']*white-space:\s*pre-wrap[^"']*["'][^>]*>([^<]+)<\/span>/gi,
                            '$1'
                        );
                        
                        // Remove LexicalTheme__paragraph wrapper
                        processed = processed.replace(
                            /<p\s+class=["']LexicalTheme__paragraph["'][^>]*>(.*?)<\/p>/gi,
                            '$1'
                        );
                        
                        // Fix malformed tags like "yspan>", "xspan>", "gspan>" - these are broken AI output
                        processed = processed.replace(
                            /(\w+)span>/gi,
                            '$1'
                        );
                        
                        // Fix any remaining broken span tags
                        processed = processed.replace(
                            /<span[^>]*>([^<]*)span>/gi,
                            '$1'
                        );
                        
                        // Additional fix for specific malformed patterns
                        processed = processed.replace(
                            /(\d+\s*\w+)span>/gi,
                            '$1'
                        );
                        
                        // Fix common malformed patterns like "8 gspan>"
                        processed = processed.replace(
                            /(\d+\s*[a-zA-Z]+)span>/gi,
                            '$1'
                        );
                        
                        // Fix any remaining "span>" at the end of words
                        processed = processed.replace(
                            /([a-zA-Z0-9]+)span>/gi,
                            '$1'
                        );
                        
                        // Remove any remaining empty or unnecessary spans
                        processed = processed.replace(
                            /<span[^>]*><\/span>/gi,
                            ''
                        );
                        
                        // Clean up any orphaned closing tags
                        processed = processed.replace(
                            /<\/span>/gi,
                            ''
                        );
                        
                        // Final cleanup: remove any remaining spans with dir="ltr" (multiple passes to be sure)
                        processed = processed.replace(
                            /<span[^>]*dir\s*=\s*["']ltr["'][^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // Handle edge cases where quotes might be different
                        processed = processed.replace(
                            /<span[^>]*dir\s*=\s*['"]ltr['"][^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // NUCLEAR OPTION: Remove ALL remaining spans completely (no exceptions)
                        // This ensures absolutely NO span tags appear anywhere
                        const beforeNuclear = processed;
                        processed = processed.replace(
                            /<span[^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // Debug: log nuclear option results
                        if (beforeNuclear !== processed) {
                            console.log('NUCLEAR: Removed remaining spans:', beforeNuclear, 'â†’', processed);
                        }
                        
                        // Remove any remaining opening span tags
                        processed = processed.replace(
                            /<span[^>]*>/gi,
                            ''
                        );
                        
                        // Remove any remaining closing span tags
                        processed = processed.replace(
                            /<\/span>/gi,
                            ''
                        );
                        
                        // Handle existing math-field tags from JSON
                        // Convert them to proper format with all necessary attributes
                        processed = processed.replace(
                            /<math-field([^>]*)>(.*?)<\/math-field>/gi,
                            (match, attrs, content) => {
                                // Extract value attribute
                                const valueMatch = attrs.match(/value=["']([^"']*)["']/i);
                                let value = valueMatch ? valueMatch[1] : content;
                                
                                // Clean up value - handle escaped characters and special cases
                                value = value.replace(/\\displaystyle\{([^}]+)\}/g, '$1')
                                           .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '\\frac{$1}{$2}')
                                           .replace(/â€‹/g, ''); // Remove zero-width spaces
                                
                                // Extract or set default-mode
                                const modeMatch = attrs.match(/default-mode=["']([^"']*)["']/i);
                                const mode = modeMatch ? modeMatch[1] : 'inline-math';
                                
                                // Check if read-only (from source)
                                const isReadOnly = attrs.includes('read-only');
                                const readOnlyAttr = isReadOnly ? 'read-only="true"' : '';
                                
                                // Create proper math-field with all attributes
                                // Always force LTR for math content
                                // Escape the value properly for HTML attribute
                                const escapedValue = value.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<math-field default-mode="${mode}" value="${escapedValue}" ${readOnlyAttr} virtual-keyboard-mode="onfocus" use-shared-virtual-keyboard dir="ltr" style="direction: ltr; unicode-bidi: embed;"></math-field>`;
                            }
                        );
                        
                        return processed;
                    } catch (error) {
                        console.error('Process math field tags error:', error);
                        return htmlString;
                    }
                },

                renderContentWithMath(htmlString) {
                    try {
                        if (typeof htmlString !== 'string' || !htmlString) {
                            return '<div class="content-root" dir="rtl">&nbsp;</div>';
                        }
                        const cleanedHtml = htmlString.replace(/R\s*(\d+)/g, 'ÙˆØ§Ù„Ø¨Ø§Ù‚ÙŠ $1');

                        // 1. First, handle blank tags and math-field tags before sanitization
                        let processedHtml = this.processBlankTags(cleanedHtml);
                        processedHtml = this.processMathFieldTags(processedHtml);
                        
                        // 2. Sanitize the processed HTML (but keep math-field tags)
                        let sanitizedHtml = TranslatorApp.security.sanitize(processedHtml);
                        
                        // 3. Create a temporary DOM element to parse the sanitized HTML
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = sanitizedHtml;
                
                        // 3. Use a TreeWalker to process all nodes and convert LaTeX
                        const walker = document.createTreeWalker(
                            tempDiv,
                            NodeFilter.SHOW_TEXT,
                            null,
                            false
                        );
                        const nodesToReplace = [];
                        let node;
                        while ((node = walker.nextNode())) {
                            let textContent = node.textContent;

                            // Find and replace LaTeX expressions
                            const latexRegex = /(\$\$[\s\S]*?\$\$|\$[^$]*\$)/g;
                            const parts = textContent.split(latexRegex);
                
                            if (parts.length > 1) {
                                const fragment = document.createDocumentFragment();
                                parts.forEach(part => {
                                    const isDisplayMode = part.startsWith('$$') && part.endsWith('$$');
                                    const isInlineMode = part.startsWith('$') && part.endsWith('$');
                
                                    if (isDisplayMode || isInlineMode) {
                                        const latex = part.slice(isDisplayMode ? 2 : 1, isDisplayMode ? -2 : -1);

                                        const mf = document.createElement('math-field');
                                        mf.setAttribute('default-mode', isDisplayMode ? 'math' : 'inline-math');
                                        mf.setAttribute('value', latex);
                                        mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                        mf.setAttribute('use-shared-virtual-keyboard', '');
                                        mf.setAttribute('dir', 'ltr');
                                    
                                        // Create the delete button and add it directly to the math-field
                                        const deleteBtn = document.createElement('button');
                                        deleteBtn.className = 'math-field-delete-btn';
                                        deleteBtn.textContent = 'Ã—';
                                        deleteBtn.title = 'Ø­Ø°Ù Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©';
                                        deleteBtn.onclick = (event) => {
                                            event.stopPropagation();
                                            const fieldContainer = mf.closest('.editable-preview-field');
                                            mf.remove(); // This removes the math field itself
                                            if (fieldContainer) {
                                                TranslatorApp.preview.handlePreviewFieldUpdate(fieldContainer);
                                            }
                                        };
                                        mf.appendChild(deleteBtn);
                                        fragment.appendChild(mf);
                                    } else if (part) {
                                        fragment.appendChild(document.createTextNode(part));
                                    }
                                });
                                nodesToReplace.push({ oldNode: node, newNode: fragment });
                            }
                        }
                        nodesToReplace.forEach(({ oldNode, newNode }) => {
                            oldNode.parentNode.replaceChild(newNode, oldNode);
                        });
                        let finalHtml = tempDiv.innerHTML;
                        finalHtml = this.decorateBlanks(finalHtml);
                        finalHtml = this.injectChemistryMathFields(finalHtml);
                        finalHtml = TranslatorApp.utils.textDirection.enhancePreviewContent(finalHtml);
                
                        const textContent = tempDiv.textContent || '';
                        const containerDirection = TranslatorApp.utils.textDirection.getDominantDirection(textContent);
                        const dirAttr = containerDirection === 'rtl' ? 'rtl' : 'ltr';
                
                        return `<div class="content-root" dir="${dirAttr}">${finalHtml}</div>`;
                    } catch (error) {
                        console.error('Render content with math error:', error);
                        return '<div class="content-root" dir="rtl">ÙØ´Ù„ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­ØªÙˆÙ‰</div>';
                    }
                },
                    
                handleCopyEvent(e) {
                    const selection = window.getSelection();
                    if (!selection.rangeCount) return;
                
                    const range = selection.getRangeAt(0);
                    const clonedContent = range.cloneContents();
                    const tempDiv = document.createElement('div');
                    tempDiv.appendChild(clonedContent);
                
                    const mathFields = tempDiv.querySelectorAll('math-field');
                    mathFields.forEach(mf => {
                        const mode = mf.getAttribute('default-mode');
                        const value = mf.value;
                        const delimiter = (mode === 'math') ? '$$' : '$';
                        const latexString = `${delimiter}${value}${delimiter}`;
                        
                        const textNode = document.createTextNode(latexString);
                        mf.parentNode.replaceChild(textNode, mf);
                    });
                    const html = tempDiv.innerHTML;
                    const text = tempDiv.textContent || '';
                    
                    e.clipboardData.setData('text/html', html);
                    e.clipboardData.setData('text/plain', text);
                    e.preventDefault();
                    
                },

                handlePasteEvent(e) {
                    try {
                        e.preventDefault();
                        const pasteHtml = e.clipboardData.getData('text/html');
                        const pasteText = e.clipboardData.getData('text/plain');
                        let contentToInsert = '';
                        if (pasteHtml) {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = pasteHtml;
                            contentToInsert = tempDiv.innerHTML;
                        } else {
                            contentToInsert = pasteText;
                        }
                        if (!contentToInsert) return;

                        const selection = window.getSelection();
                        if (!selection.rangeCount) return;
                        
                        const range = selection.getRangeAt(0);
                        range.deleteContents();
                        const processorDiv = document.createElement('div');
                        processorDiv.innerHTML = contentToInsert;
                        const walker = document.createTreeWalker(
                            processorDiv,
                            NodeFilter.SHOW_TEXT,
                            null,
                            false
                        );
                        let node;
                        const nodesToReplace = [];
                        
                        while ((node = walker.nextNode())) {
                            const textContent = node.textContent;
                            const latexRegex = /(\$\$[\s\S]*?\$\$|\$[^$]*\$)/g;
                            const parts = textContent.split(latexRegex);
                            
                            if (parts.length > 1) {
                                const fragment = document.createDocumentFragment();
                                parts.forEach(part => {
                                    if (part.startsWith('$$') && part.endsWith('$$')) {
                                        const latex = part.slice(2, -2);
                                        const mf = document.createElement('math-field');
                                        mf.setAttribute('default-mode', 'math');
                                        mf.setAttribute('value', latex);
                                        mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                        mf.setAttribute('use-shared-virtual-keyboard', '');
                                        mf.setAttribute('dir', 'ltr');
                                        fragment.appendChild(mf);
                                    } else if (part.startsWith('$') && part.endsWith('$')) {
                                        const latex = part.slice(1, -1);
                                        const mf = document.createElement('math-field');
                                        mf.setAttribute('default-mode', 'inline-math');
                                        mf.setAttribute('value', latex);
                                        mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                        mf.setAttribute('use-shared-virtual-keyboard', '');
                                        mf.setAttribute('dir', 'ltr');
                                        fragment.appendChild(mf);
                                    } else if (part) {
                                        fragment.appendChild(document.createTextNode(part));
                                    }
                                });
                                nodesToReplace.push({ oldNode: node, newNode: fragment });
                            }
                        }
                        nodesToReplace.forEach(({ oldNode, newNode }) => {
                            oldNode.parentNode.replaceChild(newNode, oldNode);
                        });
                        const finalFragment = document.createDocumentFragment();
                        while (processorDiv.firstChild) {
                            finalFragment.appendChild(processorDiv.firstChild);
                        }
                        range.insertNode(finalFragment);
                        selection.collapseToEnd();
                        
                        const fieldContainer = e.target.closest('.editable-preview-field');
                        if (fieldContainer) {
                            this.handlePreviewFieldUpdate(fieldContainer);
                        }
                    } catch (error) {
                        console.error('Paste event error:', error);
                        TranslatorApp.ui.showAlert('Paste failed. Plain text copied instead.', 'error');
                        document.execCommand('insertText', false, e.clipboardData.getData('text/plain'));
                    }
                    
                },      

                // Convert plain chemical formulas (e.g., NaHCO3, H2SO4, Ca(OH)2) into inline math-fields
                injectChemistryMathFields(text) {
                    try {
                        if (!text || typeof text !== 'string') return text;
                        const escapeAttr = (s) => (s || '').replace(/"/g, '&quot;');
                        // Basic LaTeX conversion: element digits -> _{digits}, parenthesis digits -> _{digits}
                        const toLatex = (formula) => {
                            try {
                                let out = formula;
                                out = out.replace(/([A-Za-z][a-z]?)\s*(\d+)/g, '$1_{$2}');
                                out = out.replace(/\)(\d+)/g, ')_{$1}');
                                return out;
                            } catch (error) {
                                console.warn('LaTeX conversion error:', error);
                                return formula;
                            }
                        };
                        // Regex for typical chemical formula tokens
                        const chemRegex = /\b(?:[A-Z][a-z]?\d*)+(?:\([A-Za-z\d]+\)\d*)*\b/g;
                        return text.replace(chemRegex, (match) => {
                            try {
                                // Avoid converting if already inside an HTML tag like <span> or attributes
                                // Heuristic: skip if match is immediately preceded by '&' (entity) or within a tag
                                // Since we sanitize later and we run on plain text chunks, this is usually safe
                                const latex = escapeAttr(toLatex(match));
                                return `<math-field default-mode="inline-math" value="${latex}" virtual-keyboard-mode="onfocus" use-shared-virtual-keyboard dir="ltr"></math-field>`;
                            } catch (error) {
                                console.warn('Chemistry field injection error:', error);
                                return match;
                            }
                        });
                    } catch (error) {
                        console.error('Inject chemistry math fields error:', error);
                        return text;
                    }
                },

                decorateBlanks(text) {
                    try {
                        if (!text || typeof text !== 'string') return text;
                        // Replace sequences of 3+ underscores with a visual blank slot
                        // Also handle other common blank patterns like [___], (___), etc.
                        let decorated = text;

                        // Detect text direction for appropriate blank styling
                        const textDirection = TranslatorApp.utils.textDirection.getDominantDirection(text);
                        const isMixed = TranslatorApp.utils.textDirection.isMixed(text);
                        const directionClass = isMixed ? 'mixed-content' : (textDirection === 'rtl' ? 'rtl-auto' : 'ltr-auto');

                        // Handle underscores: ___, ____, _____ etc. (preserve surrounding spaces)
                        decorated = decorated.replace(/(\s*)_{3,}(\s*)/g, (m, spaceBefore, spaceAfter) => {
                            const underscores = m.trim();
                            return `${spaceBefore}<span class="blank-slot ${directionClass}" data-blank="${underscores}" dir="${isMixed ? 'auto' : textDirection}"></span>${spaceAfter}`;
                        });

                        // Handle brackets with underscores: [___], (___), {___}
                        decorated = decorated.replace(/([\[\(\{])_{3,}([\]\)\}])/g, (m, open, close) => {
                            const underscores = m.slice(1, -1);
                            return `${open}<span class="blank-slot ${directionClass}" data-blank="${underscores}" dir="${isMixed ? 'auto' : textDirection}">${underscores}</span>${close}`;
                        });

                        // Handle simple brackets with spaces: [   ], (   ), {   }
                        decorated = decorated.replace(/([\[\(\{])\s{3,}([\]\)\}])/g, (m, open, close) => {
                            const spaces = m.slice(1, -1);
                            return `${open}<span class="blank-slot ${directionClass}" data-blank="${spaces}" dir="${isMixed ? 'auto' : textDirection}">${spaces}</span>${close}`;
                        });

                        // Handle other common blank patterns
                        // Handle question marks: ???, ???? etc.
                        decorated = decorated.replace(/\?{3,}/g, (m) => `<span class="blank-slot ${directionClass}" data-blank="${'?'.repeat(m.length)}" dir="${isMixed ? 'auto' : textDirection}">${m}</span>`);

                        // Handle dashes: ---, ---- etc.
                        decorated = decorated.replace(/-{3,}/g, (m) => `<span class="blank-slot ${directionClass}" data-blank="${'-'.repeat(m.length)}" dir="${isMixed ? 'auto' : textDirection}">${m}</span>`);

                        // Handle dots: ..., .... etc.
                        decorated = decorated.replace(/\.{3,}/g, (m) => `<span class="blank-slot ${directionClass}" data-blank="${'.'.repeat(m.length)}" dir="${isMixed ? 'auto' : textDirection}">${m}</span>`);

                        // Handle HTML content with blanks (preserve HTML structure)
                        if (decorated.includes('<') && decorated.includes('>')) {
                            // Create a temporary DOM element to process HTML content
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = decorated;

                            // Process text nodes within HTML
                            const walker = document.createTreeWalker(
                                tempDiv,
                                NodeFilter.SHOW_TEXT,
                                null,
                                false
                            );

                            const textNodes = [];
                            let node;
                            while (node = walker.nextNode()) {
                                textNodes.push(node);
                            }

                            // Process each text node
                            textNodes.forEach(textNode => {
                                const originalText = textNode.textContent;
                                let processedText = originalText;

                                // Detect direction for this specific text node
                                const nodeDirection = TranslatorApp.utils.textDirection.getDominantDirection(originalText);
                                const nodeIsMixed = TranslatorApp.utils.textDirection.isMixed(originalText);
                                const nodeDirectionClass = nodeIsMixed ? 'mixed-content' : (nodeDirection === 'rtl' ? 'rtl-auto' : 'ltr-auto');
                                const nodeDir = nodeIsMixed ? 'auto' : nodeDirection;

                                // Apply blank decoration to text content with proper direction (preserve spaces)
                                processedText = processedText.replace(/(\s*)_{3,}(\s*)/g, (m, spaceBefore, spaceAfter) => {
                                    const underscores = m.trim();
                                    return `${spaceBefore}<span class="blank-slot ${nodeDirectionClass}" data-blank="${underscores}" dir="${nodeDir}"></span>${spaceAfter}`;
                                });
                                processedText = processedText.replace(/([\[\(\{])_{3,}([\]\)\}])/g, (m, open, close) => {
                                    const underscores = m.slice(1, -1);
                                    return `${open}<span class="blank-slot ${nodeDirectionClass}" data-blank="${underscores}" dir="${nodeDir}">${underscores}</span>${close}`;
                                });
                                processedText = processedText.replace(/([\[\(\{])\s{3,}([\]\)\}])/g, (m, open, close) => {
                                    const spaces = m.slice(1, -1);
                                    return `${open}<span class="blank-slot ${nodeDirectionClass}" data-blank="${spaces}" dir="${nodeDir}">${spaces}</span>${close}`;
                                });
                                processedText = processedText.replace(/\?{3,}/g, (m) => `<span class="blank-slot ${nodeDirectionClass}" data-blank="${'?'.repeat(m.length)}" dir="${nodeDir}">${m}</span>`);
                                processedText = processedText.replace(/-{3,}/g, (m) => `<span class="blank-slot ${nodeDirectionClass}" data-blank="${'-'.repeat(m.length)}" dir="${nodeDir}">${m}</span>`);
                                processedText = processedText.replace(/\.{3,}/g, (m) => `<span class="blank-slot ${nodeDirectionClass}" data-blank="${'.'.repeat(m.length)}" dir="${nodeDir}">${m}</span>`);

                                if (processedText !== originalText) {
                                    const wrapper = document.createElement('span');
                                    wrapper.innerHTML = processedText;
                                    // Apply direction to the wrapper as well
                                    TranslatorApp.utils.textDirection.applySmartDirection(wrapper, originalText);
                                    textNode.parentNode.replaceChild(wrapper, textNode);
                                }
                            });

                            decorated = tempDiv.innerHTML;
                        }

                        return decorated;
                    } catch (error) {
                        console.error('Decorate blanks error:', error);
                        return text;
                    }
                },

                handleUnitUpdate(fieldContainer, newUnitValue) {
                    try {
                        if (!fieldContainer) return;
                
                        const path = fieldContainer.dataset.path;
                        const fileIndex = parseInt(fieldContainer.dataset.fileIndex, 10);
                        if (!path || isNaN(fileIndex)) {
                            console.warn('Invalid field container data for unit update:', { path, fileIndex });
                            return;
                        }
                
                        const pathParts = path.split('.');
                        const parentPath = pathParts.slice(0, pathParts.length - 1);
                        let targetObject = TranslatorApp.state.translatedJsonData[fileIndex].data;
                        for (const key of parentPath) {
                            targetObject = targetObject[key];
                        }
                
                        if (targetObject && typeof targetObject === 'object' && targetObject.hasOwnProperty('unit')) {
                            targetObject.unit = newUnitValue;
                        }
                        
                        this.updateDiff(fileIndex, path, newUnitValue);
                
                        const statusEl = document.getElementById(`status-field-${fileIndex}-${path.replace(/\./g, '-')}`);
                        if (statusEl) {
                            statusEl.className = 'status-dot status-edited';
                            statusEl.title = 'ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ÙŠØ¯ÙˆÙŠØ§Ù‹';
                        }
                        
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('Handle unit update error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« ÙˆØ­Ø¯Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©.', 'error');
                    }
                },
                // New helper function to get data by path
                getDataByPath(obj, path) {
                    return path.split('.').reduce((o, i) => (o ? o[i] : undefined), obj);
                },

                handlePreviewFieldUpdate(fieldContainer) {
                    try {
                        if (!fieldContainer) return;

                        const path = fieldContainer.dataset.path;
                        const fileIndex = parseInt(fieldContainer.dataset.fileIndex, 10);
                
                        if (!path || isNaN(fileIndex)) {
                            console.warn('Invalid field container data:', { path, fileIndex });
                            return;
                        }
                        let newContent = '';
                        const root = fieldContainer.querySelector('.content-root');
                        if (root) {
                            root.childNodes.forEach(node => {
                                if (node.tagName === 'MATH-FIELD') {
                                    const delimiter = node.getAttribute('default-mode') === 'math' ? '$$' : '$';
                                    newContent += `${delimiter}${node.value}${delimiter}`;
                                } else {
                                    newContent += node.outerHTML || node.textContent;
                                }
                            });
                        }
                        
                        // Remove the visual blank slots from the final HTML before saving
                        // Handle both empty blank slots and those with content
                        newContent = newContent.replace(/<span class="blank-slot"[^>]*>(.*?)<\/span>/g, (match, content) => {
                            // If content is empty or just spaces, use ___
                            if (!content || content.trim() === '') {
                                return '___';
                            }
                            // If content has actual text, preserve it but convert to underscores
                            return content.replace(/\S/g, '_').replace(/_+/g, '___');
                        });
                        this.updateData(fileIndex, path, newContent);
                        this.updateDiff(fileIndex, path);
                        const statusEl = document.getElementById(`status-field-${fileIndex}-${path.replace(/\./g, '-')}`);
                        if (statusEl) {
                            statusEl.className = 'status-dot status-edited';
                            statusEl.title = 'ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ÙŠØ¯ÙˆÙŠØ§Ù‹';
                        }

                        // Push to history after update is complete
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        TranslatorApp.state.hasUnsavedChanges = true;
                        
                        // Update quality indicators and word count for this field
                        const fieldId = fieldContainer.id;
                        setTimeout(() => {
                            this.updateQualityIndicators(fieldId, fileIndex, path);
                            this.updateWordCount(fieldId);
                            this.updateStats();
                            this.checkAndAlert(fieldId, fileIndex, path);
                        }, 100);

                    } catch (error) {
                        console.error('Handle preview field update error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø­Ù‚Ù„ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©.', 'error');
                    }
                },

                render() {
                    try {
                        const { previewContainer } = TranslatorApp.dom;
                        previewContainer.innerHTML = '';
                        
                        // Get the mapped IDs from the input field once before the loop
                        let mappedIdsArray = [];
                        try {
                            if (TranslatorApp.dom.useMappedIdsCheckbox.checked && TranslatorApp.dom.mappedIdsInput.value.trim()) {
                                mappedIdsArray = JSON.parse(TranslatorApp.dom.mappedIdsInput.value);
                            }
                        } catch (e) {
                            console.error('Error parsing mapped IDs from input:', e);
                            TranslatorApp.ui.showAlert('Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª (mapped_id) ØºÙŠØ± ØµØ§Ù„Ø­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†Ù‡Ø§ Ù…ØµÙÙˆÙØ© JSON ØµØ­ÙŠØ­Ø©.', 'error');
                        }
                
                        TranslatorApp.state.translatedJsonData.forEach((file, fileIndex) => {
                            try {
                                const fileAccordion = document.createElement('div');
                                fileAccordion.className = 'preview-card rounded-2xl shadow-lg overflow-hidden';
                
                                const header = document.createElement('button');
                                header.className = 'accordion-header';
                                
                                const originalId = TranslatorApp.state.originalJsonData[fileIndex]?.data?.id || file.name.replace('.json', '');
                                const currentMappedId = mappedIdsArray[fileIndex] || null;
                                const sourceId = TranslatorApp.state.originalJsonData[fileIndex]?.data?.metadata?.source_id?.value || 
                                                TranslatorApp.state.originalJsonData[fileIndex]?.data?.source_id?.value || null;
                
                                header.innerHTML = `
                                    <div style="width: 100%;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px;">
                                            <div style="display: flex; align-items: center;">
                                                <span style="font-weight: normal; font-size: 0.9em; color: var(--secondary-text);">Translation ID:</span>
                                                <span dir="ltr" style="font-family: monospace; margin-left: 8px; color: var(--primary-color); font-weight: 600;">${originalId}</span>
                                            </div>
                                            ${sourceId ? `
                                            <div style="display: flex; align-items: center;">
                                                <span style="font-weight: normal; font-size: 0.9em; color: var(--secondary-text);">Source ID:</span>
                                                <span dir="ltr" style="font-family: monospace; margin-left: 8px; color: var(--success-color); font-weight: 600;">${sourceId}</span>
                                            </div>
                                            ` : ''}
                                            ${currentMappedId ? `
                                            <div style="display: flex; align-items: center;">
                                                <span style="font-weight: normal; font-size: 0.9em; color: var(--secondary-text);">Mapped ID:</span>
                                                <span dir="ltr" style="font-family: monospace; margin-left: 8px;">${currentMappedId}</span>
                                            </div>
                                            ` : ''}
                                        </div>
                                        <div class="file-progress-bar">
                                            <div class="file-progress-fill" id="file-progress-fill-${fileIndex}" style="width: 0%"></div>
                                        </div>
                                        <div class="text-xs text-center mt-1" style="color: var(--secondary-text);">
                                            <span id="file-progress-text-${fileIndex}">0 Ù…Ù† 0 Ø­Ù‚ÙˆÙ„</span>
                                        </div>
                                    </div>
                                `;
                
                                header.onclick = (e) => {
                                    const content = e.currentTarget.nextElementSibling;
                                    const accordionParent = e.currentTarget.closest('.preview-card');
                                    const isOpen = content.style.maxHeight && content.style.maxHeight !== '0px';
                                    
                                    if (isOpen) {
                                        content.style.maxHeight = null;
                                        accordionParent.style.boxShadow = null;
                                        accordionParent.style.transform = null;
                                        accordionParent.classList.remove('open');
                                    } else {
                                        content.style.maxHeight = content.scrollHeight + "px";
                                        accordionParent.style.boxShadow = '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)';
                                        accordionParent.style.transform = 'scale(1.01)';
                                        accordionParent.classList.add('open');
                                    }
                                };
                                
                                const content = document.createElement('div');
                                content.className = 'accordion-content';
                                content.innerHTML = this.renderFileContent(file.data, fileIndex, currentMappedId);
                
                                fileAccordion.appendChild(header);
                                fileAccordion.appendChild(content);
                                previewContainer.appendChild(fileAccordion);
                
                                this.generateInitialDiffs(fileIndex);
                            } catch (fileError) {
                                console.warn('Error rendering file:', fileError);
                                const errorDiv = document.createElement('div');
                                errorDiv.className = 'preview-card rounded-2xl shadow-lg overflow-hidden';
                                errorDiv.innerHTML = `<div class="p-4" style="color: var(--error-color);">Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ù: ${file.name}</div>`;
                                previewContainer.appendChild(errorDiv);
                            }
                        });
                        this.prepareInteractiveMathFields();
                        
                        // Update stats and quality indicators after render
                        setTimeout(() => {
                            this.updateStats();
                            this.updateAllQualityIndicators();
                            this.updateAllWordCounts();
                            this.loadNotes();
                        }, 100);
                    } catch (error) {
                        console.error('Preview render error:', error);
                        const { previewContainer } = TranslatorApp.dom;
                        previewContainer.innerHTML = '<div class="p-4" style="color: var(--error-color);">ÙØ´Ù„ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©</div>';
                    }
                },
                
                updateStats() {
                    try {
                        let total = 0, completed = 0, edited = 0, warnings = 0;
                        
                        document.querySelectorAll('.status-dot').forEach(dot => {
                            total++;
                            if (dot.classList.contains('status-translated')) completed++;
                            if (dot.classList.contains('status-edited')) edited++;
                        });
                        
                        document.querySelectorAll('.field-error, .field-warning').forEach(() => warnings++);
                        
                        const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
                        
                        if (TranslatorApp.dom.totalFieldsCount) TranslatorApp.dom.totalFieldsCount.textContent = total;
                        if (TranslatorApp.dom.completedFieldsCount) TranslatorApp.dom.completedFieldsCount.textContent = completed;
                        if (TranslatorApp.dom.editedFieldsCount) TranslatorApp.dom.editedFieldsCount.textContent = edited;
                        if (TranslatorApp.dom.warningsCount) TranslatorApp.dom.warningsCount.textContent = warnings;
                        if (TranslatorApp.dom.progressPercentage) TranslatorApp.dom.progressPercentage.textContent = `${percentage}%`;
                    } catch (error) {
                        console.error('Update stats error:', error);
                    }
                },
                
                updateAllQualityIndicators() {
                    try {
                        document.querySelectorAll('[id^="field-"]').forEach(field => {
                            if (field.contentEditable === 'true') {
                                const fieldId = field.id;
                                const fileIndex = parseInt(field.dataset.fileIndex);
                                const path = field.dataset.path;
                                this.updateQualityIndicators(fieldId, fileIndex, path);
                            }
                        });
                    } catch (error) {
                        console.error('Update all quality indicators error:', error);
                    }
                },
                
                updateQualityIndicators(fieldId, fileIndex, path) {
                    try {
                        const field = document.getElementById(fieldId);
                        if (!field) return;
                        
                        const translatedText = field.textContent || '';
                        const originalText = this.getOriginalTextByPath(fileIndex, path);
                        
                        // Check numbers
                        const numbersCheck = document.getElementById(`numbers-check-${fieldId}`);
                        if (numbersCheck) {
                            const hasNumbers = TranslatorApp.quality.qa.checkNumbers(originalText, translatedText);
                            numbersCheck.classList.toggle('valid', hasNumbers.length === 0);
                            numbersCheck.classList.toggle('invalid', hasNumbers.length > 0);
                        }
                        
                        // Check HTML balance
                        const htmlCheck = document.getElementById(`html-check-${fieldId}`);
                        if (htmlCheck) {
                            const htmlErrors = TranslatorApp.quality.qa.checkHtmlBalance(translatedText);
                            htmlCheck.classList.toggle('valid', htmlErrors.length === 0);
                            htmlCheck.classList.toggle('invalid', htmlErrors.length > 0);
                        }
                        
                        // Check LaTeX
                        const latexCheck = document.getElementById(`latex-check-${fieldId}`);
                        if (latexCheck) {
                            const hasLatex = translatedText.includes('$') || translatedText.includes('\\');
                            const isValid = !translatedText.includes('\\alt{') && !translatedText.includes('\\prime');
                            latexCheck.classList.toggle('valid', !hasLatex || isValid);
                            latexCheck.classList.toggle('invalid', hasLatex && !isValid);
                        }
                        
                        // Check blanks
                        const blanksCheck = document.getElementById(`blanks-check-${fieldId}`);
                        if (blanksCheck) {
                            const originalBlanks = (originalText.match(/_{3,}/g) || []).length;
                            const translatedBlanks = (translatedText.match(/_{3,}/g) || []).length + 
                                                     (field.querySelectorAll('.blank-slot').length || 0);
                            blanksCheck.classList.toggle('valid', originalBlanks === translatedBlanks);
                            blanksCheck.classList.toggle('invalid', originalBlanks !== translatedBlanks);
                        }
                    } catch (error) {
                        console.error('Update quality indicators error:', error);
                    }
                },
                
                updateAllWordCounts() {
                    try {
                        document.querySelectorAll('[id^="field-"]').forEach(field => {
                            if (field.contentEditable === 'true') {
                                const fieldId = field.id;
                                this.updateWordCount(fieldId);
                            }
                        });
                    } catch (error) {
                        console.error('Update all word counts error:', error);
                    }
                },
                
                updateWordCount(fieldId) {
                    try {
                        const field = document.getElementById(fieldId);
                        if (!field) return;
                        
                        const text = field.textContent || '';
                        const words = text.trim().split(/\s+/).filter(Boolean).length;
                        const chars = text.length;
                        
                        const wordCountEl = document.getElementById(`wordCount-${fieldId}`);
                        const charCountEl = document.getElementById(`charCount-${fieldId}`);
                        
                        if (wordCountEl) wordCountEl.textContent = words;
                        if (charCountEl) charCountEl.textContent = chars;
                    } catch (error) {
                        console.error('Update word count error:', error);
                    }
                },
                
                getOriginalTextByPath(fileIndex, path) {
                    try {
                        let data = TranslatorApp.state.originalJsonData[fileIndex]?.data;
                        const keys = path.split('.');
                        for (let key of keys) {
                            data = data?.[key];
                        }
                        return data || '';
                    } catch (error) {
                        return '';
                    }
                },
                
                validateAllFields() {
                    try {
                        let totalWarnings = 0;
                        document.querySelectorAll('[id^="field-"]').forEach(field => {
                            if (field.contentEditable === 'true') {
                                const fieldId = field.id;
                                const fileIndex = parseInt(field.dataset.fileIndex);
                                const path = field.dataset.path;
                                
                                this.updateQualityIndicators(fieldId, fileIndex, path);
                                this.updateWordCount(fieldId);
                                
                                const warnings = field.closest('.border').querySelectorAll('.quality-badge.invalid').length;
                                if (warnings > 0) {
                                    field.closest('.border').classList.add('field-warning');
                                    totalWarnings++;
                                }
                            }
                        });
                        
                        this.updateStats();
                        TranslatorApp.ui.showAlert(`Ø§Ù„ØªØ­Ù‚Ù‚ Ù…ÙƒØªÙ…Ù„ - ${totalWarnings} ØªØ­Ø°ÙŠØ±`, totalWarnings > 0 ? 'warning' : 'success');
                    } catch (error) {
                        console.error('Validate all fields error:', error);
                    }
                },
                
                applyFilters() {
                    try {
                        const typeFilter = this.dom.filterByType?.value || 'all';
                        const statusFilter = this.dom.filterByStatus?.value || 'all';
                        const sortBy = this.dom.sortBy?.value || 'default';
                        
                        // Apply filters logic here
                        // This is a placeholder - full implementation would filter based on part.type and status
                        
                        TranslatorApp.ui.showAlert('ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ±', 'info', 2000);
                    } catch (error) {
                        console.error('Apply filters error:', error);
                    }
                },
                
                checkAndAlert(fieldId, fileIndex, path) {
                    try {
                        const field = document.getElementById(fieldId);
                        if (!field) return;
                        
                        const translatedText = field.textContent || '';
                        const originalText = this.getOriginalTextByPath(fileIndex, path);
                        
                        const alerts = [];
                        
                        // Check if field is empty
                        if (!translatedText.trim()) {
                            alerts.push('âš ï¸ Ø§Ù„Ø­Ù‚Ù„ ÙØ§Ø±Øº');
                        }
                        
                        // Check numbers mismatch
                        const numbersCheck = TranslatorApp.quality.qa.checkNumbers(originalText, translatedText);
                        if (numbersCheck.length > 0) {
                            alerts.push('ğŸ”¢ Ø§Ø®ØªÙ„Ø§Ù ÙÙŠ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…');
                        }
                        
                        // Check missing blanks
                        const originalBlanks = (originalText.match(/_{3,}/g) || []).length;
                        const translatedBlanks = (translatedText.match(/_{3,}/g) || []).length + 
                                                 (field.querySelectorAll('.blank-slot').length || 0);
                        if (originalBlanks !== translatedBlanks) {
                            alerts.push(`__ ÙØ±Ø§ØºØ§Øª Ù†Ø§Ù‚ØµØ© (${translatedBlanks}/${originalBlanks})`);
                        }
                        
                        // Check HTML balance
                        const htmlErrors = TranslatorApp.quality.qa.checkHtmlBalance(translatedText);
                        if (htmlErrors.length > 0) {
                            alerts.push('ğŸ·ï¸ HTML ØºÙŠØ± Ù…ØªÙˆØ§Ø²Ù†');
                        }
                        
                        // Check LaTeX errors
                        if (translatedText.includes('\\alt{') || translatedText.includes('\\prime')) {
                            alerts.push('ğŸ“ LaTeX Ø®Ø§Ø·Ø¦ (Ù†Øµ Ø¹Ø±Ø¨ÙŠ)');
                        }
                        
                        // Apply visual indicators
                        const fieldWrapper = field.closest('.border');
                        if (alerts.length > 0) {
                            fieldWrapper?.classList.add('field-error');
                            // Show subtle notification
                            console.warn(`Field ${fieldId}:`, alerts.join(', '));
                        } else {
                            fieldWrapper?.classList.remove('field-error', 'field-warning');
                            fieldWrapper?.classList.add('field-success');
                        }
                        
                    } catch (error) {
                        console.error('Check and alert error:', error);
                    }
                },
                renderReadOnlyField(label, originalValue, translatedValue) {
                    try {
                        if (originalValue === undefined || originalValue === null) return '';
                        const displayOriginalValue = Array.isArray(originalValue) ? originalValue.join(', ') : String(originalValue);
                        const displayTranslatedValue = Array.isArray(translatedValue) ? translatedValue.join(', ') : String(translatedValue);
                        
                        // This is a new check for numeric values to determine direction, but it's not applied correctly.
                        // const isNumeric = !isNaN(parseFloat(displayOriginalValue)) && isFinite(displayOriginalValue);
                        // const dirAttr = isNumeric ? 'ltr' : 'rtl'; 
                        
                        // Let's assume the original values are always English and force LTR for them.
                        const originalDir = 'ltr'; 
                
                        const enhancedOriginal = TranslatorApp.utils.textDirection.enhancePreviewContent(displayOriginalValue);
                        const enhancedTranslated = TranslatorApp.utils.textDirection.enhancePreviewContent(displayTranslatedValue);
                
                        return `
                            <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                                <h5 class="font-bold flex items-center mb-2">${TranslatorApp.security.sanitize(label)}</h5>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ø§Ù„Ø£ØµÙ„ÙŠ</p>
                                        <div class="p-3 rounded-lg text-sm h-full" dir="${originalDir}" style="background-color: var(--bg-color); color: var(--secondary-text);">${enhancedOriginal}</div>
                                    </div>
                                    <div>
                                        <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">Ø§Ù„Ù…ØªØ±Ø¬Ù… (Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„)</p>
                                        <div class="p-3 rounded-lg text-sm h-full" dir="rtl" style="background-color: var(--bg-color); color: var(--secondary-text);">${enhancedTranslated}</div>
                                    </div>
                                </div>
                            </div>`;
                    } catch (error) {
                        console.error('Render read only field error:', error);
                        return `
                        <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                            <h5 class="font-bold flex items-center mb-2">Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶</h5>
                            <div class="p-3 rounded-lg text-sm" style="background-color: var(--bg-color); color: var(--error-color);">ÙØ´Ù„ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­ØªÙˆÙ‰</div>
                        </div>`;
                    }
                },
                renderInputField(label, originalValue, translatedValue, originalUnit, translatedUnit, path, fileIndex) {
                    if (originalValue === undefined || originalValue === null) return '';
                
                    const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                    const statusId = `status-${fieldId}`;
                
                    // Get the translated unit from the new map
                    const translatedUnitText = TranslatorApp.quality.unitsMap[originalUnit.toLowerCase()] || originalUnit;
                
                    return `
                        <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                            <div class="flex justify-between items-center mb-2">
                                <h5 class="font-bold flex items-center">${TranslatorApp.security.sanitize(label)} <span id="${statusId}" class="status-dot status-translated" title="ØªÙ…Øª Ø§Ù„ØªØ±Ø¬Ù…Ø©"></span></h5>
                                <div class="flex gap-2">
                                    <button class="text-xs font-semibold py-1 px-2 rounded" onclick="TranslatorApp.preview.copyOriginalText(this)">Ù†Ø³Ø® Ø§Ù„Ø£ØµÙ„ÙŠ</button>
                                    <button class="text-xs font-semibold py-1 px-2 rounded" onclick="document.getElementById('diff-field-${fileIndex}-${path.replace(/\./g, '-')}').parentNode.classList.toggle('hidden')">Ø¹Ø±Ø¶/Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª</button>
                                </div>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ø§Ù„Ø£ØµÙ„ÙŠ</p>
                                    <div class="original-text-readonly p-3 rounded-lg text-sm h-full flex items-center justify-end" dir="rtl" style="background-color: var(--bg-color); color: var(--secondary-text); overflow:auto;">
                                        <span style="font-family: monospace;">${TranslatorApp.security.sanitize(originalValue)}</span>
                                        <span class="mr-2">${TranslatorApp.security.sanitize(originalUnit)}</span>
                                    </div>
                                </div>
                                <div>
                                    <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">Ø§Ù„Ù…ØªØ±Ø¬Ù… (Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„)</p>
                                    <div id="${fieldId}" 
                                        class="editable-preview-field flex items-center justify-end"
                                        data-path="${path}"
                                        data-file-index="${fileIndex}"
                                        dir="rtl">
                                        <span contenteditable="true" dir="ltr" class="flex-grow text-right">${TranslatorApp.security.sanitize(translatedValue)}</span>
                                        <span contenteditable="true" dir="rtl" class="flex-shrink-0 mr-2 editable-unit">${TranslatorApp.security.sanitize(translatedUnitText)}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-4 hidden">
                                <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª (Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ù…Ù‚Ø§Ø¨Ù„ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©)</p>
                                <div id="diff-field-${fileIndex}-${path.replace(/\./g, '-')}" class="diff-view"></div>
                            </div>
                        </div>
                    `;
                },
                        
                renderReadOnlyLTRField(label, value) {
                    if (value === undefined || value === null) return '';
                    const displayValue = Array.isArray(value) ? value.join(', ') : String(value);
                
                    return `
                    <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                        <h5 class="font-bold flex items-center mb-2">${TranslatorApp.security.sanitize(label)}</h5>
                        <div>
                            <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ø§Ù„Ø£ØµÙ„ÙŠ</p>
                            <div class="p-3 rounded-lg text-sm h-full" dir="ltr" style="background-color: var(--bg-color); color: var(--secondary-text);">${TranslatorApp.security.sanitize(displayValue)}</div>
                        </div>
                    </div>`;
                },

                renderFileContent(data, fileIndex, mappedId) {
                    try {
                        let html = '<div class="space-y-6">';
                
                        const originalId = TranslatorApp.state.originalJsonData[fileIndex]?.data?.id;
                
                        // Display both original and mapped IDs with labels
                        if (originalId) {
                            html += `<div class="p-4 bg-gray-100 rounded-lg shadow-inner mb-4 flex items-center justify-between">
                                <div class="flex items-center text-sm font-semibold" style="color: var(--text-color);">
                                    <span class="ml-2">original_id:</span> <span dir="ltr" style="font-family: monospace;">${originalId}</span>
                                </div>`;
                            
                            // Show mapped_id if it exists
                            if (mappedId) {
                                html += `
                                <div class="flex items-center text-sm font-semibold" style="color: var(--text-color);">
                                    <span class="ml-2">mapped_id:</span> <span dir="ltr" style="font-family: monospace;">${mappedId}</span>
                                </div>`;
                            }
                            html += `</div>`;
                        }
                
                        const renderField = (label, originalValue, translatedValue, path, editableDir = 'rtl') => {
                            try {
                                if (originalValue === undefined || originalValue === null || (Array.isArray(originalValue) && originalValue.length === 0)) {
                                    return '';
                                }
                                const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                                const diffId = `diff-${fieldId}`;
                                const statusId = `status-${fieldId}`;
                                
                                const displayOriginalValue = (Array.isArray(originalValue) ? originalValue.join('') : String(originalValue));
                                const displayTranslatedValue = (Array.isArray(translatedValue) ? translatedValue.join('') : String(translatedValue));
                                
                                const finalTranslatedValue = displayTranslatedValue || displayOriginalValue;
                                
                                return `
                                    <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                                        <div class="flex justify-between items-center mb-2">
                                            <h5 class="font-bold flex items-center">${TranslatorApp.security.sanitize(label)} <span id="${statusId}" class="status-dot status-translated" title="ØªÙ…Øª Ø§Ù„ØªØ±Ø¬Ù…Ø©"></span></h5>
                                            <div class="flex gap-2">
                                                <button class="text-xs font-semibold py-1 px-2 rounded" onclick="TranslatorApp.preview.copyOriginalText(this)">Ù†Ø³Ø® Ø§Ù„Ø£ØµÙ„ÙŠ</button>
                                                <button class="text-xs font-semibold py-1 px-2 rounded" onclick="document.getElementById('${diffId}').parentNode.classList.toggle('hidden')">Ø¹Ø±Ø¶/Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª</button>
                                            </div>
                                        </div>
                                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                            <div>
                                                <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ø§Ù„Ø£ØµÙ„ÙŠ</p>
                                                <div class="original-text-readonly p-3 rounded-lg text-sm h-full" style="background-color: var(--bg-color); overflow:auto;">
                                                    <div dir="ltr">${this.renderContentWithMath(displayOriginalValue)}</div>
                                                </div>
                                            </div>
                                            <div>
                                                <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">Ø§Ù„Ù…ØªØ±Ø¬Ù… (Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„)</p>
                                                <div id="${fieldId}" 
                                                     contenteditable="true"
                                                     class="editable-preview-field"
                                                     data-path="${path}"
                                                     data-file-index="${fileIndex}"
                                                     dir="${editableDir}"
                                                     style="unicode-bidi: embed;">
                                                     ${this.renderContentWithMath(finalTranslatedValue)}
                                                </div>
                                            </div>
                                        </div>
                                        <!-- Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙƒÙ„Ù…Ø§Øª ÙˆÙ…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø¬ÙˆØ¯Ø© -->
                                        <div class="flex justify-between items-center mt-3 pt-3 border-t" style="border-color: var(--card-border);">
                                            <div class="flex gap-3 text-xs" style="color: var(--secondary-text);">
                                                <span>Ø§Ù„ÙƒÙ„Ù…Ø§Øª: <span class="font-bold" id="wordCount-${fieldId}">-</span></span>
                                                <span>Ø§Ù„Ø£Ø­Ø±Ù: <span class="font-bold" id="charCount-${fieldId}">-</span></span>
                                            </div>
                                            <div class="flex gap-1" id="quality-indicators-${fieldId}">
                                                <span class="quality-badge" id="numbers-check-${fieldId}" title="ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…">ğŸ”¢</span>
                                                <span class="quality-badge" id="html-check-${fieldId}" title="ØªÙˆØ§Ø²Ù† HTML">ğŸ·ï¸</span>
                                                <span class="quality-badge" id="latex-check-${fieldId}" title="ØµØ­Ø© LaTeX">ğŸ“</span>
                                                <span class="quality-badge" id="blanks-check-${fieldId}" title="Blanks Ø³Ù„ÙŠÙ…Ø©">__</span>
                                            </div>
                                        </div>
                                        
                                        <!-- Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ø³Ø±ÙŠØ¹Ø© -->
                                        <div class="flex gap-1 mt-2">
                                            <button class="action-btn" title="Ù†Ø³Ø® Ø§Ù„ØªØ±Ø¬Ù…Ø©" onclick="TranslatorApp.preview.copyTranslation('${fieldId}')">ğŸ“‹</button>
                                            <button class="action-btn" title="Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¢Ù„ÙŠØ©" onclick="TranslatorApp.preview.restoreAI('${fieldId}', '${path}', ${fileIndex})">ğŸ¤–</button>
                                            <button class="action-btn" title="Ø¥Ø¶Ø§ÙØ© Ù…Ù„Ø§Ø­Ø¸Ø©" onclick="TranslatorApp.preview.toggleNotes('${fieldId}')">ğŸ“</button>
                                        </div>
                                        
                                        <!-- Ù‚Ø³Ù… Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª -->
                                        <div id="notes-${fieldId}" class="hidden mt-2">
                                            <textarea class="w-full text-xs p-2 border rounded" 
                                                      placeholder="Ø§ÙƒØªØ¨ Ù…Ù„Ø§Ø­Ø¸Ø§ØªÙƒ Ù‡Ù†Ø§..." 
                                                      rows="2"
                                                      onchange="TranslatorApp.preview.saveNote('${fieldId}', this.value)"></textarea>
                                        </div>
                                        
                                        <div class="mt-4 hidden">
                                             <p class="text-sm font-semibold mb-1" style="color: var (--secondary-text);">Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª (Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ù…Ù‚Ø§Ø¨Ù„ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©)</p>
                                            <div id="${diffId}" class="diff-view"></div>
                                        </div>
                                    </div>`;
                            } catch (fieldError) {
                                console.warn('Error rendering field:', fieldError);
                                return '';
                            }
                        };
                
                        html += renderField('Ø§Ù„Ø¨ÙŠØ§Ù† (Statement)', TranslatorApp.state.originalJsonData[fileIndex].data.statement, data.statement, 'statement');
                
                        data.parts?.forEach((part, partIndex) => {
                            try {
                                const originalPart = TranslatorApp.state.originalJsonData[fileIndex].data.parts[partIndex];
                                if (!originalPart) return;
                
                                html += '<div class="border-t pt-4 mt-4 space-y-4" style="border-color: var(--card-border);">';
                                html += `<h5 class="font-semibold text-md" style="color: var(--secondary-text);">Ø§Ù„Ø¬Ø²Ø¡ ${partIndex + 1} (Ø§Ù„Ù†ÙˆØ¹: ${part.type || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'})</h5>`;
                
                                // Check if stem exists and is not empty
                                if (originalPart.stem && originalPart.stem.trim()) {
                                    html += renderField('Ø§Ù„Ø³Ø¤Ø§Ù„ (Stem)', originalPart.stem, part.stem, `parts.${partIndex}.stem`);
                                } else {
                                    html += `<div class="border rounded-lg p-4 bg-yellow-50" style="border-color: #f59e0b;">
                                        <p class="text-sm font-semibold text-yellow-700">âš ï¸ ØªØ­Ø°ÙŠØ±: Ø§Ù„Ø³Ø¤Ø§Ù„ (Stem) ÙØ§Ø±Øº ÙÙŠ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø£ØµÙ„ÙŠ</p>
                                    </div>`;
                                }
                
                                if (originalPart.answer) {
                                    if (part.type === 'input_box' && typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('value')) {
                                        const originalValue = originalPart.answer.value;
                                        const originalUnit = originalPart.answer.unit || '';
                                        const translatedValue = part.answer.value;
                                        const translatedUnit = part.answer.unit || '';
                                        html += this.renderInputField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer)', originalValue, translatedValue, originalUnit, translatedUnit, `parts.${partIndex}.answer.value`, fileIndex);
                                    } else if (Array.isArray(originalPart.answer)) {
                                        html += renderField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer)', originalPart.answer, part.answer, `parts.${partIndex}.answer`);
                                    } else if (typeof originalPart.answer === 'string') {
                                        html += renderField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer)', originalPart.answer, part.answer, `parts.${partIndex}.answer`);
                                    } else if (typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('value')) {
                                        const originalValue = originalPart.answer.value;
                                        const translatedValue = (part.answer && part.answer.value) || originalPart.answer.value;
                                        html += renderField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer)', originalValue, translatedValue, `parts.${partIndex}.answer.value`);
                                    } else {
                                        html += this.renderReadOnlyField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer - ØºÙŠØ± Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ±Ø¬Ù…Ø©)', JSON.stringify(originalPart.answer));
                                    }
                                }
                
                                // Add choices section header for better organization
                                if (part.choices && part.choices.length > 0) {
                                    html += '<div class="mt-4 mb-2"><h6 class="font-semibold text-sm" style="color: var(--secondary-text);">Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª (Choices):</h6></div>';
                                }
                                
                                part.choices?.forEach((choice, choiceIndex) => {
                                    const originalChoice = originalPart.choices[choiceIndex];
                                    const isCorrect = choice.is_correct || false;
                                    const correctBadge = isCorrect ? ' <span style="background-color: #10b981; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: bold;">âœ“ ØµØ­ÙŠØ­</span>' : '';
                                    // Use 'auto' for choices to respect math-field LTR while keeping text RTL
                                    html += renderField(`Ø®ÙŠØ§Ø± ${choiceIndex + 1}${correctBadge}`, originalChoice.html_content, choice.html_content, `parts.${partIndex}.choices.${choiceIndex}.html_content`, 'auto');
                                });
                
                                if (originalPart.gap_text_keys) {
                                    const sortedOriginalKeys = [...originalPart.gap_text_keys].sort((a, b) => a.correct_order - b.correct_order);
                                    const translatedPart = data.parts[partIndex];
                                    const sortedTranslatedKeys = [...(translatedPart.gap_text_keys || [])].sort((a, b) => a.correct_order - b.correct_order);
                
                                    sortedOriginalKeys.forEach((originalKeyItem, index) => {
                                        const translatedKeyItem = sortedTranslatedKeys[index] || { value: '' };
                                        const path = `parts.${partIndex}.gap_text_keys.${originalPart.gap_text_keys.findIndex(item => item.value === originalKeyItem.value)}.value`;
                
                                        html += `<div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                                            <div class="flex justify-between items-center mb-2">
                                                <h5 class="font-bold flex items-center">ÙƒÙ„Ù…Ø© Ø§Ù„ÙØ±Ø§Øº ${originalKeyItem.correct_order}</h5>
                                            </div>
                                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                                <div>
                                                    <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ø§Ù„Ø£ØµÙ„ÙŠ</p>
                                                    <div class="p-3 rounded-lg text-sm h-full" dir="ltr" style="background-color: var(--bg-color); color: var(--secondary-text);">${TranslatorApp.security.sanitize(originalKeyItem.value)}</div>
                                                </div>
                                                <div>
                                                    <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">Ø§Ù„Ù…ØªØ±Ø¬Ù… (Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„)</p>
                                                    <div id="field-${fileIndex}-${path.replace(/\./g, '-')}"
                                                        contenteditable="true"
                                                        class="editable-preview-field"
                                                        data-path="${path}"
                                                        data-file-index="${fileIndex}"
                                                        dir="rtl">
                                                        ${TranslatorApp.security.sanitize(translatedKeyItem.value)}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>`;
                                    });
                                }
                                
                                // Add ai.guidelines section for string type questions
                                if (originalPart.ai && originalPart.ai.guidelines && Array.isArray(originalPart.ai.guidelines) && originalPart.ai.guidelines.length > 0) {
                                    html += '<div class="mt-4 mb-2"><h6 class="font-semibold text-sm" style="color: var(--secondary-text);">Ø¥Ø±Ø´Ø§Ø¯Ø§Øª Ø§Ù„ØªØµØ­ÙŠØ­ (AI Guidelines):</h6></div>';
                                    
                                    originalPart.ai.guidelines.forEach((originalGuideline, guidelineIndex) => {
                                        const translatedGuideline = part.ai?.guidelines?.[guidelineIndex] || {};
                                        
                                        html += `<div class="border rounded-lg p-4 mb-3" style="border-color: var(--card-border); background-color: rgba(59, 130, 246, 0.05);">
                                            <div class="mb-2">
                                                <span class="text-xs font-semibold px-2 py-1 rounded" style="background-color: #3b82f6; color: white;">Ø¥Ø±Ø´Ø§Ø¯ ${guidelineIndex + 1}</span>
                                                ${originalGuideline.mark ? `<span class="text-xs font-semibold px-2 py-1 rounded ml-2" style="background-color: #10b981; color: white;">Ø§Ù„Ø¹Ù„Ø§Ù…Ø©: ${originalGuideline.mark}</span>` : ''}
                                            </div>`;
                                        
                                        // Render student_answer
                                        if (originalGuideline.student_answer && typeof originalGuideline.student_answer === 'string') {
                                            html += renderField('Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ (Student Answer)', 
                                                originalGuideline.student_answer, 
                                                translatedGuideline.student_answer || originalGuideline.student_answer, 
                                                `parts.${partIndex}.ai.guidelines.${guidelineIndex}.student_answer`);
                                        }
                                        
                                        // Render comment
                                        if (originalGuideline.comment && typeof originalGuideline.comment === 'string') {
                                            html += renderField('Ø§Ù„ØªØ¹Ù„ÙŠÙ‚ (Comment)', 
                                                originalGuideline.comment, 
                                                translatedGuideline.comment || originalGuideline.comment, 
                                                `parts.${partIndex}.ai.guidelines.${guidelineIndex}.comment`);
                                        }
                                        
                                        html += '</div>';
                                    });
                                }
                
                                html += '</div>';
                            } catch (partError) {
                                console.warn('Error rendering part:', partError);
                                html += '<div class="border-t pt-4 mt-4 space-y-4" style="border-color: var(--card-border);">';
                                html += `<h5 class="font-semibold text-md" style="color: var(--error-color);">Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø²Ø¡ ${partIndex + 1}</h5>`;
                                html += '</div>';
                            }
                        });
                
                        html += '</div>';
                        return html;
                    } catch (error) {
                        console.error('Render file content error:', error);
                        return '<div class="space-y-6"><div class="border rounded-lg p-4" style="border-color: var(--card-border);"><h5 class="font-bold flex items-center mb-2" style="color: var(--error-color);">Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­ØªÙˆÙ‰</h5><div class="p-3 rounded-lg text-sm" style="background-color: var(--bg-color); color: var(--error-color);">ÙØ´Ù„ ÙÙŠ Ø¹Ø±Ø¶ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù„Ù</div></div></div>';
                    }
                },
                updateData(fileIndex, path, value) {
                    try {
                        const keys = path.split('.');
                        let current = TranslatorApp.state.translatedJsonData[fileIndex].data;
                        const original = TranslatorApp.state.originalJsonData[fileIndex].data; // Keep original for reference
                        for (let i = 0; i < keys.length - 1; i++) {
                            current = current[keys[i]];
                        }
                        const lastKey = keys[keys.length - 1];
                
                        // Correctly handle the case for gap_text_keys
                        if (keys[keys.length - 2] === 'gap_text_keys') {
                            const keyIndex = parseInt(keys[keys.length - 1], 10);
                            if (current.gap_text_keys && current.gap_text_keys[keyIndex]) {
                                current.gap_text_keys[keyIndex].value = value;
                            }
                        } 
                        // Handle ai.guidelines paths (e.g., parts.0.ai.guidelines.0.student_answer)
                        else if (keys.includes('guidelines') && keys[keys.length - 2] && !isNaN(keys[keys.length - 2])) {
                            const guidelineIndex = parseInt(keys[keys.length - 2], 10);
                            const fieldName = keys[keys.length - 1]; // 'student_answer' or 'comment'
                            
                            // Navigate to the guidelines array
                            let guidelinesParent = TranslatorApp.state.translatedJsonData[fileIndex].data;
                            for (let i = 0; i < keys.length - 2; i++) {
                                guidelinesParent = guidelinesParent[keys[i]];
                            }
                            
                            if (guidelinesParent && guidelinesParent[guidelineIndex]) {
                                guidelinesParent[guidelineIndex][fieldName] = value;
                            }
                        } 
                        else {
                            // Otherwise, set the value directly
                            current[lastKey] = value;
                        }
                
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('Update data error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.', 'error');
                    }
                },

                generateInitialDiffs(fileIndex) {
                    try {
                        const originalData = TranslatorApp.state.originalJsonData[fileIndex].data;
                        const processPath = (path) => {
                            try {
                                if (originalData === undefined || originalData === null) return;
                                this.updateDiff(fileIndex, path);
                            } catch (error) {
                                console.warn(`Error processing path ${path}:`, error);
                            }
                        };
                        processPath('statement');
                        originalData.parts?.forEach((part, partIndex) => {
                            processPath(`parts.${partIndex}.stem`);
                            if (typeof part.answer === 'string') processPath(`parts.${partIndex}.answer`);
                            part.choices?.forEach((choice, choiceIndex) => {
                                processPath(`parts.${partIndex}.choices.${choiceIndex}.html_content`);
                            });
                            part.gap_text_keys?.forEach((keyItem, keyIndex) => {
                                processPath(`parts.${partIndex}.gap_text_keys.${keyIndex}.value`);
                            });
                            // Process ai.guidelines
                            part.ai?.guidelines?.forEach((guideline, guidelineIndex) => {
                                if (guideline.student_answer) processPath(`parts.${partIndex}.ai.guidelines.${guidelineIndex}.student_answer`);
                                if (guideline.comment) processPath(`parts.${partIndex}.ai.guidelines.${guidelineIndex}.comment`);
                            });
                        });
                    } catch (error) {
                        console.error('Generate initial diffs error:', error);
                    }
                },

                updateDiff(fileIndex, path) {
                    try {
                        const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                        const diffId = `diff-${fieldId}`;
                        const diffContainer = document.getElementById(diffId);
                        if (!diffContainer) return;

                        const keys = path.split('.');
                        // Compare initial translation with current translation (both in Arabic)
                        let initialText = TranslatorApp.state.initialTranslatedJsonData[fileIndex]?.data;
                        let currentText = TranslatorApp.state.translatedJsonData[fileIndex].data;
                        
                        for (let i = 0; i < keys.length; i++) {
                            initialText = initialText ? initialText[keys[i]] : '';
                            currentText = currentText ? currentText[keys[i]] : '';
                        }

                        const cleanInitial = this.plainTextForDiff(initialText || '');
                        const cleanCurrent = this.plainTextForDiff(currentText || '');

                        diffContainer.innerHTML = this.createDiffHtml(cleanInitial, cleanCurrent);
                    } catch (error) {
                        console.error('Update diff error:', error);
                    }
                },

                prepareInteractiveMathFields() {
                    try {
                        const mathFields = TranslatorApp.dom.previewContainer.querySelectorAll('math-field');
                        mathFields.forEach(mf => {
                            try {
                                // Check if this math-field is in an editable area
                                const isInEditableArea = mf.closest('.editable-preview-field');
                                const isInOriginal = mf.closest('.original-text-readonly');
                                
                                // Only remove read-only from editable areas
                                if (isInEditableArea) {
                                    mf.removeAttribute('read-only');
                                } else if (isInOriginal) {
                                    // Keep read-only for original text
                                    mf.setAttribute('read-only', 'true');
                                }
                                
                                mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                mf.setAttribute('use-shared-virtual-keyboard', '');
                                
                                // Add delete button only for editable math-fields
                                if (isInEditableArea && !mf.querySelector('.math-field-delete-btn')) {
                                    const deleteBtn = document.createElement('button');
                                    deleteBtn.className = 'math-field-delete-btn';
                                    deleteBtn.textContent = 'Ã—';
                                    deleteBtn.title = 'Ø­Ø°Ù Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©';
                                    deleteBtn.onclick = (event) => {
                                        event.stopPropagation();
                                        event.preventDefault();
                                        const fieldContainer = mf.closest('.editable-preview-field');
                                        mf.remove();
                                        if (fieldContainer) {
                                            TranslatorApp.preview.handlePreviewFieldUpdate(fieldContainer);
                                        }
                                    };
                                    mf.appendChild(deleteBtn);
                                }
                                
                                // Add copy button for original math-fields
                                if (isInOriginal && !mf.querySelector('.math-field-copy-btn')) {
                                    const copyBtn = document.createElement('button');
                                    copyBtn.className = 'math-field-copy-btn';
                                    copyBtn.textContent = 'ğŸ“‹';
                                    copyBtn.title = 'Ù†Ø³Ø® Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©';
                                    copyBtn.onclick = (event) => {
                                        event.stopPropagation();
                                        event.preventDefault();
                                        const value = mf.value || '';
                                        navigator.clipboard.writeText(`$${value}$`).then(() => {
                                            TranslatorApp.ui.showAlert('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©', 'success', 1500);
                                        });
                                    };
                                    mf.appendChild(copyBtn);
                                }

                                // Enhanced language support for MathLive
                                mf.setAttribute('virtual-keyboard-layout', 'qwerty');
                                mf.setAttribute('virtual-keyboard-theme', 'material');

                                // Enable Arabic and English input
                                mf.setAttribute('virtual-keyboard-languages', 'ar,en');
                                mf.setAttribute('virtual-keyboard-default-language', 'ar');

                                // Set direction based on content
                                const currentValue = mf.value || '';
                                const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(currentValue);
                                const direction = hasArabic ? 'rtl' : 'ltr';
                                mf.setAttribute('dir', direction);

                                // Add language toggle functionality
                                mf.addEventListener('keydown', (e) => {
                                    try {
                                        // Alt + L to toggle language
                                        if (e.altKey && e.key === 'l') {
                                            e.preventDefault();
                                            const currentLang = mf.getAttribute('virtual-keyboard-default-language');
                                            const newLang = currentLang === 'ar' ? 'en' : 'ar';
                                            mf.setAttribute('virtual-keyboard-default-language', newLang);

                                            // Update direction
                                            mf.setAttribute('dir', newLang === 'ar' ? 'rtl' : 'ltr');

                                            // Show feedback
                                            const langText = newLang === 'ar' ? 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©' : 'English';
                                            TranslatorApp.ui.showAlert(`ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ ${langText}`, 'info', 1500);
                                        }
                                    } catch (langError) {
                                        console.warn('Language toggle error:', langError);
                                    }
                                });

                                mf.addEventListener('focus', () => {
                                    try {
                                        if (typeof mf.executeCommand === 'function') {
                                            setTimeout(() => {
                                                try {
                                                    mf.executeCommand('showVirtualKeyboard');

                                                    // Set initial language based on content
                                                    const value = mf.value || '';
                                                    const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(value);
                                                    if (hasArabic) {
                                                        mf.setAttribute('virtual-keyboard-default-language', 'ar');
                                                        mf.setAttribute('dir', 'rtl');
                                                    } else {
                                                        mf.setAttribute('virtual-keyboard-default-language', 'en');
                                                        mf.setAttribute('dir', 'ltr');
                                                    }
                                                } catch (keyboardError) {
                                                    console.warn('MathLive keyboard error:', keyboardError);
                                                }
                                            }, 100);
                                        }
                                    } catch (focusError) {
                                        console.warn('MathLive focus error:', focusError);
                                    }
                                }, { once: false });

                                // Add input event to detect language changes
                                mf.addEventListener('input', (e) => {
                                    try {
                                        const value = e.target.value || '';
                                        const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(value);
                                        const hasEnglish = /[a-zA-Z]/.test(value);

                                        // Auto-switch language based on input
                                        if (hasArabic && !hasEnglish) {
                                            mf.setAttribute('virtual-keyboard-default-language', 'ar');
                                            mf.setAttribute('dir', 'rtl');
                                        } else if (hasEnglish && !hasArabic) {
                                            mf.setAttribute('virtual-keyboard-default-language', 'en');
                                            mf.setAttribute('dir', 'ltr');
                                        }
                                        // For mixed content, keep current setting
                                    } catch (inputError) {
                                        console.warn('MathLive input error:', inputError);
                                    }
                                });

                            } catch (fieldError) {
                                console.warn('MathLive field setup error:', fieldError);
                            }
                        });
                    } catch (generalError) {
                        console.warn('MathLive general setup error:', generalError);
                    }
                },

                createDiffHtml(text1, text2) {
                    try {
                        const d = this.dmp.diff_main(text1, text2);
                        this.dmp.diff_cleanupSemantic(d);
                        return this.dmp.diff_prettyHtml(d);
                    } catch (error) {
                        console.error('Create diff HTML error:', error);
                        return `<div style="color: var (--error-color);">ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª</div>`;
                    }
                },

                plainTextForDiff(html) {
                    try {
                        const div = document.createElement('div');
                        div.innerHTML = html || '';
                        return div.textContent || div.innerText || '';
                    } catch (error) {
                        console.error('Plain text for diff error:', error);
                        return '';
                    }
                },

                // Helper functions for new features
                copyTranslation(fieldId) {
                    try {
                        const field = document.getElementById(fieldId);
                        if (field) {
                            const text = field.textContent || '';
                            navigator.clipboard.writeText(text).then(() => {
                                TranslatorApp.ui.showAlert('ØªÙ… Ù†Ø³Ø® Ø§Ù„ØªØ±Ø¬Ù…Ø©', 'success', 2000);
                            });
                        }
                    } catch (error) {
                        console.error('Copy translation error:', error);
                    }
                },
                
                restoreAI(fieldId, path, fileIndex) {
                    try {
                        const initialData = TranslatorApp.state.initialTranslatedJsonData[fileIndex];
                        if (!initialData) {
                            TranslatorApp.ui.showAlert('Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ±Ø¬Ù…Ø© Ø¢Ù„ÙŠØ© Ù…Ø­ÙÙˆØ¸Ø©', 'info', 3000);
                            return;
                        }
                        
                        const field = document.getElementById(fieldId);
                        if (field) {
                            // Get initial translation from saved data
                            let data = initialData.data;
                            const keys = path.split('.');
                            for (let key of keys) {
                                data = data[key];
                            }
                            field.innerHTML = TranslatorApp.preview.renderContentWithMath(data);
                            TranslatorApp.preview.handlePreviewFieldUpdate(field);
                            TranslatorApp.ui.showAlert('ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¢Ù„ÙŠØ©', 'success', 2000);
                        }
                    } catch (error) {
                        console.error('Restore AI error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø©', 'error');
                    }
                },
                
                toggleNotes(fieldId) {
                    try {
                        const notesDiv = document.getElementById(`notes-${fieldId}`);
                        if (notesDiv) {
                            notesDiv.classList.toggle('hidden');
                        }
                    } catch (error) {
                        console.error('Toggle notes error:', error);
                    }
                },
                
                saveNote(fieldId, noteText) {
                    try {
                        const notes = JSON.parse(localStorage.getItem('translationNotes') || '{}');
                        notes[fieldId] = noteText;
                        localStorage.setItem('translationNotes', JSON.stringify(notes));
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('Save note error:', error);
                    }
                },
                
                loadNotes() {
                    try {
                        const notes = JSON.parse(localStorage.getItem('translationNotes') || '{}');
                        Object.keys(notes).forEach(fieldId => {
                            const textarea = document.querySelector(`#notes-${fieldId} textarea`);
                            if (textarea) {
                                textarea.value = notes[fieldId];
                            }
                        });
                    } catch (error) {
                        console.error('Load notes error:', error);
                    }
                },

                copyOriginalText(button) {
                    try {
                        const fieldContainer = button.closest('.border').querySelector('.original-text-readonly');
                        if (fieldContainer) {
                            const textToCopy = fieldContainer.innerHTML;
                            const textArea = document.createElement('textarea');
                            textArea.value = textToCopy;

                            textArea.style.position = 'fixed';
                            textArea.style.top = '0';
                            textArea.style.left = '0';
                            textArea.style.width = '2em';
                            textArea.style.height = '2em';
                            textArea.style.padding = '0';
                            textArea.style.border = 'none';
                            textArea.style.outline = 'none';
                            textArea.style.boxShadow = 'none';
                            textArea.style.background = 'transparent';

                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();

                            try {
                                const successful = document.execCommand('copy');
                                if (successful) {
                                    TranslatorApp.ui.showAlert('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ!', 'success', 2000);
                                } else {
                                    TranslatorApp.ui.showAlert('ÙØ´Ù„ Ù†Ø³Ø® Ø§Ù„Ù†Øµ.', 'error', 2000);
                                }
                            } catch (err) {
                                console.error('Fallback: Oops, unable to copy', err);
                                TranslatorApp.ui.showAlert('ÙØ´Ù„ Ù†Ø³Ø® Ø§Ù„Ù†Øµ.', 'error', 2000);
                            }

                            document.body.removeChild(textArea);
                        } else {
                            TranslatorApp.ui.showAlert('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ Ù†Ø³Ø®Ù‡.', 'error', 2000);
                        }
                    } catch (error) {
                        console.error('Copy original text error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ù†Ø³Ø® Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ.', 'error', 2000);
                    }
                },

                filter() {
                    try {
                        const term = TranslatorApp.dom.searchPreview.value.toLowerCase();
                        const accordions = document.querySelectorAll('#previewContainer > div');
                        accordions.forEach(accordion => {
                            try {
                                const content = accordion.textContent.toLowerCase();
                                const isVisible = content.includes(term);
                                accordion.style.display = isVisible ? '' : 'none';
                            } catch (error) {
                                console.warn('Error filtering accordion:', error);
                            }
                        });
                    } catch (error) {
                        console.error('Filter error:', error);
                    }
                }
            },
            export: {
                exportAs(format) {
                    return this.toJson();
                },

                async toJson() {
                    const useMappedIds = TranslatorApp.dom.useMappedIdsCheckbox.checked;
                    let mappedIds = [];
                    let idCounter = 0;
                    
                    if (useMappedIds) {
                        try {
                            mappedIds = JSON.parse(TranslatorApp.dom.mappedIdsInput.value);
                            if (!Array.isArray(mappedIds)) throw new Error('not array');
                        } catch (e) {
                            return TranslatorApp.ui.showAlert('Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª (mapped_id) ØºÙŠØ± ØµØ§Ù„Ø­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†Ù‡Ø§ Ù…ØµÙÙˆÙØ© JSON ØµØ­ÙŠØ­Ø©.', 'error');
                        }
                    }
                    
                    const selectedTranslator = TranslatorApp.state.selectedTranslator;
                    const sourceId = TranslatorApp.state.translators[selectedTranslator];
                    
                    const zip = new JSZip();
                    
                    for (const translatedFile of TranslatorApp.state.translatedJsonData) {
                        const finalData = JSON.parse(JSON.stringify(translatedFile.data));
                        const originalId = TranslatorApp.state.originalJsonData.find(f => f.name === translatedFile.name)?.data?.id;
                    
                        finalData.metadata = finalData.metadata || {};
                        finalData.metadata.title = "";
                        finalData.metadata.language = 'ar';
                        finalData.metadata.dialect = ['modern_standard'];
                        finalData.metadata.country = 'eg';
                    
                        if (sourceId) {
                            finalData.metadata.source_id = {
                                "value": parseInt(sourceId),
                                "page_number": null
                            };
                        } else {
                            finalData.metadata.source_id = null;
                        }
                    
                        const stripHtml = (html) => {
                            if (!html) return "";
                            const doc = new DOMParser().parseFromString(html, 'text/html');
                            return doc.body.textContent || "";
                        };
                    
                        const cleanStatement = stripHtml(finalData.statement);
                        const cleanStem = finalData.parts?.[0]?.stem ? stripHtml(finalData.parts[0].stem) : '';
                        let description = (cleanStatement + ' ' + cleanStem).trim();
                        finalData.metadata.description = description;
                    
                        if (finalData.parts) {
                            finalData.parts.forEach((part) => {
                                if (part.type === 'input_box' && part.answer && part.answer.hasOwnProperty('value')) {
                                    const originalUnit = TranslatorApp.state.originalJsonData
                                        .find(f => f.name === translatedFile.name)?.data.parts
                                        .find(p => p.n === part.n)?.answer.unit || '';
                                    part.answer.unit = TranslatorApp.quality.unitsMap[originalUnit.toLowerCase()] || originalUnit;
                                }
                            });
                        }
                    
                        let fileNameToUse = translatedFile.name;
                        // Assign the mapped ID for both export and display
                        if (useMappedIds && idCounter < mappedIds.length) {
                            const newMappedId = mappedIds[idCounter];
                            finalData.metadata.mapped_id = newMappedId;
                            fileNameToUse = `${newMappedId}.json`;
                            idCounter++;
                        } else {
                            finalData.metadata.mapped_id = originalId; // Fallback to original ID for the mapped_id field
                        }
                    
                        zip.file(fileNameToUse, JSON.stringify(finalData, null, 2));
                    }
                    
                    if (useMappedIds && idCounter < TranslatorApp.state.translatedJsonData.length) {
                        TranslatorApp.ui.showAlert(`ØªØ­Ø°ÙŠØ±: Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª (${idCounter}) Ø£Ù‚Ù„ Ù…Ù† Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù„ÙØ§Øª (${TranslatorApp.state.translatedJsonData.length}).`, 'error');
                    }
                    
                    try {
                        const content = await zip.generateAsync({ type: "blob" });
                        const link = document.createElement("a");
                        link.href = URL.createObjectURL(content);
                        link.download = `translated_questions_${new Date().toISOString().replace(/[:.]/g, '-')}.zip`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                        TranslatorApp.ui.showAlert('ØªÙ… ØªØµØ¯ÙŠØ± Ù…Ù„ÙØ§Øª JSON Ø¨Ù†Ø¬Ø§Ø­!', 'success');
                    } catch (e) {
                        console.error('ZIP creation error:', e);
                        TranslatorApp.ui.showAlert(`ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ZIP: ${e.message}`, 'error');
                    }
                },
                annotator: {
                    canvas: null,
                    fabricCanvas: null,
                    currentImage: null,
                    open() {
                        try {
                            const images = TranslatorApp.dom.previewContainer.querySelectorAll('img');
                            if (!images.length) {
                                TranslatorApp.ui.showAlert('Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ± ÙÙŠ Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©.', 'info');
                                return;
                            }

                            // Use the first image in view for simplicity
                            this.currentImage = images[0];
                            if (!this.currentImage || !this.currentImage.src) {
                                TranslatorApp.ui.showAlert('Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©.', 'error');
                                return;
                            }

                            TranslatorApp.ui.showModal('imageAnnotatorModal', true);
                            setTimeout(() => this.initCanvas(), 0);
                        } catch (error) {
                            console.error('Image annotator open error:', error);
                            TranslatorApp.ui.showAlert(`ÙØ´Ù„ ÙÙŠ ÙØªØ­ Ù…Ø­Ø±Ø± Ø§Ù„ØµÙˆØ±: ${error.message}`, 'error');
                        }
                    },
                    close() {
                        try {
                            // Clean up Fabric.js canvas
                            if (this.fabricCanvas) {
                                this.fabricCanvas.dispose();
                                this.fabricCanvas = null;
                            }
                            this.currentImage = null;
                            TranslatorApp.ui.showModal('imageAnnotatorModal', false);
                        } catch (error) {
                            console.error('Image annotator close error:', error);
                            TranslatorApp.ui.showModal('imageAnnotatorModal', false);
                        }
                    },
                    initCanvas() {
                        try {
                            const canvasEl = TranslatorApp.dom.imageAnnotatorCanvas;
                            const img = this.currentImage;
                            if (!canvasEl || !img) {
                                TranslatorApp.ui.showAlert('Ø¹Ù†Ø§ØµØ± Canvas Ø£Ùˆ Ø§Ù„ØµÙˆØ±Ø© ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©.', 'error');
                                return;
                            }

                            // Set canvas dimensions
                            canvasEl.width = img.naturalWidth || img.width || 800;
                            canvasEl.height = img.naturalHeight || img.height || 600;

                            // Initialize Fabric.js canvas
                            this.fabricCanvas = new fabric.Canvas(canvasEl, { selection: true });

                            // Load image into canvas
                            fabric.Image.fromURL(img.src, (oImg) => {
                                try {
                                    oImg.selectable = false;
                                    oImg.evented = false;
                                    oImg.scaleToWidth(canvasEl.width);
                                    this.fabricCanvas.add(oImg).sendToBack(oImg);
                                } catch (imgError) {
                                    console.error('Image loading error:', imgError);
                                    TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø­Ø±Ø±.', 'error');
                                }
                            }, { crossOrigin: 'anonymous' });

                            // Add helper text tool with RTL support
                            this.fabricCanvas.on('mouse:dblclick', (e) => {
                                try {
                                    const pointer = this.fabricCanvas.getPointer(e.e);
                                    const textbox = new fabric.Textbox('Ù†Øµ', {
                                        left: pointer.x,
                                        top: pointer.y,
                                        fontSize: 24,
                                        fill: '#111827',
                                        backgroundColor: 'rgba(255,255,255,0.7)'
                                    });
                                    this.fabricCanvas.add(textbox).setActiveObject(textbox);
                                } catch (textError) {
                                    console.error('Text tool error:', textError);
                                }
                            });
                        } catch (error) {
                            console.error('Canvas initialization error:', error);
                            TranslatorApp.ui.showAlert(`ÙØ´Ù„ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ù…Ø­Ø±Ø± Ø§Ù„ØµÙˆØ±: ${error.message}`, 'error');
                        }
                    },
                    save() {
                        if (!this.fabricCanvas) {
                            TranslatorApp.ui.showAlert('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø­ØªÙˆÙ‰ Ù„Ù„Ø­ÙØ¸.', 'error');
                            return;
                        }

                        try {
                            const dataUrl = this.fabricCanvas.toDataURL({ format: 'png', quality: 1 });
                            if (!dataUrl || dataUrl === 'data:,') {
                                throw new Error('ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ ØµÙˆØ±Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
                            }

                            // Replace the image in preview with annotated version (non-destructive â€“ just in UI)
                            this.currentImage.src = dataUrl;
                            TranslatorApp.state.hasUnsavedChanges = true;
                            this.close();
                            TranslatorApp.ui.showAlert('ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø© (Ù…Ø­Ù„ÙŠØ§Ù‹).', 'success');
                        } catch (error) {
                            console.error('Image save error:', error);
                            TranslatorApp.ui.showAlert(`ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±Ø©: ${error.message}`, 'error');
                        }
                    }
                }
            },
            
            /**
             * Validate that all required fields are selected before enabling translation
             */
            validateTranslationRequirements() {
                try {
                    const subject = this.state.selectedSubject || this.dom.subjectSelect?.value || 'None';
                    const grade = this.state.selectedGrade || this.dom.gradeSelect?.value || 'None';
                    const translator = this.state.selectedTranslator || this.dom.translatorSelect?.value || '';
                    const hasFiles = this.state.selectedFilesInfo && this.state.selectedFilesInfo.length > 0;
                    
                    // Check if all required fields are filled
                    const isSubjectValid = subject && subject !== 'None';
                    const isGradeValid = grade && grade !== 'None';
                    const isTranslatorValid = translator && translator !== '';
                    const allValid = isSubjectValid && isGradeValid && isTranslatorValid && hasFiles;
                    
                    // Enable or disable the translate button
                    if (this.dom.translateBtn) {
                        this.dom.translateBtn.disabled = !allValid;
                        
                        // Update button appearance
                        if (!allValid) {
                            this.dom.translateBtn.style.opacity = '0.5';
                            this.dom.translateBtn.style.cursor = 'not-allowed';
                            
                            // Show helpful message
                            const missingFields = [];
                            if (!isSubjectValid) missingFields.push('Ø§Ù„Ù…Ø§Ø¯Ø©');
                            if (!isGradeValid) missingFields.push('Ø§Ù„ØµÙ');
                            if (!isTranslatorValid) missingFields.push('Ø§Ø³Ù… Ø§Ù„Ù…ØªØ±Ø¬Ù…');
                            if (!hasFiles) missingFields.push('Ø§Ù„Ù…Ù„ÙØ§Øª');
                            
                            this.dom.translateBtn.title = `ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø±: ${missingFields.join(' Ùˆ ')}`;
                        } else {
                            this.dom.translateBtn.style.opacity = '1';
                            this.dom.translateBtn.style.cursor = 'pointer';
                            this.dom.translateBtn.title = 'Ø§Ø¨Ø¯Ø£ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ±Ø¬Ù…Ø© (Ctrl + Enter)';
                        }
                    }
                    
                    return allValid;
                } catch (error) {
                    console.error('Validate translation requirements error:', error);
                    return false;
                }
            }
        };


        document.addEventListener('DOMContentLoaded', () => TranslatorApp.init());

    </script>



    <script>
        // Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ØªÙ‚ÙˆÙ… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø²Ø± ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ù„ØºØ© ÙˆØ¥Ø¶Ø§ÙØªÙ‡ Ø¥Ù„Ù‰ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
        function addLanguageToggleButton() {
            // Ø§Ø¨Ø­Ø« Ø¹Ù† Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ ÙÙŠ Ø§Ù„ØµÙØ­Ø©
            const keyboard = document.querySelector('.ML__keyboard');

            // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ù…ÙˆØ¬ÙˆØ¯Ø©ØŒ Ø£Ùˆ ÙƒØ§Ù† Ø§Ù„Ø²Ø± Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§ Ø¨Ø§Ù„ÙØ¹Ù„ØŒ Ù„Ø§ ØªÙØ¹Ù„ Ø´ÙŠØ¦Ù‹Ø§
            if (!keyboard || keyboard.querySelector('.lang-toggle-btn')) {
                return;
            }

            // Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù†ØµØ± Ø§Ù„Ø²Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
            const btn = document.createElement('button');

            // Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ Ø³ÙŠØ¸Ù‡Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø±
            btn.textContent = 'Ø¹Ø±Ø¨ÙŠ / EN';

            // ÙƒÙ„Ø§Ø³ CSS Ù„ØªÙ…ÙŠÙŠØ² Ø§Ù„Ø²Ø±
            btn.className = 'lang-toggle-btn';

            // ØªØµÙ…ÙŠÙ… Ø¨Ø³ÙŠØ· Ù„Ù„Ø²Ø± Ù„ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
            btn.style.cssText = `
            position: absolute;
            top: 5px;
            right: 170px; /* ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¶Ø¹ Ù„ÙŠÙƒÙˆÙ† Ù…Ù†Ø§Ø³Ø¨Ù‹Ø§ */
            padding: 5px 10px;
            font-size: 14px;
            font-weight: bold;
            background-color: #555;
            color: white;
            border: 1px solid #777;
            border-radius: 6px;
            cursor: pointer;
            z-index: 100;
        `;

            // Ø¹Ù†Ø¯ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø±ØŒ Ù‚Ù… Ø¨ØªÙ†ÙÙŠØ° Ù†ÙØ³ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„ØªÙŠ ÙƒØ§Ù† Ø§Ù„Ø§Ø®ØªØµØ§Ø± ÙŠÙ†ÙØ°Ù‡Ø§
            btn.onclick = () => TranslatorApp.utils.mathLive.toggleLanguage();

            // Ø£Ø¶Ù Ø§Ù„Ø²Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø¥Ù„Ù‰ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
            keyboard.appendChild(btn);
        }

        // Ø¨Ù…Ø§ Ø£Ù† Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ ØªØ¸Ù‡Ø± ÙˆØªØ®ØªÙÙŠØŒ Ø³Ù†Ù‚ÙˆÙ… Ø¨ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¯Ø§Ù„Ø© Ø¨Ø´ÙƒÙ„ Ø¯ÙˆØ±ÙŠ
        // Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¸Ù‡ÙˆØ±Ù‡Ø§ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø²Ø± ÙƒÙ„ Ù†ØµÙ Ø«Ø§Ù†ÙŠØ©
        setInterval(addLanguageToggleButton, 500);
    </script>
</body>

</html>
