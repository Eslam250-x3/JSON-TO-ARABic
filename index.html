<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>مترجم الأسئلة</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- MathLive for LaTeX editing -->
    <script src="https://unpkg.com/@nagwa-limited/mathlive" defer></script>
    <!-- Fabric.js for simple image annotation/editor -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

    <!-- DOMPurify for security -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>

    <!-- Diff Match Patch for comparing text -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f3f4f6;
            --text-color: #1f2937;
            --card-bg: #ffffff;
            --card-border: #e5e7eb;
            --input-bg: #ffffff;
            --input-border: #d1d5db;
            --primary-color: #4f46e5;
            --primary-hover: #4338ca;
            --secondary-text: #6b7280;
            --success-color: #10b981;
            --error-color: #ef4444;
            --highlight-bg: #fef9c3;
            --diff-ins-bg: #ddfbe9;
            --diff-del-bg: #fce8e9;
        }

        [data-theme="dark"] {
            --bg-color: #111827;
            --text-color: #f9fafb;
            --card-bg: #1f2937;
            --card-border: #374151;
            --input-bg: #374151;
            --input-border: #4b5563;
            --primary-color: #6366f1;
            --primary-hover: #818cf8;
            --secondary-text: #9ca3af;
            --highlight-bg: #4d4318;
            --diff-ins-bg: #133825;
            --diff-del-bg: #411a1d;
        }

        body {
            font-family: 'Cairo', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        .main-card,
        .preview-card {
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        input,
        select,
        textarea {
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
        }

        .dragover {
            border-color: var(--primary-color);
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--bg-color));
        }

        .api-selector input[type="radio"]:checked+label {
            border-color: var(--primary-color);
            background-color: color-mix(in srgb, var(--primary-color) 15%, var(--card-bg));
            color: var(--primary-color);
        }

        .alert {
            transition: all 0.5s ease-in-out;
            opacity: 1;
            transform: translateX(0);
        }

        .alert.fade-out {
            opacity: 0;
            transform: translateX(100%);
        }

        .search-highlight,
        mark.search-highlight {
            background-color: var(--highlight-bg);
            color: var(--text-color);
            border-radius: 3px;
            padding: 0 2px;
        }

        #saveIndicator {
            font-size: 0.85rem;
            color: var(--secondary-text);
        }

        #saveIndicator.saved {
            color: var(--success-color);
        }

        #saveIndicator.error {
            color: var(--error-color);
        }

        /* Accordion Styles */
        .accordion-header {
            width: 100%;
            padding: 1rem 1.5rem;
            text-align: right;
            font-weight: 700;
            font-size: 1.125rem;
            border-radius: 0.75rem;
            background-color: color-mix(in srgb, var(--primary-color) 8%, var(--card-bg));
            transition: background-color 0.2s;
            cursor: pointer;
        }

        .accordion-header:hover {
            background-color: color-mix(in srgb, var(--primary-color) 15%, var(--card-bg));
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-in-out;
            background-color: var(--card-bg);
            border-top: 1px solid var(--card-border);
        }

        .accordion-content.open {
            padding: 1.5rem;
        }

        /* Diff View Styles */
        .diff-view {
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: var(--bg-color);
            border: 1px solid var(--card-border);
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .diff-view ins {
            background-color: var(--diff-ins-bg);
            text-decoration: none;
        }

        .diff-view del {
            background-color: var(--diff-del-bg);
            text-decoration: line-through;
        }

        /* Status Indicator */
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 8px;
        }

        .status-translated {
            background-color: var(--success-color);
        }
        
        /* Field State Colors */
        .field-warning {
            border-right: 4px solid var(--warning-color) !important;
        }
        
        .field-error {
            border-right: 4px solid var(--error-color) !important;
        }
        
        .field-success {
            border-right: 4px solid var(--success-color) !important;
        }
        
        .field-edited {
            background-color: color-mix(in srgb, var(--warning-color) 5%, var(--card-bg)) !important;
        }
        
        /* Quality Badges */
        .quality-badge {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            opacity: 0.3;
            cursor: help;
            transition: all 0.2s;
        }
        
        .quality-badge.valid {
            opacity: 1;
            background-color: #10b981;
            color: white;
        }
        
        .quality-badge.invalid {
            opacity: 1;
            background-color: #ef4444;
            color: white;
        }
        
        /* Action Buttons */
        .action-btn {
            padding: 4px 8px;
            border: 1px solid var(--card-border);
            border-radius: 6px;
            background: var(--card-bg);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        
        .action-btn:hover {
            background-color: var(--primary-color);
            color: white;
            transform: scale(1.1);
        }
        
        /* Progress Bars */
        .file-progress-bar {
            width: 100%;
            background-color: #e5e7eb;
            border-radius: 9999px;
            height: 0.5rem;
            margin-top: 0.5rem;
            overflow: hidden;
        }
        
        .file-progress-fill {
            background-color: #10b981;
            height: 100%;
            border-radius: 9999px;
            transition: width 0.3s ease;
        }
        
        /* Review Mode */
        .review-mode .translated-content {
            filter: blur(8px);
            transition: filter 0.3s;
        }
        
        .review-mode .translated-content:hover {
            filter: blur(0px);
        }

        .status-edited {
            background-color: #f59e0b;
        }

        /* Amber 500 */

        /* Styles for MathLive Fields */
        .editable-preview-field {
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            padding: 0.75rem;
            min-height: 80px;
        }

        math-field {
            position: relative;
        }

        .math-field-delete-btn {
            position: absolute;
            top: -10px;
            left: -10px;
            background-color: var(--error-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 10;
        }
        
        .math-field-copy-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 10;
        }
        
        math-field:hover .math-field-delete-btn,
        math-field:focus-within .math-field-delete-btn,
        math-field:hover .math-field-copy-btn,
        math-field:focus-within .math-field-copy-btn {
            opacity: 1;
            visibility: visible;
        }
        
        .math-field-delete-btn:hover {
            background-color: #dc2626;
            transform: scale(1.1);
        }
        
        .math-field-copy-btn:hover {
            background-color: var(--success-color);
            transform: scale(1.1);
        }
        /* MathLive default look (editable) */
        math-field {
            border: 1px solid var(--input-border);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 1.1em;
            display: inline-block;
            background: var(--input-bg);
            min-width: 20px;
            margin: 2px;
            max-width: 100%;
            white-space: nowrap;
            /* Force LTR for all math content - critical for equations */
            direction: ltr !important;
            unicode-bidi: embed;
        }

        /* Higher-fidelity preview to match source system: make formulas look inline and unboxed inside preview */
        .editable-preview-field math-field {
            border: 0;
            background: transparent;
            padding: 0 2px;
            box-shadow: none;
        }

        .editable-preview-field .content-root {
            line-height: 1.8;
        }

        .editable-preview-field .content-root p {
            margin: .25rem 0;
        }

        /* Approximate Lexical theme blocks so content spacing matches original */
        .LexicalTheme__paragraph {
            white-space: pre-wrap;
            margin: .25rem 0;
        }

        .LexicalTheme__image img {
            max-width: 100%;
            height: auto;
        }

        math-field:focus-within {
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--input-bg));
            box-shadow: 0 0 0 2px var(--primary-color);
            outline: none;
        }

        /* Enhanced MathLive keyboard styling for Arabic support */
        math-field {
            font-family: 'Cairo', 'Arial', sans-serif;
        }

        /* Arabic text in math fields */
        math-field[dir="rtl"] {
            text-align: right;
            direction: rtl;
        }

        /* English text in math fields */
        math-field[dir="ltr"] {
            text-align: left;
            direction: ltr;
        }

        /* Mixed content in math fields */
        math-field[dir="auto"] {
            text-align: start;
            direction: auto;
        }

        /* Virtual keyboard styling */
        .ML__keyboard {
            font-family: 'Cairo', 'Arial', sans-serif !important;
        }

        /* Arabic keys in keyboard */
        .ML__keyboard .ML__key[data-key*="\u0600"] {
            font-family: 'Cairo', 'Arial', sans-serif !important;
            font-size: 1.1em;
        }

        /* Language indicator */
        .ML__keyboard::before {
            content: attr(data-language);
            position: absolute;
            top: -25px;
            left: 10px;
            font-size: 12px;
            color: var(--secondary-text);
            font-family: 'Cairo', 'Arial', sans-serif;
        }

        /* Enhanced keyboard theme for Arabic */
        .ML__keyboard[data-language="ar"] {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }

        /* Arabic key styling */
        .ML__keyboard[data-language="ar"] .ML__key {
            border-radius: 6px;
            border: 1px solid #dee2e6;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .ML__keyboard[data-language="ar"] .ML__key:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }

        .ML__keyboard[data-language="ar"] .ML__key:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Visual blank for underscores in preview (does not persist to JSON) */
        .blank-slot {
            display: inline-block;
            min-width: 1.8em;
            border-bottom: 2px solid currentColor;
            vertical-align: baseline;
            line-height: 1.2;
            margin: 0 0.15em;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 2px;
            padding: 1px 2px;
        }

        /* Ensure blanks are visible in both original and translated text */
        .original-text-readonly .blank-slot,
        .editable-preview-field .blank-slot {
            border-bottom: 2px solid #666;
            background-color: rgba(0, 0, 0, 0.08);
        }

        /* Make blanks more prominent in original text */
        .original-text-readonly .blank-slot {
            border-bottom: 3px solid #333;
            background-color: rgba(0, 0, 0, 0.12);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        /* Ensure blanks are visible in read-only fields */
        .p-3.rounded-lg.text-sm .blank-slot {
            border-bottom: 2px solid #555;
            background-color: rgba(0, 0, 0, 0.1);
            min-width: 2em;
        }

        /* Make blanks more visible in different contexts */
        .blank-slot {
            position: relative;
            cursor: default;
        }

        .blank-slot::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 1px;
            background-color: rgba(0, 0, 0, 0.2);
        }

        /* Add hover effect to make blanks more interactive */
        .blank-slot:hover {
            background-color: rgba(0, 0, 0, 0.15) !important;
            border-bottom-color: #333 !important;
        }

        /* Ensure blanks are visible in dark mode */
        @media (prefers-color-scheme: dark) {
            .blank-slot {
                background-color: rgba(255, 255, 255, 0.1) !important;
                border-bottom-color: #ccc !important;
            }

            .blank-slot:hover {
                background-color: rgba(255, 255, 255, 0.2) !important;
                border-bottom-color: #fff !important;
            }
        }

        /* Add tooltip to show blank length on hover */
        .blank-slot[data-blank]:hover::before {
            content: attr(data-blank);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }

        /* Ensure tooltip is visible in dark mode */
        @media (prefers-color-scheme: dark) {
            .blank-slot[data-blank]:hover::before {
                background-color: #fff;
                color: #333;
            }
        }

        /* Add animation for better visual feedback */
        .blank-slot {
            transition: all 0.2s ease-in-out;
        }

        .blank-slot:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Ensure blanks are accessible */
        .blank-slot[data-blank] {
            aria-label: "فراغ: " attr(data-blank);
        }

        /* Add focus styles for keyboard navigation */
        .blank-slot:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        /* Ensure blanks are visible in print */
        @media print {
            .blank-slot {
                border-bottom: 2px solid #000 !important;
                background-color: transparent !important;
                box-shadow: none !important;
            }
        }

        /* Add support for high contrast mode */
        @media (prefers-contrast: high) {
            .blank-slot {
                border-bottom: 3px solid #000 !important;
                background-color: #fff !important;
            }
        }

        /* Add support for reduced motion */
        @media (prefers-reduced-motion: reduce) {
            .blank-slot {
                transition: none !important;
            }

            .blank-slot:hover {
                transform: none !important;
            }
        }

        /* Advanced text direction support for mixed content */
        .text-mixed {
            direction: auto;
            text-align: start;
            unicode-bidi: embed;
        }

        /* Enhanced text direction for Arabic-English mixed content */
        .rtl-auto {
            direction: rtl;
            text-align: right;
            unicode-bidi: embed;
        }

        .ltr-auto {
            direction: ltr;
            text-align: left;
            unicode-bidi: embed;
        }

        /* Support for inline mixed text */
        .mixed-content {
            direction: auto;
            unicode-bidi: plaintext;
        }

        /* Improved support for numbers in Arabic text */
        .arabic-numerals {
            font-family: 'Arial Unicode MS', Arial, sans-serif;
            direction: ltr;
            unicode-bidi: embed;
            display: inline;
        }

        .english-numerals {
            font-family: Arial, sans-serif;
            direction: ltr;
            unicode-bidi: embed;
            display: inline;
        }

        /* Enhanced preview content direction */
        .original-text-readonly,
        .editable-preview-field {
            direction: auto;
            text-align: start;
            unicode-bidi: plaintext;
        }

        /* Special handling for mixed content in preview */
        .content-root {
            unicode-bidi: plaintext;
        }

        .content-root * {
            unicode-bidi: embed;
        }
        
        /* Ensure proper RTL direction for Arabic content */
        .editable-preview-field .content-root[dir="rtl"],
        .original-text-readonly .content-root[dir="rtl"] {
            direction: rtl;
            text-align: right;
        }
        
        /* Ensure proper LTR direction for English content */
        .editable-preview-field .content-root[dir="ltr"],
        .original-text-readonly .content-root[dir="ltr"] {
            direction: ltr;
            text-align: left;
        }

        /* Handle English phrases within Arabic text */
        .english-phrase {
            direction: ltr;
            unicode-bidi: embed;
            display: inline;
        }

        /* Handle Arabic phrases within English text */
        .arabic-phrase {
            direction: rtl;
            unicode-bidi: embed;
            display: inline;
        }

        /* Math and chemical formulas should always be LTR */
        math-field,
        .math-content,
        .chemical-formula {
            direction: ltr !important;
            unicode-bidi: embed;
            text-align: left;
        }

        /* Improved blank slots for mixed content */
        .blank-slot {
            direction: inherit;
            unicode-bidi: embed;
        }

        /* Add support for large text */
        @media (prefers-reduced-motion: reduce) {
            .blank-slot {
                min-width: 2.5em;
                font-size: 1.1em;
            }
        }

        /* Tables inside editable preview */
        .editable-preview-field table {
            width: 100%;
            border-collapse: collapse;
            direction: rtl;
        }

        .editable-preview-field th,
        .editable-preview-field td {
            border: 1px solid var(--card-border);
            padding: 6px 8px;
            vertical-align: top;
        }

        .editable-preview-field thead {
            background-color: color-mix(in srgb, var(--primary-color) 8%, var(--card-bg));
        }

        /* Make table cells editable */
        .editable-preview-field td,
        .editable-preview-field th {
            position: relative;
            min-height: 1.5em;
            cursor: text;
        }

        .editable-preview-field td:focus,
        .editable-preview-field th:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: -2px;
            background-color: color-mix(in srgb, var(--primary-color) 5%, var(--input-bg));
        }
    </style>
</head>

<body class="text-gray-800">
    <div id="alertContainer" class="fixed top-0 right-0 p-4 w-full max-w-md z-50 space-y-3"></div>

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-4xl md:text-5xl font-bold" style="color: var(--primary-color);">🌍 مترجم الأسئلة 
            </h1>
            <div class="flex items-center gap-4">
                <span id="saveIndicator" aria-live="polite">—</span>
                <button id="theme-toggle" class="text-2xl">☀️</button>
                <button id="newSessionBtn"
                    class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition">بدء
                    جلسة جديدة</button>
            </div>
        </div>
        <p class="mt-2 mb-8 text-center text-lg" style="color: var(--secondary-text);">ترجمة ملفات JSON، مع المعاينة
            والتعديل، ودعم المعادلات الرياضية.</p>

        <div id="setupSection" class="main-card p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4 border-b-2 pb-2"
                style="color: var(--primary-color); border-color: var(--primary-color-light);">الخطوة 1: الإعدادات ورفع
                الملفات</h3>
            <div class="grid md:grid-cols-2 gap-6">
                <div>
                    <div class="mb-6">
                        <label class="block mb-2 font-semibold">اختر مُزوّد الخدمة:</label>
                        <div class="api-selector grid grid-cols-3 gap-4">
                            <div>
                                <input type="radio" id="geminiProvider" name="apiProvider" value="gemini" class="hidden"
                                    checked>
                                <label for="geminiProvider"
                                    class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span
                                        class="font-bold">🤖 Gemini</span></label>
                            </div>
                            <div>
                                <input type="radio" id="chatgptProvider" name="apiProvider" value="chatgpt"
                                    class="hidden">
                                <label for="chatgptProvider"
                                    class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span
                                        class="font-bold">💬 ChatGPT</span></label>
                            </div>
                            <div>
                                <input type="radio" id="localModelProvider" name="apiProvider" value="local"
                                    class="hidden">
                                <label for="localModelProvider"
                                    class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span
                                        class="font-bold">🖥️ نموذج محلي</span></label>
                            </div>
                        </div>
                    </div>

                    <div id="geminiKeyGroup" class="mb-6">
                        <label for="geminiKey" class="block mb-2 font-semibold">مفتاح Gemini API:</label>
                        <input type="password" id="geminiKey" placeholder="يبدأ بـ AIza..."
                            class="w-full p-3 rounded-lg focus:ring-2 transition"
                            style="border-color: var(--input-border);">
                    </div>
                    <div id="chatgptKeyGroup" class="mb-6 hidden">
                        <label for="chatgptKey" class="block mb-2 font-semibold">مفتاح OpenAI API:</label>
                        <input type="password" id="chatgptKey" placeholder="يبدأ بـ sk-..."
                            class="w-full p-3 rounded-lg focus:ring-2 transition"
                            style="border-color: var(--input-border);">
                    </div>
                    <div id="localModelGroup" class="mb-6 hidden">
                        <label for="localModelUrl" class="block mb-2 font-semibold">عنوان URL لخادم Ollama:</label>
                        <input type="text" id="localModelUrl" placeholder="http://localhost:11434/api/generate"
                            class="w-full p-3 rounded-lg focus:ring-2 transition mb-2"
                            style="border-color: var(--input-border);">
                        <label for="localModelName" class="block mb-2 font-semibold">اسم النموذج (مثال:
                            gemma:7b):</label>
                        <input type="text" id="localModelName" placeholder="gemma:7b"
                            class="w-full p-3 rounded-lg focus:ring-2 transition"
                            style="border-color: var(--input-border);">
                    </div>

                    <div class="mb-6">
                      <label for="translatorSelect" class="block mb-2 font-semibold">اسم المترجم:</label>
                      <select id="translatorSelect" class="w-full p-3 rounded-lg focus:ring-2 transition" style="border-color: var(--input-border);">
                        <option value="">اختر مترجماً</option>
                        <option value="Fatema Samy">Fatema Samy</option>
                        <option value="Samar Bahaaeldin">Samar Bahaaeldin</option>
                        <option value="Lobna Adel">Lobna Adel</option>
                        <option value="Shady Donia">Shady Donia</option>
                        <option value="Zeina Elsheikh">Zeina Elsheikh</option>
                        <option value="Aiat Saied">Aiat Saied</option>
                        <option value="Monica Sidhom">Monica Sidhom</option>
                        <option value="Yara Sobhy">Yara Sobhy</option>
                        <option value="Mariam Ghonaim">Mariam Ghonaim</option>
                        <option value="Hussein Mahmoud">Hussein Mahmoud</option>
                        <option value="Ahmed Sabra">Ahmed Sabra</option>
                        <option value="Ahmed Alhefny">Ahmed Alhefny</option>
                        <option value="Aya Abulmagd">Aya Abulmagd</option>
                        <option value="Gehan Khaled">Gehan Khaled</option>
                        <option value="Salma Hafez">Salma Hafez</option>
                        <option value="Hend El Husseiny">Hend El Husseiny</option>
                        <option value="Salma Zaki">Salma Zaki</option>
                        <option value="Esraa Shahien">Esraa Shahien</option>
                      </select>
                    </div>

                    <div class="mb-3">
                        <label class="inline-flex items-center gap-2">
                            <input id="ephemeralKeysCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2"
                                style="color: var(--primary-color);">
                            <span class="text-sm font-medium">عدم حفظ مفاتيح API محليًا (جلسة مؤقتة فقط)</span>
                        </label>
                    </div>
                    <div class="mb-3">
                        <label class="inline-flex items-center gap-2">
                            <input id="useTmCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2" checked
                                style="color: var(--primary-color);">
                            <span class="text-sm font-medium">استخدام ذاكرة الترجمة (TM)</span>
                        </label>
                        <div class="mt-1 mr-6 flex items-center gap-2">
                            <span id="tmStats" class="text-xs" style="color: var(--secondary-text);">جاري التحميل...</span>
                            <button id="clearTmBtn" type="button" class="text-xs px-2 py-1 rounded hover:opacity-75" style="background-color: var(--error-color); color: white;">مسح الذاكرة</button>
                        </div>
                    </div>
                    <div class="mb-6">
                        <label class="inline-flex items-center gap-2">
                            <input id="useProofreadCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2"
                                style="color: var(--primary-color);">
                            <span class="text-sm font-medium">تفعيل التدقيق اللغوي الآلي بعد الترجمة</span>
                        </label>
                    </div>

                    <div class="flex items-center justify-between mb-6 p-3 rounded-lg"
                        style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                        <button id="manageSubjectsBtn" type="button" class="font-semibold"
                            style="color: var(--primary-color);">📚 إدارة المواد والصفوف</button>
                    </div>

                    <div class="flex items-center justify-between p-3 rounded-lg"
                        style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                        <button id="manageIdsBtn" type="button" class="font-semibold"
                            style="color: var(--primary-color);">🆔 إدارة معرفات الأسئلة (mapped_id)</button>
                    </div>
                </div>

                <div>
                    <div class="mb-4">
                        <label class="block mb-2 font-semibold">ملفات الأسئلة (JSON):</label>
                        <div id="fileUpload"
                            class="border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition"
                            style="border-color: var(--input-border);">
                            <div style="color: var(--primary-color);" class="text-4xl mb-2">📤</div>
                            <p class="font-semibold">اسحب وأفلت الملفات هنا أو انقر للاختيار</p>
                            <p class="text-sm mt-1" style="color: var(--secondary-text);">يجب أن تكون الملفات بصيغة JSON
                            </p>
                            <input type="file" id="fileInput" multiple accept=".json" class="hidden">
                        </div>
                    </div>
                    <div id="fileList" class="space-y-2 max-h-40 overflow-y-auto"></div>
                </div>
            </div>

            <button id="translateBtn"
                class="w-full text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none mt-8"
                style="background-color: var(--primary-color);">
                ترجمة الملفات (Ctrl + Enter)
            </button>
        </div>

        <div id="progressContainer" class="hidden main-card p-6 rounded-2xl shadow-lg mb-6 text-center">
            <div class="w-16 h-16 border-4 border-dashed rounded-full animate-spin mx-auto"
                style="border-color: var (--primary-color); border-top-color: transparent;"></div>
            <p id="progressText" class="mt-4 text-lg font-semibold">جاري الترجمة...</p>
            <div class="mt-3">
                <button id="cancelTranslationBtn"
                    class="px-4 py-2 rounded-lg bg-red-500 text-white hover:bg-red-600">إلغاء</button>
            </div>
        </div>

        <div id="analyticsSection" class="hidden main-card p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4" style="color: var(--primary-color);">📊 تحليل الترجمة</h3>
            <div id="statsContainer" class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center"></div>
        </div>

        <div id="previewSection" class="hidden">
            <div class="main-card p-4 rounded-2xl shadow-lg mb-6">
                <div class="flex flex-wrap gap-4 items-center justify-between">
                    <div>
                        <h3 class="text-2xl font-bold" style="color: var(--success-color);">الخطوة 2: معاينة وتعديل
                            الترجمة</h3>
                        <p class="mt-1" style="color: var(--secondary-text);">راجع التراجم، عدّلها، وقارنها بالنص
                            الأصلي.</p>
                    </div>
                    <div class="flex items-center gap-2">
                        <button id="undoBtn" disabled class="px-3 py-2 rounded-lg disabled:opacity-50">↩️ تراجع</button>
                        <button id="redoBtn" disabled class="px-3 py-2 rounded-lg disabled:opacity-50">↪️ إعادة</button>
                        <button id="openAnnotatorBtn" class="px-3 py-2 rounded-lg"
                            title="تحرير النص فوق الصور (أرقام/رموز)">🖊️ محرر الصور</button>
                    </div>
                </div>
                <!-- لوحة الإحصائيات السريعة -->
                <div class="grid grid-cols-2 md:grid-cols-5 gap-3 my-4">
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--primary-color);" id="totalFieldsCount">0</div>
                        <div class="text-xs" style="color: var(--secondary-text);">إجمالي الحقول</div>
                    </div>
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--success-color);" id="completedFieldsCount">0</div>
                        <div class="text-xs" style="color: var(--secondary-text);">مكتملة</div>
                    </div>
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--warning-color);" id="editedFieldsCount">0</div>
                        <div class="text-xs" style="color: var(--secondary-text);">معدّلة يدوياً</div>
                    </div>
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--error-color);" id="warningsCount">0</div>
                        <div class="text-xs" style="color: var(--secondary-text);">تحذيرات</div>
                    </div>
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--primary-color);" id="progressPercentage">0%</div>
                        <div class="text-xs" style="color: var(--secondary-text);">نسبة الإنجاز</div>
                    </div>
                </div>

                <div class="preview-controls my-4 p-4 rounded-lg"
                    style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                    <!-- البحث -->
                    <div class="flex flex-wrap gap-4 items-center mb-3">
                        <div class="flex-grow">
                            <input type="text" id="searchPreview" placeholder="البحث في النص الأصلي أو الترجمة..."
                                class="w-full p-2 border rounded-lg">
                        </div>
                    </div>
                    
                    <!-- الفلاتر المتقدمة -->
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-3">
                        <select id="filterByType" class="p-2 border rounded-lg text-sm">
                            <option value="all">جميع الأنواع</option>
                            <option value="mcq">اختيار من متعدد</option>
                            <option value="input_box">صندوق إدخال</option>
                            <option value="gap_match">ملء الفراغات</option>
                            <option value="true_false">صح/خطأ</option>
                        </select>
                        
                        <select id="filterByStatus" class="p-2 border rounded-lg text-sm">
                            <option value="all">جميع الحالات</option>
                            <option value="translated">مترجمة آلياً</option>
                            <option value="edited">معدّلة يدوياً</option>
                            <option value="warnings">بها تحذيرات</option>
                        </select>
                        
                        <select id="sortBy" class="p-2 border rounded-lg text-sm">
                            <option value="default">الترتيب الافتراضي</option>
                            <option value="warnings">الأكثر تحذيرات</option>
                            <option value="longest">الأطول أولاً</option>
                            <option value="shortest">الأقصر أولاً</option>
                        </select>
                        
                        <button id="clearFiltersBtn" class="p-2 border rounded-lg text-sm hover:bg-gray-100">
                            🔄 إعادة تعيين
                        </button>
                    </div>
                    
                    <!-- أزرار الإجراءات السريعة -->
                    <div class="flex flex-wrap gap-2">
                        <button id="validateAllBtn" class="text-xs px-3 py-2 rounded-lg" 
                                style="background-color: var(--primary-color); color: white;">
                            ✓ التحقق من جميع الحقول
                        </button>
                        
                        <button id="expandAllBtn" class="text-xs px-3 py-2 rounded-lg border">
                            📂 فتح جميع الملفات
                        </button>
                        
                        <button id="collapseAllBtn" class="text-xs px-3 py-2 rounded-lg border">
                            📁 إغلاق جميع الملفات
                        </button>
                        
                        <button id="jumpToWarningsBtn" class="text-xs px-3 py-2 rounded-lg" 
                                style="background-color: var(--error-color); color: white;">
                            ⚠️ الانتقال للتحذيرات
                        </button>
                        
                        <button id="reviewModeBtn" class="text-xs px-3 py-2 rounded-lg border">
                            👁️ وضع المراجعة
                        </button>
                    </div>
                </div>
            </div>

            <div id="previewContainer" class="space-y-4"></div>

            <div class="main-card mt-8 p-4 rounded-2xl shadow-lg">
                <div class="flex items-center justify-center gap-4 mb-4">
                    <div class="text-center">
                        <p class="font-semibold mb-2">تصدير بصيغة JSON</p>
                        <p class="text-sm" style="color: var(--secondary-text);">يحافظ على البنية الأصلية للبيانات مع جميع الخصائص والعلاقات</p>
                    </div>
                    <button id="exportBtn"
                        class="text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105"
                        style="background-color: var(--success-color);">
                        تصدير الملفات المترجمة
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals (Glossary, Mapped IDs, Subjects) -->
    <!-- Image Annotator Modal -->
    <div id="imageAnnotatorModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-4 w-full max-w-4xl">
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-xl font-bold" style="color: var(--primary-color);">تحرير نص فوق الصورة</h3>
                <button id="imageAnnotatorClose" class="text-2xl">&times;</button>
            </div>
            <div class="w-full overflow-auto" style="max-height:70vh">
                <canvas id="imageAnnotatorCanvas" class="w-full border"
                    style="border-color: var(--card-border);"></canvas>
            </div>
            <div class="flex justify-end gap-2 mt-3">
                <button id="imageAnnotatorSave" class="px-4 py-2 rounded-lg text-white"
                    style="background-color: var(--success-color);">حفظ</button>
            </div>
        </div>
    </div>
    <div id="mappedIdsModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-2xl transform transition-all" role="dialog"
            aria-labelledby="mappedIdsTitle">
            <div class="flex justify-between items-center">
                <h3 id="mappedIdsTitle" class="text-2xl font-bold" style="color: var(--primary-color);">إدارة معرفات
                    الأسئلة (mapped_id)</h3>
                <button id="closeMappedIdsModalBtn" class="text-2xl hover:opacity-75"
                    aria-label="إغلاق">&times;</button>
            </div>
            <p class="text-sm mt-1 mb-4" style="color: var(--secondary-text);">أدخل عدد المعرفات المطلوبة ثم اضغط على
                الزر لجلبها تلقائياً، أو ألصقها يدوياً.</p>
            <div class="flex gap-2 mb-4">
                <input type="number" id="mappedIdsCount" placeholder="أدخل العدد"
                    class="p-2 border rounded-lg w-1/3 text-center">
                <button id="fetchMappedIdsBtn" class="flex-1 px-4 py-2 text-sm text-white rounded-lg"
                    style="background-color: var(--primary-color);">جلب الأكواد من Nagwa</button>
            </div>
            <textarea id="mappedIdsInput" rows="5" class="w-full p-2 rounded-lg mb-4"
                placeholder='["...","..."]'></textarea>
            <div class="flex items-center">
                <input id="useMappedIdsCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2"
                    style="color: var(--primary-color);">
                <label for="useMappedIdsCheckbox" class="mr-2 text-sm font-medium">تفعيل استبدال المعرفات عند
                    التصدير</label>
            </div>
        </div>
    </div>

    <div id="subjectsModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-3xl transform transition-all" role="dialog"
            aria-labelledby="subjectsTitle">
            <div class="flex justify-between items-center">
                <h3 id="subjectsTitle" class="text-2xl font-bold" style="color: var(--primary-color);">إدارة المواد
                    والصفوف</h3>
                <button id="closeSubjectsModalBtn" class="text-2xl hover:opacity-75" aria-label="إغلاق">&times;</button>
            </div>
            <p class="text-sm mt-1 mb-4" style="color: var(--secondary-text);">اختر المادة والصف لتطبيق تعليمات ترجمة مخصصة وجلب المصطلحات المناسبة.</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <select id="subjectSelect" class="p-2 border rounded-lg w-full"></select>
                <select id="gradeSelect" class="p-2 border rounded-lg w-full"></select>
            </div>
            <h4 class="text-lg font-semibold mb-2">معاينة التعليمات (البرومبت)</h4>
            <textarea id="promptPreview" rows="8" class="w-full p-2 rounded-lg mb-4" readonly></textarea>
            <button id="applyPromptBtn" class="w-full text-white font-bold py-2 px-4 rounded-lg"
                style="background-color: var(--success-color);">تطبيق وحفظ</button>
        </div>
    </div>

    <script>

        const GOOGLE_SHEET_ID = '16-ant77j9ckFE7y48mOaqmMvUQrx8ZzM-ksWHaFNSUU';

        const TranslatorApp = {
            constants: {
                BATCH_SEPARATOR: "\\n|||---|||\\n",
                CONTEXT_SEPARATOR: "\\n<SEP>\\n",
                HISTORY_MAX: 20,
                CHUNK_SIZE: 40
            },

            state: {
                selectedFilesInfo: [],
                originalJsonData: [],
                translatedJsonData: [],
                initialTranslatedJsonData: [],
                activeScreen: 'setup',
                translationCache: new Map(),
                startTime: null,
                hasUnsavedChanges: false,
                selectedSubject: 'None',
                selectedGrade: 'None',
                fileStore: new Map(),
                isTranslating: false,
                translators: {
                  "Aya Abulmagd": "643164068106",
                  "Salma Hafez": "927169194769",
                  "Hend El Husseiny": "805189370751",
                  "Salma Zaki": "698106520137",
                  "Esraa Shahien": "937145789737",
                  "Fatema Samy": "719130548578",
                  "Samar Bahaaeldin": "694164363692",
                  "Lobna Adel": "925171517156",
                  "Shady Donia": "963163430437",
                  "Zeina Elsheikh": "154106968213",
                  "Aiat Saied": "942130798452",
                  "Monica Sidhom": "819178319024",
                  "Yara Sobhy": "618146184254",
                  "Mariam Ghonaim": "182136230818",
                  "Hussein Mahmoud": "676130390838",
                  "Gehan Khaled": "475149294140",
                  "Ahmed Sabra": "175196786128",
                  "Ahmed Alhefny": "120171982460"
                    },
                selectedTranslator: "",
            },

            dom: {},

            init() {
                try {
                    this.cacheDomElements();
                    this.bindEvents();
                    this.theme.init();
                    this.history.init();
                    this.subjects.init();
                    this.translationMemory.init();
                    this.session.load();
                    this.shortcuts.init();
                    this.autoSave.init();
                    this.addBeforeUnloadGuard();
                    // Initialize shared MathLive virtual keyboard if available
                    try {
                        if (window.MathfieldElement) {
                            // Configure MathLive defaults
                            if (window.MathfieldElement.defaultConfig) {
                                window.MathfieldElement.defaultConfig = {
                                    ...window.MathfieldElement.defaultConfig,
                                    virtualKeyboardMode: 'onfocus',
                                    virtualKeyboardTheme: 'material',
                                    virtualKeyboards: 'numeric symbols greek',
                                    inlineShortcuts: true,
                                    smartMode: true,
                                    smartFence: true,
                                    smartSuperscript: true,
                                    keypressVibration: true,
                                };
                            }
                            
                            // Create shared virtual keyboard
                            if (typeof MathfieldElement.makeSharedVirtualKeyboard === 'function') {
                                MathfieldElement.makeSharedVirtualKeyboard();
                            }
                        }
                    } catch (mathError) {
                        console.warn('MathLive initialization error:', mathError);
                    }
                    
                    // Validate translation requirements on init (disable translate button initially)
                    setTimeout(() => {
                        this.validateTranslationRequirements();
                    }, 100);
                } catch (error) {
                    console.error('Application initialization error:', error);
                    TranslatorApp.ui.showAlert('فشل في تهيئة التطبيق. يرجى إعادة تحميل الصفحة.', 'error');
                }
            },

            cacheDomElements() {
                try {
                    const ids = {
                        alertContainer: 'alertContainer', newSessionBtn: 'newSessionBtn',
                        fileUpload: 'fileUpload', fileInput: 'fileInput', fileList: 'fileList',
                        translateBtn: 'translateBtn', geminiKeyInput: 'geminiKey', chatgptKeyInput: 'chatgptKey',
                        geminiKeyGroup: 'geminiKeyGroup', chatgptKeyGroup: 'chatgptKeyGroup',
                        localModelGroup: 'localModelGroup', localModelUrl: 'localModelUrl', localModelName: 'localModelName',
                        setupSection: 'setupSection', progressContainer: 'progressContainer', progressText: 'progressText',
                        previewSection: 'previewSection', previewContainer: 'previewContainer', exportBtn: 'exportBtn',
                        themeToggle: 'theme-toggle', analyticsSection: 'analyticsSection',
                        statsContainer: 'statsContainer',
                        searchPreview: 'searchPreview', undoBtn: 'undoBtn', redoBtn: 'redoBtn',
                        imageAnnotatorModal: 'imageAnnotatorModal',
                        imageAnnotatorCanvas: 'imageAnnotatorCanvas',
                        imageAnnotatorClose: 'imageAnnotatorClose',
                        imageAnnotatorSave: 'imageAnnotatorSave',
                        mappedIdsInput: 'mappedIdsInput', useMappedIdsCheckbox: 'useMappedIdsCheckbox',
                        manageIdsBtn: 'manageIdsBtn', mappedIdsModal: 'mappedIdsModal',
                        closeMappedIdsModalBtn: 'closeMappedIdsModalBtn',
                        mappedIdsCount: 'mappedIdsCount', fetchMappedIdsBtn: 'fetchMappedIdsBtn',
                        manageSubjectsBtn: 'manageSubjectsBtn', subjectsModal: 'subjectsModal',
                        closeSubjectsModalBtn: 'closeSubjectsModalBtn', subjectSelect: 'subjectSelect',
                        gradeSelect: 'gradeSelect', promptPreview: 'promptPreview', applyPromptBtn: 'applyPromptBtn',
                        cancelTranslationBtn: 'cancelTranslationBtn', saveIndicator: 'saveIndicator',
                        ephemeralKeysCheckbox: 'ephemeralKeysCheckbox',
                        useTmCheckbox: 'useTmCheckbox', useProofreadCheckbox: 'useProofreadCheckbox', translatorSelect: 'translatorSelect',
                        tmStats: 'tmStats', clearTmBtn: 'clearTmBtn',
                        totalFieldsCount: 'totalFieldsCount', completedFieldsCount: 'completedFieldsCount',
                        editedFieldsCount: 'editedFieldsCount', warningsCount: 'warningsCount', progressPercentage: 'progressPercentage',
                        filterByType: 'filterByType', filterByStatus: 'filterByStatus', sortBy: 'sortBy', clearFiltersBtn: 'clearFiltersBtn',
                        validateAllBtn: 'validateAllBtn', expandAllBtn: 'expandAllBtn', collapseAllBtn: 'collapseAllBtn',
                        jumpToWarningsBtn: 'jumpToWarningsBtn', reviewModeBtn: 'reviewModeBtn'
                    };
                    for (const k in ids) {
                        try {
                            this.dom[k] = document.getElementById(ids[k]);
                            if (!this.dom[k] && k !== 'glossaryCategory') {
                                console.warn(`DOM element not found: ${k}`);
                            }
                        } catch (elementError) {
                            console.warn(`Error caching DOM element ${k}:`, elementError);
                        }
                    }
                    this.dom.apiProviderRadios = document.querySelectorAll('input[name="apiProvider"]');
                } catch (error) {
                    console.error('Cache DOM elements error:', error);
                    throw new Error('فشل في تهيئة عناصر واجهة المستخدم');
                }
            },

            bindEvents() {
                try {
                    this.dom.previewContainer.addEventListener('input', (e) => {
                        try {
                            if (e.target.classList.contains('editable-unit')) {
                                const fieldContainer = e.target.closest('.editable-preview-field');
                                if (fieldContainer) {
                                    this.preview.handleUnitUpdate(fieldContainer, e.target.textContent);
                                }
                            } else {
                                const fieldContainer = e.target.closest('.editable-preview-field');
                                if (fieldContainer) {
                                    this.preview.handlePreviewFieldUpdate(fieldContainer);
                                }
                            }
                        } catch (error) {
                            console.error('Preview input event error:', error);
                        }
                    });
                    this.dom.previewContainer.addEventListener('keydown', (e) => {
                        // Protect math-fields from accidental deletion
                        if (e.key === 'Backspace' || e.key === 'Delete') {
                            const selection = window.getSelection();
                            if (!selection.rangeCount) return;

                            const range = selection.getRangeAt(0);
                            const focusNode = range.startContainer;
                            
                            // Check if we're inside a math-field
                            const parentMathField = focusNode.parentNode?.closest('math-field');
                            
                            // Only delete math-field if it's empty AND user is inside it
                            if (parentMathField && parentMathField.value.trim() === '') {
                                e.preventDefault();
                                const fieldContainer = parentMathField.closest('.editable-preview-field');
                                parentMathField.remove();
                                if (fieldContainer) {
                                    TranslatorApp.preview.handlePreviewFieldUpdate(fieldContainer);
                                }
                                return;
                            }
                            
                            // Prevent deletion of math-field when deleting adjacent text
                            const editableField = focusNode.parentNode?.closest('.editable-preview-field');
                            if (!editableField) return;
                            
                            // Enhanced protection: Check all possible sibling scenarios
                            if (e.key === 'Backspace') {
                                // Check direct previous sibling
                                const prevSibling = range.startContainer.previousSibling;
                                // Check if parent's previous sibling is math-field
                                const parentPrevSibling = range.startContainer.parentNode?.previousSibling;
                                
                                if ((prevSibling?.tagName === 'MATH-FIELD' && range.startOffset === 0) ||
                                    (parentPrevSibling?.tagName === 'MATH-FIELD' && range.startOffset === 0)) {
                                    // Place cursor before math-field instead of deleting it
                                    e.preventDefault();
                                    const mathField = prevSibling?.tagName === 'MATH-FIELD' ? prevSibling : parentPrevSibling;
                                    const newRange = document.createRange();
                                    newRange.setStartBefore(mathField);
                                    newRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                    return;
                                }
                            } else if (e.key === 'Delete') {
                                // Check direct next sibling
                                const nextSibling = range.startContainer.nextSibling;
                                // Check if parent's next sibling is math-field
                                const parentNextSibling = range.startContainer.parentNode?.nextSibling;
                                
                                if (nextSibling?.tagName === 'MATH-FIELD' || parentNextSibling?.tagName === 'MATH-FIELD') {
                                    // Place cursor after math-field instead of deleting it
                                    e.preventDefault();
                                    const mathField = nextSibling?.tagName === 'MATH-FIELD' ? nextSibling : parentNextSibling;
                                    const newRange = document.createRange();
                                    newRange.setStartAfter(mathField);
                                    newRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                    return;
                                }
                            }
                        }
                    }, true);
                    
                    this.dom.newSessionBtn.addEventListener('click', (e) => {
                        try {
                            this.session.clear.bind(this.session)();
                        } catch (error) {
                            console.error('New session error:', error);
                            TranslatorApp.ui.showAlert('فشل في بدء جلسة جديدة.', 'error');
                        }
                    });
                    this.dom.apiProviderRadios.forEach(radio => radio.addEventListener('change', (e) => {
                        try {
                            this.events.onApiProviderChange.bind(this)(e);
                        } catch (error) {
                            console.error('API provider radio change error:', error);
                        }
                    }));
                    this.dom.fileUpload.addEventListener('click', (e) => {
                        try {
                            this.dom.fileInput.click();
                        } catch (error) {
                            console.error('File upload click error:', error);
                        }
                    });
                    this.dom.fileUpload.addEventListener('dragover', (e) => {
                        try {
                            this.events.onDragOver(e);
                        } catch (error) {
                            console.error('Drag over error:', error);
                        }
                    });
                    this.dom.previewContainer.addEventListener('keydown', (e) => {
                        try {
                            const isEditable = e.target.closest('.editable-preview-field');
                            if (!isEditable) return;
                    
                            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'm') {
                                e.preventDefault();
                                const selection = window.getSelection();
                                if (!selection.rangeCount) return;
                                const range = selection.getRangeAt(0);
                                
                                // Create a new math-field element
                                const newMathField = document.createElement('math-field');
                                newMathField.setAttribute('default-mode', 'inline-math');
                                newMathField.setAttribute('value', '');
                                newMathField.setAttribute('virtual-keyboard-mode', 'onfocus');
                                newMathField.setAttribute('use-shared-virtual-keyboard', '');
                                newMathField.setAttribute('dir', 'ltr');
                                
                                // Insert the new math field
                                range.insertNode(newMathField);
                                
                                // Focus the cursor inside the new math field
                                newMathField.focus();
                    
                                TranslatorApp.preview.handlePreviewFieldUpdate(isEditable);
                            }
                        } catch (error) {
                            console.error('Math field shortcut error:', error);
                        }
                    }, true); // Use `true` for capture phase to ensure it runs before other handlers
                    
                    this.dom.fileUpload.addEventListener('dragleave', (e) => {
                        try {
                            this.events.onDragLeave(e);
                        } catch (error) {
                            console.error('Drag leave error:', error);
                        }
                    });
                    this.dom.fileUpload.addEventListener('drop', (e) => {
                        try {
                            this.events.onFileDrop.bind(this)(e);
                        } catch (error) {
                            console.error('File drop error:', error);
                        }
                    });
                    this.dom.fileInput.addEventListener('change', (e) => {
                        try {
                            this.events.onFileSelect.bind(this)(e);
                        } catch (error) {
                            console.error('File input change error:', error);
                        }
                    });
                    this.dom.translateBtn.addEventListener('click', (e) => {
                        try {
                            this.startTranslationProcess.bind(this)();
                        } catch (error) {
                            console.error('Start translation error:', error);
                            TranslatorApp.ui.showAlert('فشل في بدء عملية الترجمة.', 'error');
                        }
                    });
                    this.dom.cancelTranslationBtn.addEventListener('click', (e) => {
                        try {
                            this.api.cancel.bind(this.api)();
                        } catch (error) {
                            console.error('Cancel translation error:', error);
                        }
                    });
                    this.dom.exportBtn.addEventListener('click', (e) => {
                        try {
                            this.export.exportAs('json');
                        } catch (error) {
                            console.error('Export error:', error);
                            TranslatorApp.ui.showAlert('فشل في تصدير الملفات.', 'error');
                        }
                    });
                    
                    // New feature: Expand/Collapse All
                    this.dom.expandAllBtn?.addEventListener('click', () => {
                        try {
                            document.querySelectorAll('.accordion-content').forEach(content => {
                                content.style.maxHeight = content.scrollHeight + "px";
                                const parent = content.closest('.preview-card');
                                if (parent) parent.classList.add('open');
                            });
                        } catch (error) {
                            console.error('Expand all error:', error);
                        }
                    });
                    
                    this.dom.collapseAllBtn?.addEventListener('click', () => {
                        try {
                            document.querySelectorAll('.accordion-content').forEach(content => {
                                content.style.maxHeight = null;
                                const parent = content.closest('.preview-card');
                                if (parent) parent.classList.remove('open');
                            });
                        } catch (error) {
                            console.error('Collapse all error:', error);
                        }
                    });
                    
                    // Jump to warnings
                    this.dom.jumpToWarningsBtn?.addEventListener('click', () => {
                        try {
                            const firstWarning = document.querySelector('.field-error, .field-warning');
                            if (firstWarning) {
                                firstWarning.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                firstWarning.style.animation = 'pulse 1s ease-in-out 3';
                            } else {
                                TranslatorApp.ui.showAlert('لا توجد تحذيرات', 'success', 2000);
                            }
                        } catch (error) {
                            console.error('Jump to warnings error:', error);
                        }
                    });
                    
                    // Validate all fields
                    this.dom.validateAllBtn?.addEventListener('click', () => {
                        try {
                            TranslatorApp.preview.validateAllFields();
                        } catch (error) {
                            console.error('Validate all error:', error);
                        }
                    });
                    
                    // Review mode toggle
                    this.dom.reviewModeBtn?.addEventListener('click', () => {
                        try {
                            const previewSection = document.getElementById('previewSection');
                            previewSection?.classList.toggle('review-mode');
                            const isReviewMode = previewSection?.classList.contains('review-mode');
                            this.dom.reviewModeBtn.textContent = isReviewMode ? '✓ إنهاء المراجعة' : '👁️ وضع المراجعة';
                        } catch (error) {
                            console.error('Review mode toggle error:', error);
                        }
                    });
                    
                    // Filters
                    this.dom.filterByType?.addEventListener('change', () => {
                        try {
                            TranslatorApp.preview.applyFilters();
                        } catch (error) {
                            console.error('Filter by type error:', error);
                        }
                    });
                    
                    this.dom.filterByStatus?.addEventListener('change', () => {
                        try {
                            TranslatorApp.preview.applyFilters();
                        } catch (error) {
                            console.error('Filter by status error:', error);
                        }
                    });
                    
                    this.dom.sortBy?.addEventListener('change', () => {
                        try {
                            TranslatorApp.preview.applyFilters();
                        } catch (error) {
                            console.error('Sort by error:', error);
                        }
                    });
                    
                    this.dom.clearFiltersBtn?.addEventListener('click', () => {
                        try {
                            if (this.dom.filterByType) this.dom.filterByType.value = 'all';
                            if (this.dom.filterByStatus) this.dom.filterByStatus.value = 'all';
                            if (this.dom.sortBy) this.dom.sortBy.value = 'default';
                            TranslatorApp.preview.applyFilters();
                        } catch (error) {
                            console.error('Clear filters error:', error);
                        }
                    });
                    this.dom.geminiKeyInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Gemini key input error:', error);
                        }
                    });
                    this.dom.chatgptKeyInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('ChatGPT key input error:', error);
                        }
                    });
                    this.dom.localModelUrl.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Local model URL input error:', error);
                        }
                    });
                    this.dom.localModelName.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Local model name input error:', error);
                        }
                    });
                    this.dom.themeToggle.addEventListener('click', (e) => {
                        try {
                            this.theme.toggle.bind(this.theme)();
                        } catch (error) {
                            console.error('Theme toggle error:', error);
                        }
                    });
                    this.dom.mappedIdsInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Mapped IDs input error:', error);
                        }
                    });
                    this.dom.useMappedIdsCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Use mapped IDs checkbox error:', error);
                        }
                    });
                    this.dom.ephemeralKeysCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Ephemeral keys checkbox error:', error);
                        }
                    });
                    this.dom.useTmCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                            this.translationMemory.updateUI();
                        } catch (error) {
                            console.error('Use TM checkbox error:', error);
                        }
                    });
                    this.dom.useProofreadCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Use proofread checkbox error:', error);
                        }
                    });
                    
                    this.dom.clearTmBtn.addEventListener('click', (e) => {
                        try {
                            if (confirm('هل أنت متأكد من حذف جميع الترجمات المحفوظة؟\nلن تتمكن من استعادتها بعد الحذف.')) {
                                this.translationMemory.clear();
                                this.translationMemory.updateUI();
                                this.ui.showAlert('تم مسح ذاكرة الترجمة بنجاح', 'success');
                            }
                        } catch (error) {
                            console.error('Clear TM error:', error);
                        }
                    });

                    this.dom.searchPreview.addEventListener('input', (e) => {
                        try {
                            this.preview.filter.bind(this.preview)();
                        } catch (error) {
                            console.error('Search preview error:', error);
                        }
                    });
                    this.dom.undoBtn.addEventListener('click', (e) => {
                        try {
                            this.history.undo.bind(this.history)();
                        } catch (error) {
                            console.error('Undo error:', error);
                            TranslatorApp.ui.showAlert('فشل في التراجع.', 'error');
                        }
                    });
                    this.dom.redoBtn.addEventListener('click', (e) => {
                        try {
                            this.history.redo.bind(this.history)();
                        } catch (error) {
                            console.error('Redo error:', error);
                            TranslatorApp.ui.showAlert('فشل في الإعادة.', 'error');
                        }
                    });

                    this.dom.manageIdsBtn.addEventListener('click', () => {
                        try {
                            this.ui.showMappedIdsModal(true);
                        } catch (error) {
                            console.error('Show mapped IDs modal error:', error);
                        }
                    });
                    this.dom.closeMappedIdsModalBtn.addEventListener('click', () => {
                        try {
                            this.ui.showMappedIdsModal(false);
                        } catch (error) {
                            console.error('Close mapped IDs modal error:', error);
                        }
                    });
                    this.dom.fetchMappedIdsBtn.addEventListener('click', (e) => {
                        try {
                            this.mappedIds.fetch.bind(this.mappedIds)();
                        } catch (error) {
                            console.error('Fetch mapped IDs error:', error);
                            TranslatorApp.ui.showAlert('فشل في جلب المعرفات.', 'error');
                        }
                    });

                    this.dom.manageSubjectsBtn.addEventListener('click', () => {
                        try {
                            this.ui.showSubjectsModal(true);
                        } catch (error) {
                            console.error('Show subjects modal error:', error);
                        }
                    });
                    this.dom.closeSubjectsModalBtn.addEventListener('click', () => {
                        try {
                            this.ui.showSubjectsModal(false);
                        } catch (error) {
                            console.error('Close subjects modal error:', error);
                        }
                    });
                    this.dom.subjectSelect.addEventListener('change', (e) => {
                        try {
                            this.subjects.onSubjectChange.bind(this.subjects)();
                            // Check if all required fields are selected
                            TranslatorApp.validateTranslationRequirements();
                        } catch (error) {
                            console.error('Subject change error:', error);
                        }
                    });
                    this.dom.gradeSelect.addEventListener('change', (e) => {
                        try {
                            this.subjects.onGradeChange.bind(this.subjects)();
                            // Check if all required fields are selected
                            TranslatorApp.validateTranslationRequirements();
                        } catch (error) {
                            console.error('Grade change error:', error);
                        }
                    });
                    this.dom.applyPromptBtn.addEventListener('click', (e) => {
                        try {
                            this.subjects.apply.bind(this.subjects)();
                        } catch (error) {
                            console.error('Apply prompt error:', error);
                            TranslatorApp.ui.showAlert('فشل في تطبيق الإعدادات.', 'error');
                        }
                    });

                    // Image annotator events
                    const openAnnotatorBtn = document.getElementById('openAnnotatorBtn');
                    if (openAnnotatorBtn) {
                        openAnnotatorBtn.addEventListener('click', (e) => {
                            try {
                                this.annotator.open.bind(this.annotator)();
                            } catch (error) {
                                console.error('Open annotator error:', error);
                                TranslatorApp.ui.showAlert('فشل في فتح محرر الصور.', 'error');
                            }
                        });
                    }
                    this.dom.imageAnnotatorClose.addEventListener('click', (e) => {
                        try {
                            this.annotator.close.bind(this.annotator)();
                        } catch (error) {
                            console.error('Close annotator error:', error);
                        }
                    });
                    this.dom.imageAnnotatorSave.addEventListener('click', (e) => {
                        try {
                            this.annotator.save.bind(this.annotator)();
                        } catch (error) {
                            console.error('Save annotator error:', error);
                            TranslatorApp.ui.showAlert('فشل في حفظ الصورة.', 'error');
                        }
                    });

                    // Event delegation for all preview field updates
                    this.dom.previewContainer.addEventListener('input', (e) => {
                        try {
                            const fieldContainer = e.target.closest('.editable-preview-field');
                            if (fieldContainer) {
                                this.preview.handlePreviewFieldUpdate(fieldContainer);
                            }
                        } catch (error) {
                            console.error('Preview field update error:', error);
                        }
                    });
                    this.dom.previewContainer.addEventListener('copy', (e) => {
                        try {
                            this.preview.handleCopyEvent(e);
                        } catch (error) {
                            console.error('Copy event error:', error);
                        }
                    });

                    this.dom.previewContainer.addEventListener('paste', (e) => {
                        try {
                            this.preview.handlePasteEvent(e);
                        } catch (error) {
                            console.error('Paste event error:', error);
                        }
                    });
                    
                    // Ensure MathLive keyboard opens for inline chemistry/math on focus
                    this.dom.previewContainer.addEventListener('pointerdown', (e) => {
                        try {
                            const mf = e.target && e.target.closest && e.target.closest('math-field');
                            if (mf) {
                                try {
                                    mf.removeAttribute('read-only');
                                    mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                    mf.setAttribute('use-shared-virtual-keyboard', '');
                                    if (typeof mf.executeCommand === 'function') {
                                        setTimeout(() => {
                                            try {
                                                mf.executeCommand('showVirtualKeyboard');
                                                mf.focus();
                                            } catch (err) {
                                                console.warn('MathLive keyboard error:', err);
                                            }
                                        }, 100);
                                    }
                                    e.stopPropagation();
                                } catch (err) {
                                    console.warn('MathLive setup error:', err);
                                }
                            }
                        } catch (error) {
                            console.error('MathLive pointerdown error:', error);
                        }
                    });
                    this.dom.translatorSelect.addEventListener('change', (e) => {
                      try {
                        const selectedName = e.target.value;
                        // Update the global state with the selected translator's name
                        TranslatorApp.state.selectedTranslator = selectedName;
                        TranslatorApp.state.hasUnsavedChanges = true;
                        
                        // Check if all required fields are selected
                        TranslatorApp.validateTranslationRequirements();
                        
                        if (selectedName) {
                          const sourceId = TranslatorApp.state.translators[selectedName];
                          TranslatorApp.ui.showAlert(`تم اختيار المترجم: ${selectedName} (ID: ${sourceId}).`, 'info', 3000);
                        } else {
                          TranslatorApp.ui.showAlert('لم يتم اختيار مترجم. لن تتم إضافة source_id.', 'warning', 3000);
                        }
                      } catch (error) {
                          console.error('Translator select change error:', error);
                          TranslatorApp.ui.showAlert('حدث خطأ أثناء اختيار المترجم.', 'error');
                      }
                    });
                    this.dom.mappedIdsInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                            // Re-render the preview to show the new mapped ID
                            this.preview.render();
                        } catch (error) {
                            console.error('Mapped IDs input error:', error);
                        }
                    });
                    this.dom.useMappedIdsCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                            // Re-render the preview to show/hide the mapped ID
                            this.preview.render();
                        } catch (error) {
                            console.error('Use mapped IDs checkbox error:', error);
                        }
                    });
                } catch (error) {
                    console.error('bindEvents error:', error);
                    try { TranslatorApp.ui.showAlert('فشل في ربط الأحداث.', 'error'); } catch { }
                }
            },

            events: {
                onApiProviderChange(e) {
                    try {
                        const provider = e.target.value;
                        TranslatorApp.dom.geminiKeyGroup.classList.toggle('hidden', provider !== 'gemini');
                        TranslatorApp.dom.chatgptKeyGroup.classList.toggle('hidden', provider !== 'chatgpt');
                        TranslatorApp.dom.localModelGroup.classList.toggle('hidden', provider !== 'local');
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('API provider change error:', error);
                    }
                },
                onDragOver(e) {
                    try {
                        e.preventDefault();
                        e.currentTarget.classList.add('dragover');
                    } catch (error) {
                        console.error('Drag over error:', error);
                    }
                },
                onDragLeave(e) {
                    try {
                        e.preventDefault();
                        e.currentTarget.classList.remove('dragover');
                    } catch (error) {
                        console.error('Drag leave error:', error);
                    }
                },
                onFileDrop(e) {
                    try {
                        e.preventDefault();
                        TranslatorApp.dom.fileUpload.classList.remove('dragover');
                        TranslatorApp.fileHandler.addFiles(e.dataTransfer.files);
                    } catch (error) {
                        console.error('File drop error:', error);
                        TranslatorApp.ui.showAlert('فشل في إضافة الملفات.', 'error');
                    }
                },
                onFileSelect(e) {
                    try {
                        TranslatorApp.fileHandler.addFiles(e.target.files);
                    } catch (error) {
                        console.error('File select error:', error);
                        TranslatorApp.ui.showAlert('فشل في اختيار الملفات.', 'error');
                    }
                }
            },

            theme: {
                init() {
                    const savedTheme = localStorage.getItem('translatorTheme') || 'light';
                    this.set(savedTheme);
                },
                toggle() {
                    const current = document.documentElement.getAttribute('data-theme');
                    this.set(current === 'dark' ? 'light' : 'dark');
                },
                set(themeName) {
                    document.documentElement.setAttribute('data-theme', themeName);
                    localStorage.setItem('translatorTheme', themeName);
                    TranslatorApp.dom.themeToggle.textContent = themeName === 'dark' ? '☀️' : '🌙';
                }
            },

            shortcuts: {
                init() {
                    document.addEventListener('keydown', (e) => {
                        try {
                            if (e.ctrlKey || e.metaKey) {
                                const isEditable = e.target.closest('[contenteditable="true"]');
                                const isMathField = e.target.closest('math-field');
                                if (isEditable || isMathField) {
                                    return; // Exit and let the browser's native undo handle it.
                                }
                                switch (e.key.toLowerCase()) {
                                    case 's':
                                        e.preventDefault();
                                        TranslatorApp.session.save();
                                        TranslatorApp.ui.setSaveIndicator('saved');
                                        break;
                                    case 'o':
                                        e.preventDefault();
                                        TranslatorApp.dom.fileInput.click();
                                        break;
                                    case 'enter':
                                        if (TranslatorApp.state.activeScreen === 'setup') {
                                            e.preventDefault();
                                            TranslatorApp.dom.translateBtn.click();
                                        }
                                        break;
                                    case 'z':
                                        e.preventDefault();
                                        TranslatorApp.history.undo();
                                        break;
                                    case 'y':
                                        e.preventDefault();
                                        TranslatorApp.history.redo();
                                        break;
                                    case 'm':
                                    case 'M': // Support both lowercase and uppercase
                                        if (isEditable) {
                                            e.preventDefault();
                                            const selection = window.getSelection();
                                            if (!selection.rangeCount) return;
                                            const range = selection.getRangeAt(0);
                                    
                                            // Create and configure a new math-field element
                                            const newMathField = document.createElement('math-field');
                                            newMathField.setAttribute('default-mode', 'inline-math');
                                            newMathField.setAttribute('value', '');
                                            newMathField.setAttribute('virtual-keyboard-mode', 'onfocus');
                                            newMathField.setAttribute('use-shared-virtual-keyboard', '');
                                            newMathField.setAttribute('dir', 'ltr');
                                            
                                            // Insert math field
                                            range.insertNode(newMathField);
                                            
                                            // Add a zero-width space after the math field to allow cursor placement
                                            const zwsp = document.createTextNode('\u200B');
                                            newMathField.parentNode.insertBefore(zwsp, newMathField.nextSibling);
                                            
                                            // Place cursor inside the new math field
                                            newMathField.focus();
                                    
                                            TranslatorApp.preview.handlePreviewFieldUpdate(isEditable.closest('.editable-preview-field'));
                                        }
                                        break;
                                }
                            }

                            // MathLive language toggle shortcut (Alt + L)
                            if (e.ctrlKey && e.altKey && e.key === 'k') {
                                e.preventDefault();
                                TranslatorApp.utils.mathLive.toggleLanguage();
                            }

                            // Alt+M as alternative for inserting math field (for keyboards where Ctrl+M doesn't work)
                            if (e.altKey && !e.ctrlKey && (e.key === 'm' || e.key === 'M')) {
                                const isEditable = e.target.closest('.editable-preview-field');
                                if (isEditable && isEditable.isContentEditable) {
                                    e.preventDefault();
                                    const selection = window.getSelection();
                                    if (!selection.rangeCount) return;
                                    const range = selection.getRangeAt(0);
                            
                                    // Create and configure a new math-field element
                                    const newMathField = document.createElement('math-field');
                                    newMathField.setAttribute('default-mode', 'inline-math');
                                    newMathField.setAttribute('value', '');
                                    newMathField.setAttribute('virtual-keyboard-mode', 'onfocus');
                                    newMathField.setAttribute('use-shared-virtual-keyboard', '');
                                    newMathField.setAttribute('dir', 'ltr');
                                    
                                    // Insert math field
                                    range.insertNode(newMathField);
                                    
                                    // Add a zero-width space after the math field to allow cursor placement
                                    const zwsp = document.createTextNode('\u200B');
                                    newMathField.parentNode.insertBefore(zwsp, newMathField.nextSibling);
                                    
                                    // Place cursor inside the new math field
                                    newMathField.focus();
                            
                                    TranslatorApp.preview.handlePreviewFieldUpdate(isEditable.closest('.editable-preview-field'));
                                }
                            }

                        } catch (error) {
                            console.error('Shortcut error:', error);
                        }
                    });
                }
            },

            addBeforeUnloadGuard() {
                window.addEventListener('beforeunload', (e) => {
                    try {
                        if (TranslatorApp.state.hasUnsavedChanges) {
                            e.preventDefault();
                            e.returnValue = '';
                        }
                    } catch (error) {
                        console.error('Before unload error:', error);
                    }
                });
            },

            utils: {
                collectAllTextsFromFiles(filesArr) {
                    const bag = new Set();
                    const toPlain = (html) => {
                        if (typeof html !== 'string') return '';
                        const div = document.createElement('div');
                        div.innerHTML = html;
                        return (div.textContent || div.innerText || '').trim();
                    };

                    const traverse = (obj) => {
                        if (!obj) return;
                        if (Array.isArray(obj)) {
                            obj.forEach(item => traverse(item));
                        } else if (typeof obj === 'object') {
                            Object.keys(obj).forEach(key => {
                                const value = obj[key];
                                // **IMPROVEMENT**: More specific keys to check for translatable content
                                const translatableKeys = ['stem', 'html_content', 'answer', 'statement', 'student_answer', 'comment'];
                                if (translatableKeys.includes(key) && typeof value === 'string') {
                                    const plain = toPlain(value);
                                    if (plain) bag.add(plain);
                                } else if (key === 'gap_text_keys' && Array.isArray(value)) {
                                    value.forEach(item => {
                                        if (item && typeof item.value === 'string') {
                                            const plain = toPlain(item.value);
                                            if (plain) bag.add(plain);
                                        }
                                    });
                                }
                                else {
                                    traverse(value);
                                }
                            });
                        }
                    };

                    filesArr.forEach(f => {
                        if (f.data) traverse(f.data);
                    });

                    return Array.from(bag);
                },
                escapeRegex(str) { return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); },

                // MathLive language utilities
                mathLive: {
                    // Toggle language for all math fields
                    toggleLanguage() {
                        try {
                            const mathFields = document.querySelectorAll('math-field');
                            mathFields.forEach(mf => {
                                const currentLang = mf.getAttribute('virtual-keyboard-default-language') || 'ar';
                                const newLang = currentLang === 'ar' ? 'en' : 'ar';
                                mf.setAttribute('virtual-keyboard-default-language', newLang);
                                mf.setAttribute('dir', newLang === 'ar' ? 'rtl' : 'ltr');
                            });

                            const langText = newLang === 'ar' ? 'العربية' : 'English';
                            TranslatorApp.ui.showAlert(`تم التبديل إلى ${langText} لجميع الحقول الرياضية`, 'info', 2000);
                        } catch (error) {
                            console.error('Toggle language error:', error);
                        }
                    },

                    // Set language for specific math field
                    setLanguage(mathField, language) {
                        try {
                            if (!mathField || !language) return;

                            mathField.setAttribute('virtual-keyboard-default-language', language);
                            mathField.setAttribute('dir', language === 'ar' ? 'rtl' : 'ltr');

                            const langText = language === 'ar' ? 'العربية' : 'English';
                            TranslatorApp.ui.showAlert(`تم التبديل إلى ${langText}`, 'info', 1500);
                        } catch (error) {
                            console.error('Set language error:', error);
                        }
                    },

                    // Get current language of math field
                    getLanguage(mathField) {
                        try {
                            if (!mathField) return 'ar';
                            return mathField.getAttribute('virtual-keyboard-default-language') || 'ar';
                        } catch (error) {
                            console.error('Get language error:', error);
                            return 'ar';
                        }
                    },

                    // Detect language from text content
                    detectLanguage(text) {
                        try {
                            if (!text || typeof text !== 'string') return 'ar';

                            const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(text);
                            const hasEnglish = /[a-zA-Z]/.test(text);

                            if (hasArabic && !hasEnglish) return 'ar';
                            if (hasEnglish && !hasArabic) return 'en';
                            return 'ar'; // Default to Arabic
                        } catch (error) {
                            console.error('Detect language error:', error);
                            return 'ar';
                        }
                    }
                },

                // Advanced text direction detection and processing
                textDirection: {
                    // Detect if text is primarily Arabic
                    isArabic(text) {
                        if (!text || typeof text !== 'string') return false;
                        const arabicRegex = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
                        return arabicRegex.test(text);
                    },

                    // Detect if text is primarily English/Latin
                    isLatin(text) {
                        if (!text || typeof text !== 'string') return false;
                        const latinRegex = /[a-zA-Z]/;
                        return latinRegex.test(text);
                    },

                    // Detect if text contains numbers
                    hasNumbers(text) {
                        if (!text || typeof text !== 'string') return false;
                        return /[\d٠-٩]/.test(text);
                    },

                    // Detect if text is mixed (Arabic + Latin)
                    isMixed(text) {
                        if (!text || typeof text !== 'string') return false;
                        return this.isArabic(text) && this.isLatin(text);
                    },

                    // Get dominant text direction
                    getDominantDirection(text) {
                        if (!text || typeof text !== 'string') return 'rtl';

                        const arabicChars = (text.match(/[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/g) || []).length;
                        const latinChars = (text.match(/[a-zA-Z]/g) || []).length;

                        if (arabicChars > latinChars) return 'rtl';
                        if (latinChars > arabicChars) return 'ltr';
                        return 'rtl'; // Default to RTL for Arabic interface
                    },

                    // Process mixed content and add appropriate markup
                    processMixedContent(text) {
                        if (!text || typeof text !== 'string') return text;

                        try {
                            let processed = text;

                            // Handle Arabic numerals (٠-٩)
                            

                            // Handle English numerals in Arabic context
                            

                            // Handle English words/phrases in Arabic text
                            if (this.isArabic(text) && this.isLatin(text)) {
                                processed = processed.replace(/([a-zA-Z][a-zA-Z0-9\s\-_]*[a-zA-Z0-9]|[a-zA-Z])/g, (match) => {
                                    // Don't wrap if it's already wrapped
                                    if (match.includes('<span')) return match;
                                    return `<span class="english-phrase" dir="ltr">${match}</span>`;
                                });
                            }

                            return processed;
                        } catch (error) {
                            console.error('Process mixed content error:', error);
                            return text;
                        }
                    },

                    // Apply smart direction classes to element
                    applySmartDirection(element, text) {
                        if (!element || !text) return;

                        try {
                            const direction = this.getDominantDirection(text);
                            const isMixed = this.isMixed(text);

                            // Remove existing direction classes
                            element.classList.remove('rtl-auto', 'ltr-auto', 'text-mixed', 'mixed-content');

                            if (isMixed) {
                                element.classList.add('mixed-content');
                                element.setAttribute('dir', 'auto');
                            } else if (direction === 'rtl') {
                                element.classList.add('rtl-auto');
                                element.setAttribute('dir', 'rtl');
                            } else {
                                element.classList.add('ltr-auto');
                                element.setAttribute('dir', 'ltr');
                            }

                            // Add unicode-bidi for better rendering
                            if (isMixed) {
                                element.style.unicodeBidi = 'plaintext';
                            } else {
                                element.style.unicodeBidi = 'embed';
                            }
                        } catch (error) {
                            console.error('Apply smart direction error:', error);
                        }
                    },

                    // Enhanced content processing for preview
                    enhancePreviewContent(htmlString) {
                        if (!htmlString || typeof htmlString !== 'string') return htmlString;

                        try {
                            // Create a temporary container to work with DOM
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = htmlString;

                            // Process all text nodes
                            const walker = document.createTreeWalker(
                                tempDiv,
                                NodeFilter.SHOW_TEXT,
                                null,
                                false
                            );

                            const textNodes = [];
                            let node;
                            while (node = walker.nextNode()) {
                                textNodes.push(node);
                            }

                            textNodes.forEach(textNode => {
                                const text = textNode.textContent;
                                if (text && text.trim()) {
                                    const processedText = this.processMixedContent(text);
                                    if (processedText !== text) {
                                        const wrapper = document.createElement('span');
                                        wrapper.innerHTML = processedText;
                                        this.applySmartDirection(wrapper, text);
                                        textNode.parentNode.replaceChild(wrapper, textNode);
                                    }
                                }
                            });

                            // Apply direction to container elements
                            const elements = tempDiv.querySelectorAll('p, div, span, h1, h2, h3, h4, h5, h6');
                            elements.forEach(el => {
                                const text = el.textContent;
                                if (text && text.trim()) {
                                    this.applySmartDirection(el, text);
                                }
                            });

                            return tempDiv.innerHTML;
                        } catch (error) {
                            console.error('Enhance preview content error:', error);
                            return htmlString;
                        }
                    }
                },
                /**
                 * دالة لتحليل نص HTML، استخراج النصوص القابلة للترجمة، وتوليد هيكل HTML مع نصوص نائبة.
                 * @param {string} htmlString - كود HTML المراد تحليله.
                 * @param {object} basePointer - معلومات لتحديد مصدر النص (رقم الملف، الجزء، إلخ).
                 * @returns {{jobs: Array, parsedBody: HTMLElement}} - كائن يحتوي على قائمة مهام الترجمة والهيكل.
                 */
                parseHtmlAndCreateJobs(htmlString, basePointer) {
                    const jobs = [];
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(`<!DOCTYPE html><body>${htmlString}</body>`, 'text/html');
                    const body = doc.body;

                    function traverse(node) {
                        if (!node) return;
                        if (node.nodeType === 3) { // Text node
                            const text = (node.nodeValue || '').trim();
                            if (text) {
                                jobs.push({
                                    type: 'text_node',
                                    originalText: text,
                                    pointer: { ...(basePointer || {}) },
                                    domNode: node
                                });
                            }
                            return;
                        }
                        if (node.nodeType === 1) { // Element
                            const tag = (node.tagName || '').toUpperCase();
                            if (tag === 'SCRIPT' || tag === 'STYLE') return;
                            for (const child of Array.from(node.childNodes || [])) traverse(child);
                        }
                    }

                    traverse(body);
                    return { jobs, parsedBody: body };
                }
            },

            translationMemory: {
                storage: new Map(),
                maxEntries: 10000, // Maximum number of translations to store
                
                init() {
                    this.load();
                    // Update UI after a short delay to ensure DOM is ready
                    setTimeout(() => this.updateUI(), 100);
                },
                
                load() {
                    try {
                        const saved = localStorage.getItem('translationMemoryCache');
                        if (saved) {
                            const data = JSON.parse(saved);
                            this.storage = new Map(data);
                            console.log(`TM loaded: ${this.storage.size} entries`);
                        }
                    } catch (error) {
                        console.warn('Failed to load TM:', error);
                        this.storage = new Map();
                    }
                },
                
                save() {
                    try {
                        // Convert Map to array for JSON serialization
                        const data = Array.from(this.storage.entries());
                        
                        // If too many entries, keep only the most recent ones
                        if (data.length > this.maxEntries) {
                            const trimmed = data.slice(-this.maxEntries);
                            this.storage = new Map(trimmed);
                        }
                        
                        localStorage.setItem('translationMemoryCache', JSON.stringify(Array.from(this.storage.entries())));
                        console.log(`TM saved: ${this.storage.size} entries`);
                    } catch (error) {
                        console.warn('Failed to save TM:', error);
                    }
                },
                
                get(originalText) {
                    if (!TranslatorApp.dom.useTmCheckbox.checked) return null;
                    const key = this.createKey(originalText);
                    return this.storage.get(key) || null;
                },
                
                set(originalText, translatedText) {
                    if (!TranslatorApp.dom.useTmCheckbox.checked) return;
                    const key = this.createKey(originalText);
                    this.storage.set(key, {
                        translation: translatedText,
                        timestamp: Date.now(),
                        subject: TranslatorApp.state.selectedSubject,
                        grade: TranslatorApp.state.selectedGrade
                    });
                },
                
                createKey(text) {
                    // Normalize text for consistent matching
                    return (text || '').trim().toLowerCase();
                },
                
                clear() {
                    this.storage.clear();
                    localStorage.removeItem('translationMemoryCache');
                    console.log('TM cleared');
                },
                
                getStats() {
                    return {
                        totalEntries: this.storage.size,
                        maxEntries: this.maxEntries,
                        enabled: TranslatorApp.dom.useTmCheckbox.checked
                    };
                },
                
                updateUI() {
                    try {
                        const stats = this.getStats();
                        if (TranslatorApp.dom.tmStats) {
                            const statusText = stats.enabled ? '✓ مفعّل' : '✗ معطّل';
                            TranslatorApp.dom.tmStats.textContent = `${statusText} | عدد الترجمات المحفوظة: ${stats.totalEntries.toLocaleString('ar-EG')} / ${stats.maxEntries.toLocaleString('ar-EG')}`;
                        }
                    } catch (error) {
                        console.warn('TM UI update error:', error);
                    }
                }
            },

            remoteGlossary: {
                map: {},
                async fetchApproved(subject, grade, texts) {
                    this.map = {};
                    if (!subject || subject === 'None') return this.map;
                    
                    try {
                        // Extract grid number from grade (e.g., "Grade 5" -> "5")
                        const gradeNumber = grade.replace(/[^0-9]/g, '');
                        
                        console.log(`Fetching termbase for Subject: ${subject}, Grade: ${gradeNumber}`);
                        
                        // Query based on new structure: Subject (Column A), grid (Column B), English Term (Column D), Arabic Term (Column E)
                        // Filter by Subject and grid
                        let tq = `select D,E where A = '${(subject || '').replace(/'/g, "\\'")}' and B = '${gradeNumber}'`;
                        let url = `https://docs.google.com/spreadsheets/d/${GOOGLE_SHEET_ID}/gviz/tq?tqx=out:json&headers=1&tq=${encodeURIComponent(tq)}`;
                        
                        let res = await fetch(url, { cache: 'no-cache' });
                        
                        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        
                        const raw = await res.text();
                        const match = raw.match(/google\.visualization\.Query\.setResponse\(([\s\S]+)\);/);
                        if (!match) throw new Error('تعذّر قراءة استجابة gviz.');
                        
                        const data = JSON.parse(match[1]);
                        const rows = data.table?.rows || [];
                        
                        // Column D (index 0) = English Term, Column E (index 1) = Arabic Term
                        const allPairs = rows.map(r => ({
                            term: (r.c?.[0]?.v || '').toString().trim(),
                            translation: (r.c?.[1]?.v || '').toString().trim()
                        })).filter(x => x.term && x.translation);

                        console.log(`Fetched ${allPairs.length} terms for ${subject} - Grade ${gradeNumber}`);

                        const loweredTexts = Array.isArray(texts) ? texts.map(t => (t || '').toString().toLowerCase()) : [];
                        const map = {};
                        if (loweredTexts.length > 0) {
                            allPairs.forEach(({ term, translation }) => {
                                const tl = term.toLowerCase();
                                if (loweredTexts.some(tx => tx.includes(tl))) map[term] = translation;
                            });
                        } else {
                            allPairs.forEach(({ term, translation }) => { map[term] = translation; });
                        }
                        this.map = map;
                        
                        console.log(`Applied ${Object.keys(map).length} terms from termbase`);
                        return this.map;
                    } catch (e) {
                        console.warn('GVIZ fetch failed:', e);
                        TranslatorApp.ui.showAlert('تعذّر جلب المصطلحات المعتمدة (سيتم الاستمرار بدونها).', 'info', 4000);
                        this.map = {};
                        return this.map;
                    }
                },
                applyWithPlaceholders(text) {
                    if (!text || !this.map || Object.keys(this.map).length === 0) {
                        return { modifiedText: text, placeholders: {} };
                    }
                    let modifiedText = text;
                    const placeholders = {};
                    let i = 0;
                    const terms = Object.keys(this.map).filter(Boolean).sort((a, b) => b.length - a.length);
                    for (const term of terms) {
                        const translation = this.map[term];
                        if (!translation) continue;
                        const esc = TranslatorApp.utils.escapeRegex(term.trim());
                        const useWordBoundary = /^[A-Za-z0-9 _-]+$/.test(term);
                        const re = new RegExp(useWordBoundary ? `\\b${esc}\\b` : esc, 'gi');
                        if (re.test(modifiedText)) {
                            const ph = `__GLOSSARY_${i++}__`;
                            placeholders[ph] = translation;
                            modifiedText = modifiedText.replace(re, ph);
                        }
                    }
                    return { modifiedText, placeholders };
                },
                revertPlaceholders(text, placeholders) {
                    if (!placeholders || !text) return text;
                    let out = text;
                    for (const [ph, tr] of Object.entries(placeholders)) out = out.split(ph).join(tr);
                    return out;
                }
            },

            security: {
                SALT: "a-secure-static-salt-for-obfuscation",
                encrypt(key) {
                    try {
                        if (!key || typeof key !== 'string') return '';
                        return btoa(key + this.SALT);
                    } catch (error) {
                        console.warn('Encryption error:', error);
                        return '';
                    }
                },
                decrypt(encryptedKey) {
                    try {
                        if (!encryptedKey || typeof encryptedKey !== 'string') return '';
                        const decoded = atob(encryptedKey);
                        return decoded.endsWith(this.SALT) ? decoded.slice(0, -this.SALT.length) : '';
                    } catch (error) {
                        console.warn('Decryption error:', error);
                        return '';
                    }
                },
                escapeHtml(text) {
                    if (typeof text !== 'string') return text;
                    const map = {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#039;'
                    };
                    return text.replace(/[&<>"']/g, m => map[m]);
                },
                sanitize(html) {
                    if (typeof html !== 'string') return html;
                    try {
                        if (window.DOMPurify) {
                            return DOMPurify.sanitize(html, {
                                ALLOWED_TAGS: ['b', 'i', 'u', 'em', 'strong', 'sub', 'sup', 'br', 'span', 'p', 'ul', 'ol', 'li', 'img', 'a', 'code', 'pre', 'table', 'tr', 'td', 'th', 'thead', 'tbody', 'math', 'div', 'math-field', 'audio'],
                                ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'class', 'style', 'dir', 'value', 'default-mode', 'data-path', 'data-file-index', 'data-blank', 'read-only', 'controls', 'virtual-keyboard-mode', 'use-shared-virtual-keyboard', 'data-node-type', 'data-node-variation', 'locale', 'data-question-id', 'data-part-index', 'data-field-type', 'data-choice-index', 'data-math-index', 'white-space']
                            });
                        }
                        // Fallback sanitization
                        return html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                    } catch (error) {
                        console.warn('HTML sanitization error:', error);
                        // Return a safe fallback
                        return html ? html.replace(/<[^>]*>/g, '') : '';
                    }
                }
            },

            quality: {
                unitsMap: {
                    'pounds': 'جنيه',
                    'pound': 'جنيه',
                    'cm': 'سم',
                    'mm': 'مم',
                    'km': 'كم',
                    'm': 'م',
                    'kg': 'كجم',
                    'g': 'جم',
                    'l': 'ل',
                    'L': 'ل',
                    'ml': 'مل',
                    's': 'ث',
                    'min': 'د',
                    'h': 'س'
                },
                wantsArabicIndicDigits(subject, grade) {
                    if (subject === 'Mathematics' && ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'].includes(grade)) return true;
                    if (subject === 'Science' && grade === 'Grade 9') return true;
                    return false;
                },
                cleanLatexArabic(text) {
                    if (typeof text !== 'string') return text;
                    // This is a simple but effective fix for the specific issue
                    return text.replace(/\\alt{\\alef}\\prime/g, '')
                               .replace(/\\lam/g, 'والباقي ');
                },
                
                protectSegments(text) {
                    const placeholders = {};
                    let idx = 0;
                    const patterns = [
                        /<math-field[\s\S]*?<\/math-field>/g,
                        /<audio[\s\S]*?<\/audio>/g,
                        /<img[^>]*>/g,
                        // Don't protect tables - let their content be translated
                        // /<table[\s\S]*?<\/table>/g,
                        /_{3,}/g,
                        /```[\s\S]*?```/g,
                        /`[^`]*`/g,
                        /\$\$[\s\S]*?\$\$/g,
                        /\$[^$]*\$/g,
                        /\\\[[\s\S]*?\\]/g,
                        /\\\([\s\S]*?\\\)/g,
                        /https?:\/\/\S+/g,
                        // Protect Lexical theme elements that might interfere with translation
                        /<span[^>]*class="[^"]*LexicalTheme[^"]*"[^>]*>[\s\S]*?<\/span>/g,
                        /<p[^>]*class="[^"]*LexicalTheme[^"]*"[^>]*>[\s\S]*?<\/p>/g
                    ];
                    let protectedText = String(text || '');
                    for (const re of patterns) {
                        protectedText = protectedText.replace(re, (m) => { const ph = `__LOCK_${idx++}__`; placeholders[ph] = m; return ph; });
                    }
                    return { protectedText, placeholders };
                },
                restoreSegments(text, placeholders) {
                    if (!placeholders) return text;
                    let out = text || '';
                    for (const [ph, val] of Object.entries(placeholders)) out = out.split(ph).join(val);
                    return out;
                },
                convertDigits(str, toArabicIndic) {
                    const en = '0123456789'.split(''); const ar = '٠١٢٣٤٥٦٧٨٩'.split('');
                    if (toArabicIndic) return (str || '').replace(/[0-9]/g, ch => ar[+ch]);
                    return (str || '').replace(/[٠-٩]/g, ch => en[ar.indexOf(ch)]);
                },
                normalizeArabicPunct(str) {
                    return (str || '')
                        .replace(/ ,/g, '،')
                        .replace(/, /g, '، ')
                        .replace(/,/g, '،')
                        .replace(/;/g, '؛')
                        .replace(/\?/g, '؟')
                        .replace(/["""]/g, '»')
                        .replace(/'/g, 'ʼ')
                        .replace(/\s+([،؛؟])/g, '$1')
                        .replace(/([،؛])(?=[^\s])/g, '$1 ')
                        .replace(/\s+/g, ' ');
                },
                enforceUnits(str, ctx = { subject: 'None', grade: 'None' }) {
                    const map = { cm: 'سم', mm: 'مم', km: 'كم', m: 'م', kg: 'كجم', g: 'جم', l: 'ل', L: 'ل', ml: 'مل', s: 'ث', min: 'د', h: 'س' };
                    
                    // For Math Grades 4-8, units should be translated but keep English digits
                    const mathEnglishGrades = ['Grade 4', 'Grade 5', 'Grade 6', 'Grade 7', 'Grade 8'];
                    if (ctx.subject === 'Mathematics' && mathEnglishGrades.includes(ctx.grade)) {
                        // Keep English digits, translate units
                        return (str || '').replace(/([0-9.,]+)\s*(cm|mm|km|m|kg|g|l|L|ml|s|min|h)\b/g, (m, num, u) => `${num}\u00A0${map[u] || u}`);
                    }
                    
                    // For other grades, work with both English and Arabic digits
                    return (str || '').replace(/(\d[0-9٠-٩.,]*)\s*(cm|mm|km|m|kg|g|l|L|ml|s|min|h)\b/g, (m, num, u) => `${num}\u00A0${map[u] || u}`);
                },
                convertAndToComma(str, ctx = { subject: 'None', grade: 'None' }) {
                    // For Math Grades 1-3 and 9-12, convert "and" between symbols/numbers to Arabic comma
                    const mathArabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                    if (ctx.subject === 'Mathematics' && mathArabicGrades.includes(ctx.grade)) {
                        // Convert "and" or "و" between numbers or symbols to comma
                        let result = str || '';
                        // Match patterns like "x and y" or "3 and 5" and convert to comma
                        result = result.replace(/([0-9٠-٩a-zA-Zء-ي]+)\s+and\s+([0-9٠-٩a-zA-Zء-ي]+)/gi, '$1، $2');
                        // Also handle if "and" was already translated to "و" (for both numbers and Arabic letters)
                        result = result.replace(/([0-9٠-٩ء-ي]+)\s+و\s+([0-9٠-٩ء-ي]+)/g, '$1، $2');
                        return result;
                    }
                    return str;
                },
                ensureRTLDirection(htmlString) {
                    // Ensure all HTML elements with Arabic text have proper RTL direction
                    if (!htmlString || typeof htmlString !== 'string') return htmlString;
                    
                    try {
                        // Create a temporary container
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = htmlString;
                        
                        // Function to check if text is primarily Arabic
                        const isArabicText = (text) => {
                            if (!text) return false;
                            const arabicChars = (text.match(/[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/g) || []).length;
                            const totalChars = text.replace(/\s/g, '').length;
                            return arabicChars > totalChars * 0.3; // If more than 30% Arabic, consider it Arabic
                        };
                        
                        // Process all elements that can contain text
                        const elements = tempDiv.querySelectorAll('p, div, span, td, th, li, h1, h2, h3, h4, h5, h6');
                        elements.forEach(el => {
                            // Skip SVG and math elements
                            if (el.closest('svg, math-field')) return;
                            
                            const textContent = el.textContent || '';
                            if (textContent.trim() && isArabicText(textContent)) {
                                // Only add dir if not already set
                                if (!el.hasAttribute('dir')) {
                                    el.setAttribute('dir', 'rtl');
                                }
                            }
                        });
                        
                        return tempDiv.innerHTML;
                    } catch (error) {
                        console.error('Ensure RTL direction error:', error);
                        return htmlString;
                    }
                },
                postProcess(text, ctx = { subject: 'None', grade: 'None' }) {
                    let out = text || '';
                    // Add a new rule to replace the remainder symbol
                    out = out.replace(/R\s*(\d+)/g, ' والباقي $1');
                    
                    // Convert "and" to comma for specific grades
                    out = this.convertAndToComma(out, ctx);
                    
                    const toArabic = this.wantsArabicIndicDigits(ctx.subject, ctx.grade);
                    out = this.convertDigits(out, toArabic);
                    out = this.enforceUnits(out, ctx);
                    out = this.normalizeArabicPunct(out);
                    out = out.replace(/»([^»«]+)»/g, '«$1»');
                    
                    // Ensure RTL direction for Arabic content
                    out = this.ensureRTLDirection(out);
                    
                    return out;
                },
                qa: {
                    extractPlain(html) { const div = document.createElement('div'); div.innerHTML = html || ''; return (div.textContent || div.innerText || '').trim(); },
                    unifyDigits(s) { const ar = '٠١٢٣٤٥٦٧٨٩'; return (s || '').replace(/[٠-٩]/g, d => String(ar.indexOf(d))); },
                    extractNumbers(s) { return Array.from((s || '').matchAll(/[0-9٠-٩]+(?:[.,][0-9٠-٩]+)?/g)).map(m => m[0]); },
                    sameNumberSet(srcArr, dstArr) {
                        const a = srcArr.map(this.unifyDigits).sort().join('|');
                        const b = dstArr.map(this.unifyDigits).sort().join('|');
                        return a === b;
                    },
                    checkNumbers(srcHtml, dstHtml) {
                        const s = this.extractPlain(srcHtml); const d = this.extractPlain(dstHtml);
                        const srcNums = this.extractNumbers(s); const dstNums = this.extractNumbers(d);
                        return this.sameNumberSet(srcNums, dstNums) ? [] : [`تحذير: تغيرت/اختفت أرقام (${srcNums.join(',')}) → (${dstNums.join(',')}).`];
                    },
                    checkSeparator(dstText, sep) {
                        if (!dstText) return [];
                        const want = (dstText.match(new RegExp(sep.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g')) || []).length;
                        const legacy = (dstText.match(/<SEP>/g) || []).length;
                        if (legacy > 0 && want === 0) return ['تحذير: لم يُحفظ الفاصل <SEP> كما هو.'];
                        return [];
                    },
                    checkHtmlBalance(dstHtml) {
                        const tags = ['b', 'i', 'u', 'strong', 'em', 'sub', 'sup', 'span', 'p', 'ul', 'ol', 'li'];
                        const errs = [];
                        tags.forEach(t => {
                            const open = (dstHtml.match(new RegExp(`<${t}\\b`, 'gi')) || []).length;
                            const close = (dstHtml.match(new RegExp(`</${t}>`, 'gi')) || []).length;
                            if (open !== close) errs.push(`تحذير: الوسم <${t}> غير متوازن (${open}/${close}).`);
                        });
                        return errs;
                    }
                }
            },

            tm: {
                KEY: 'translatorTMv1',
                getStore() { try { return JSON.parse(localStorage.getItem(this.KEY) || '{}'); } catch { return {}; } },
                saveStore(obj) { localStorage.setItem(this.KEY, JSON.stringify(obj)); },
                plain(html) { const div = document.createElement('div'); div.innerHTML = html || ''; return (div.textContent || div.innerText || '').trim().toLowerCase(); },
                key(text, ctx) { return `${ctx.subject}||${ctx.grade}||${this.plain(text)}`; },
                get(text, ctx) { const store = this.getStore(); return store[this.key(text, ctx)] || null; },
                put(text, ctx, translated) {
                    const store = this.getStore();
                    const k = this.key(text, ctx);
                    store[k] = translated;
                    this.saveStore(store);
                }
            },

            session: {
                save() {
                    try {
                        const ephemeral = TranslatorApp.dom.ephemeralKeysCheckbox.checked;
                        const sessionData = {
                            apiKeys: ephemeral ? null : {
                                gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                                chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value),
                            },
                            localModelUrl: TranslatorApp.dom.localModelUrl.value,
                            localModelName: TranslatorApp.dom.localModelName.value,
                            selectedProvider: document.querySelector('input[name="apiProvider"]:checked').value,
                            selectedFilesInfo: TranslatorApp.state.selectedFilesInfo,
                            originalJsonData: TranslatorApp.state.originalJsonData,
                            translatedJsonData: TranslatorApp.state.translatedJsonData,
                            initialTranslatedJsonData: TranslatorApp.state.initialTranslatedJsonData,
                            glossary: TranslatorApp.state.glossary,
                            activeScreen: TranslatorApp.state.activeScreen,
                            mappedIds: TranslatorApp.dom.mappedIdsInput.value,
                            useMappedIds: TranslatorApp.dom.useMappedIdsCheckbox.checked,
                            selectedSubject: TranslatorApp.state.selectedSubject,
                            selectedGrade: TranslatorApp.state.selectedGrade,
                            ephemeralKeys: ephemeral,
                            useTM: TranslatorApp.dom.useTmCheckbox.checked,
                            useProofread: TranslatorApp.dom.useProofreadCheckbox.checked
                        };
                        localStorage.setItem('translatorSession', JSON.stringify(sessionData));

                        // Always save API keys to sessionStorage for persistence across browser sessions
                        if (TranslatorApp.dom.geminiKeyInput.value || TranslatorApp.dom.chatgptKeyInput.value) {
                            sessionStorage.setItem('translatorPersistentKeys', JSON.stringify({
                                gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                                chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value),
                                provider: document.querySelector('input[name="apiProvider"]:checked').value
                            }));
                        }

                        if (ephemeral) {
                            sessionStorage.setItem('translatorEphemeralKeys', JSON.stringify({
                                gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                                chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value)
                            }));
                        } else {
                            sessionStorage.removeItem('translatorEphemeralKeys');
                        }

                        TranslatorApp.state.hasUnsavedChanges = false;
                    } catch (error) {
                        console.error('Session save error:', error);
                        TranslatorApp.ui.showAlert('فشل في حفظ الجلسة.', 'error');
                    }
                },
                load() {
                    const saved = localStorage.getItem('translatorSession');
                    if (!saved) return;
                    try {
                        const s = JSON.parse(saved);
                        TranslatorApp.dom.ephemeralKeysCheckbox.checked = !!s.ephemeralKeys;

                        // Load API keys with fallback to persistent storage
                        let keysLoaded = false;
                        if (s.apiKeys && !s.ephemeralKeys) {
                            TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(s.apiKeys?.gemini || '');
                            TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(s.apiKeys?.chatgpt || '');
                            keysLoaded = true;
                        } else if (s.ephemeralKeys) {
                            const sk = JSON.parse(sessionStorage.getItem('translatorEphemeralKeys') || '{}');
                            TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(sk?.gemini || '');
                            TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(sk?.chatgpt || '');
                            keysLoaded = true;
                        }

                        // Fallback to persistent keys if no keys loaded from session
                        if (!keysLoaded) {
                            const persistentKeys = JSON.parse(sessionStorage.getItem('translatorPersistentKeys') || '{}');
                            if (persistentKeys.gemini || persistentKeys.chatgpt) {
                                TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(persistentKeys.gemini || '');
                                TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(persistentKeys.chatgpt || '');
                                if (persistentKeys.provider) {
                                    const radio = document.querySelector(`input[name="apiProvider"][value="${persistentKeys.provider}"]`);
                                    if (radio) { radio.checked = true; TranslatorApp.events.onApiProviderChange({ target: { value: persistentKeys.provider } }); }
                                }
                            }
                        }

                        TranslatorApp.dom.localModelUrl.value = s.localModelUrl || 'http://localhost:11434/api/generate';
                        TranslatorApp.dom.localModelName.value = s.localModelName || 'gemma:7b';
                        TranslatorApp.state.selectedFilesInfo = s.selectedFilesInfo || [];
                        TranslatorApp.state.originalJsonData = s.originalJsonData || [];
                        TranslatorApp.state.translatedJsonData = s.translatedJsonData || [];
                        TranslatorApp.state.initialTranslatedJsonData = s.initialTranslatedJsonData || [];
                        TranslatorApp.state.glossary = s.glossary || [];
                        TranslatorApp.state.activeScreen = s.activeScreen || 'setup';
                        TranslatorApp.dom.mappedIdsInput.value = s.mappedIds || '[]';
                        TranslatorApp.dom.useMappedIdsCheckbox.checked = s.useMappedIds || false;
                        TranslatorApp.state.selectedSubject = s.selectedSubject || 'None';
                        TranslatorApp.state.selectedGrade = s.selectedGrade || 'None';
                        TranslatorApp.dom.useTmCheckbox.checked = s.useTM ?? true;
                        TranslatorApp.dom.useProofreadCheckbox.checked = s.useProofread ?? false;

                        if (s.selectedProvider && !keysLoaded) {
                            const radio = document.querySelector(`input[name="apiProvider"][value="${s.selectedProvider}"]`);
                            if (radio) { radio.checked = true; TranslatorApp.events.onApiProviderChange({ target: { value: s.selectedProvider } }); }
                        }

                        TranslatorApp.ui.renderFileList();
                        TranslatorApp.subjects.updateUI();
                        
                        // Validate translation requirements after loading session
                        TranslatorApp.validateTranslationRequirements();

                        if (TranslatorApp.state.activeScreen === 'preview' && TranslatorApp.state.translatedJsonData.length > 0) {
                            TranslatorApp.ui.showScreen('preview');
                            TranslatorApp.preview.render();
                            const stats = TranslatorApp.statistics.calculate();
                            TranslatorApp.ui.renderStatistics(stats);
                            TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        } else {
                            TranslatorApp.ui.showScreen('setup');
                        }

                        TranslatorApp.ui.showAlert('تم استعادة الجلسة السابقة بنجاح.', 'success');
                    } catch (e) {
                        console.error('خطأ في استعادة الجلسة:', e);
                        TranslatorApp.ui.showAlert('حدث خطأ أثناء استعادة الجلسة السابقة. سيتم بدء جلسة جديدة.', 'error');

                        // Clear corrupted session data
                        try {
                            localStorage.removeItem('translatorSession');
                            sessionStorage.removeItem('translatorEphemeralKeys');
                        } catch (clearError) {
                            console.error('Error clearing corrupted session:', clearError);
                        }
                    }
                },
                clear() {
                    const btn = TranslatorApp.dom.newSessionBtn;
                    if (btn.dataset.confirm === 'true') {
                        try {
                            localStorage.removeItem('translatorSession');
                            sessionStorage.removeItem('translatorEphemeralKeys');
                            // Keep persistent API keys unless user explicitly wants to clear everything
                            // sessionStorage.removeItem('translatorPersistentKeys');
                            location.reload();
                        } catch (error) {
                            console.error('Session clear error:', error);
                            TranslatorApp.ui.showAlert('فشل في مسح الجلسة. يرجى إعادة تحميل الصفحة يدوياً.', 'error');
                        }
                    } else {
                        btn.dataset.confirm = 'true';
                        btn.textContent = 'هل أنت متأكد؟ انقر مجدداً';
                        btn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                        btn.classList.remove('bg-red-500', 'hover:bg-red-600');
                        setTimeout(() => {
                            btn.dataset.confirm = 'false';
                            btn.textContent = 'بدء جلسة جديدة';
                            btn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                            btn.classList.add('bg-red-500', 'hover:bg-red-600');
                        }, 3000);
                    }
                }
            },

            autoSave: {
                init() {
                    setInterval(() => {
                        try {
                            if (TranslatorApp.state.hasUnsavedChanges) {
                                TranslatorApp.session.save();
                                TranslatorApp.ui.setSaveIndicator('saving');
                                setTimeout(() => TranslatorApp.ui.setSaveIndicator('saved'), 400);
                            }
                        } catch (error) {
                            console.error('Auto-save error:', error);
                            TranslatorApp.ui.setSaveIndicator('error');
                            setTimeout(() => TranslatorApp.ui.setSaveIndicator(''), 2000);
                        }
                    }, 8000);
                }
            },

            validation: {
                validateJsonStructure(data, fileName) {
                    if (typeof data !== 'object' || data === null) {
                        throw new Error(`ملف ${fileName} يجب أن يكون كائن JSON صالح.`);
                    }
                    if (!data.hasOwnProperty('parts')) {
                        throw new Error(`ملف ${fileName} يفتقد للحقل المطلوب (parts).`);
                    }
                    if (!Array.isArray(data.parts)) {
                        throw new Error(`حقل parts في ملف ${fileName} يجب أن يكون مصفوفة.`);
                    }
                    return true;
                },
                validateApiKey(key, provider) {
                    if (!key || typeof key !== 'string') return false;
                    const trimmedKey = key.trim();
                    if (trimmedKey.length === 0) return false;

                    if (provider === 'gemini') {
                        return trimmedKey.startsWith('AIza') && trimmedKey.length > 30;
                    }
                    if (provider === 'chatgpt') {
                        return trimmedKey.startsWith('sk-') && trimmedKey.length >= 20;
                    }
                    if (provider === 'local') {
                        // For local models, we validate URL and model name separately
                        return true;
                    }
                    return false;
                },
                validateLocalModelSettings(url, modelName) {
                    if (!url || typeof url !== 'string' || url.trim().length === 0) {
                        return { valid: false, message: 'عنوان URL للخادم المحلي مطلوب.' };
                    }
                    if (!modelName || typeof modelName !== 'string' || modelName.trim().length === 0) {
                        return { valid: false, message: 'اسم النموذج المحلي مطلوب.' };
                    }
                    return { valid: true };
                }
            },

            fileHandler: {
                addFiles(files) {
                    const incoming = Array.from(files).filter(f => {
                        if (!f) return false;
                        const isJson = f.type === 'application/json' || f.name.toLowerCase().endsWith('.json');
                        if (!isJson) {
                            TranslatorApp.ui.showAlert(`الملف ${f.name} ليس ملف JSON صالح.`, 'error');
                            return false;
                        }
                        return true;
                    });

                    if (incoming.length === 0) {
                        TranslatorApp.ui.showAlert('لم يتم العثور على ملفات JSON صالحة.', 'error');
                        return;
                    }

                    incoming.forEach(file => {
                        TranslatorApp.state.fileStore.set(file.name, file);
                        if (!TranslatorApp.state.selectedFilesInfo.some(f => f.name === file.name)) {
                            TranslatorApp.state.selectedFilesInfo.push({ name: file.name, size: file.size });
                        } else {
                            const idx = TranslatorApp.state.selectedFilesInfo.findIndex(f => f.name === file.name);
                            if (idx > -1) TranslatorApp.state.selectedFilesInfo[idx].size = file.size;
                        }
                    });
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.state.hasUnsavedChanges = true;
                    TranslatorApp.ui.showAlert(`تم إضافة ${incoming.length} ملف بنجاح.`, 'success');
                },
                removeFile(index) {
                    const info = TranslatorApp.state.selectedFilesInfo[index]; if (!info) return;
                    const name = info.name;
                    TranslatorApp.state.selectedFilesInfo.splice(index, 1);
                    if (TranslatorApp.state.fileStore.has(name)) TranslatorApp.state.fileStore.delete(name);
                    const origIdx = TranslatorApp.state.originalJsonData.findIndex(d => d.name === name);
                    if (origIdx > -1) TranslatorApp.state.originalJsonData.splice(origIdx, 1);
                    const transIdx = TranslatorApp.state.translatedJsonData.findIndex(d => d.name === name);
                    if (transIdx > -1) TranslatorApp.state.translatedJsonData.splice(transIdx, 1);
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.state.hasUnsavedChanges = true;
                },
                async readFilesFromInput() {
                    if (TranslatorApp.state.selectedFilesInfo.length === 0) throw new Error("لا توجد ملفات محددة.");
                    TranslatorApp.state.originalJsonData = [];
                    const inputFiles = Array.from(TranslatorApp.dom.fileInput.files || []);

                    for (const { name } of TranslatorApp.state.selectedFilesInfo) {
                        try {
                            const file = TranslatorApp.state.fileStore.get(name) || inputFiles.find(f => f.name === name);
                            if (!file) throw new Error(`لم يتم العثور على الملف ${name}. يرجى إعادة تحديده.`);

                            const content = await file.text();
                            if (!content || content.trim() === '') {
                                throw new Error(`الملف ${name} فارغ.`);
                            }

                            let jsonData;
                            try {
                                jsonData = JSON.parse(content);
                            } catch (parseError) {
                                throw new Error(`الملف ${name} يحتوي على JSON غير صالح: ${parseError.message}`);
                            }

                            TranslatorApp.validation.validateJsonStructure(jsonData, name);
                            TranslatorApp.state.originalJsonData.push({ name, data: jsonData });

                        } catch (fileError) {
                            console.error(`Error reading file ${name}:`, fileError);
                            throw new Error(`خطأ في قراءة الملف ${name}: ${fileError.message}`);
                        }
                    }
                }
            },

            mappedIds: {
                async fetch() {
                    const count = TranslatorApp.dom.mappedIdsCount.value;
                    if (!count || count <= 0) return TranslatorApp.ui.showAlert('الرجاء إدخال عدد صحيح.', 'error');
                    const url = `https://12digit.nagwa.com/get.bulk.codes/${count}/cps/cps.system/`;
                    TranslatorApp.ui.showAlert(`جاري جلب ${count} كود...`, 'info', 3000);
                    try {
                        const response = await fetch(url, {
                            method: 'GET',
                            mode: 'cors',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            }
                        });
                        if (!response.ok) throw new Error(`فشل الطلب. حالة الخادم: ${response.status}`);
                        const data = await response.json();
                        if (Array.isArray(data)) {
                            TranslatorApp.dom.mappedIdsInput.value = JSON.stringify(data, null, 2);
                            TranslatorApp.ui.showAlert('تم جلب الأكواد بنجاح.', 'success');
                            TranslatorApp.state.hasUnsavedChanges = true;
                        } else {
                            throw new Error('البيانات ليست مصفوفة.');
                        }
                    } catch (error) {
                        console.error("Fetch Mapped IDs Error:", error);
                        TranslatorApp.ui.showAlert(`فشل الجلب بسبب قيود CORS. سيتم فتح الرابط للنسخ اليدوي.`, 'error', 8000);
                        window.open(url, '_blank');
                    }
                }
            },

            subjects: {
                data: {
                    'None': { grades: ['None'], prompt: 'Translate to Arabic accurately. Preserve HTML/LaTeX and special placeholders (e.g., __LOCK_0__, __GLOSSARY_0__). If a text contains the separator \\n<SEP>\\n, translate each segment separately and preserve the separator exactly.' },
                    'Mathematics': {
                        grades: ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 4', 'Grade 5', 'Grade 6', 'Grade 7', 'Grade 8', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'], 
                        prompts: {
                            'Grade 1': 'ترجمة أسئلة الرياضيات للصف الأول الابتدائي.\n\n**قواعد الترجمة الإلزامية:**\n1. **الأرقام والرموز:** استخدم الأرقام العربية الهندية (٠١٢٣٤٥٦٧٨٩) وترجم جميع الرموز الرياضية للعربية (مثال: x → س، y → ص، z → ع).\n2. **اتجاه النص:** اكتب جميع التعبيرات الرياضية من اليمين لليسار (RTL).\n3. **الفواصل:** استخدم الفواصل العربية (، و ؛ و ؟).\n4. **قاعدة مهمة جداً:** عند ترجمة كلمة "and" التي تأتي بين أرقام أو رموز، حوّلها إلى فاصلة عربية (،) وليس واو العطف (و).\n   - مثال: "x and y" → "س، ص" (وليس "س و ص")\n   - مثال: "٣ and ٥" → "٣، ٥" (وليس "٣ و ٥")\n5. **التسميات:** استخدم التسميات العربية (أ، ب، ج، د).\n6. احتفظ بـ \\n<SEP>\\n كما هو.\n7. استخدم مصطلحات مناسبة لعمر الطلاب.',
                            'Grade 2': 'ترجمة أسئلة الرياضيات للصف الثاني الابتدائي.\n\n**قواعد الترجمة الإلزامية:**\n1. **الأرقام والرموز:** استخدم الأرقام العربية الهندية (٠١٢٣٤٥٦٧٨٩) وترجم جميع الرموز الرياضية للعربية (مثال: x → س، y → ص، z → ع).\n2. **اتجاه النص:** اكتب جميع التعبيرات الرياضية من اليمين لليسار (RTL).\n3. **الفواصل:** استخدم الفواصل العربية (، و ؛ و ؟).\n4. **قاعدة مهمة جداً:** عند ترجمة كلمة "and" التي تأتي بين أرقام أو رموز، حوّلها إلى فاصلة عربية (،) وليس واو العطف (و).\n   - مثال: "x and y" → "س، ص" (وليس "س و ص")\n   - مثال: "٣ and ٥" → "٣، ٥" (وليس "٣ و ٥")\n5. **التسميات:** استخدم التسميات العربية (أ، ب، ج، د).\n6. احتفظ بـ \\n<SEP>\\n كما هو.\n7. استخدم مصطلحات مناسبة لعمر الطلاب.',
                            'Grade 3': 'ترجمة أسئلة الرياضيات للصف الثالث الابتدائي.\n\n**قواعد الترجمة الإلزامية:**\n1. **الأرقام والرموز:** استخدم الأرقام العربية الهندية (٠١٢٣٤٥٦٧٨٩) وترجم جميع الرموز الرياضية للعربية (مثال: x → س، y → ص، z → ع).\n2. **اتجاه النص:** اكتب جميع التعبيرات الرياضية من اليمين لليسار (RTL).\n3. **الفواصل:** استخدم الفواصل العربية (، و ؛ و ؟).\n4. **قاعدة مهمة جداً:** عند ترجمة كلمة "and" التي تأتي بين أرقام أو رموز، حوّلها إلى فاصلة عربية (،) وليس واو العطف (و).\n   - مثال: "x and y" → "س، ص" (وليس "س و ص")\n   - مثال: "٣ and ٥" → "٣، ٥" (وليس "٣ و ٥")\n5. **التسميات:** استخدم التسميات العربية (أ، ب، ج، د).\n6. احتفظ بـ \\n<SEP>\\n كما هو.\n7. استخدم مصطلحات مناسبة لعمر الطلاب.',
                            'Grade 4': 'ترجمة أسئلة الرياضيات للصف الرابع الابتدائي.\n\n**قواعد الترجمة الإلزامية:**\n1. **الأرقام والرموز:** استخدم الأرقام الإنجليزية (0123456789) واحتفظ بالرموز الرياضية بالإنجليزية (x, y, z).\n2. **اتجاه النص:** اكتب التعبيرات الرياضية من اليسار لليمين (LTR).\n3. **استثناء مهم للتعبيرات التي تحتوي على وحدات قياس:**\n   - إذا كان التعبير يحتوي على وحدة (مثل: cm, m, kg, km):\n     * اكتب التعبير من اليمين لليسار (RTL)\n     * احتفظ بالأرقام والرموز بالإنجليزية\n     * ترجم الوحدة فقط للعربية (cm → سم، m → م، kg → كجم)\n   - مثال: "5 cm" → "5 سم" (من اليمين لليسار)\n   - مثال: "x meters" → "x متر" (من اليمين لليسار)\n4. **التسميات:** استخدم التسميات العربية (أ، ب، ج، د).\n5. **الفواصل:** استخدم الفواصل العربية (، و ؛).\n6. احتفظ بـ \\n<SEP>\\n كما هو.',
                            'Grade 5': 'ترجمة أسئلة الرياضيات للصف الخامس الابتدائي.\n\n**قواعد الترجمة الإلزامية:**\n1. **الأرقام والرموز:** استخدم الأرقام الإنجليزية (0123456789) واحتفظ بالرموز الرياضية بالإنجليزية (x, y, z).\n2. **اتجاه النص:** اكتب التعبيرات الرياضية من اليسار لليمين (LTR).\n3. **استثناء مهم للتعبيرات التي تحتوي على وحدات قياس:**\n   - إذا كان التعبير يحتوي على وحدة (مثل: cm, m, kg, km):\n     * اكتب التعبير من اليمين لليسار (RTL)\n     * احتفظ بالأرقام والرموز بالإنجليزية\n     * ترجم الوحدة فقط للعربية (cm → سم، m → م، kg → كجم)\n   - مثال: "5 cm" → "5 سم" (من اليمين لليسار)\n   - مثال: "x meters" → "x متر" (من اليمين لليسار)\n4. **التسميات:** استخدم التسميات العربية (أ، ب، ج، د).\n5. **الفواصل:** استخدم الفواصل العربية (، و ؛).\n6. احتفظ بـ \\n<SEP>\\n كما هو.',
                            'Grade 6': 'ترجمة أسئلة الرياضيات للصف السادس الابتدائي.\n\n**قواعد الترجمة الإلزامية:**\n1. **الأرقام والرموز:** استخدم الأرقام الإنجليزية (0123456789) واحتفظ بالرموز الرياضية بالإنجليزية (x, y, z).\n2. **اتجاه النص:** اكتب التعبيرات الرياضية من اليسار لليمين (LTR).\n3. **استثناء مهم للتعبيرات التي تحتوي على وحدات قياس:**\n   - إذا كان التعبير يحتوي على وحدة (مثل: cm, m, kg, km):\n     * اكتب التعبير من اليمين لليسار (RTL)\n     * احتفظ بالأرقام والرموز بالإنجليزية\n     * ترجم الوحدة فقط للعربية (cm → سم، m → م، kg → كجم)\n   - مثال: "5 cm" → "5 سم" (من اليمين لليسار)\n   - مثال: "x meters" → "x متر" (من اليمين لليسار)\n4. **التسميات:** استخدم التسميات العربية (أ، ب، ج، د).\n5. **الفواصل:** استخدم الفواصل العربية (، و ؛).\n6. احتفظ بـ \\n<SEP>\\n كما هو.',
                            'Grade 7': 'ترجمة أسئلة الرياضيات للصف الأول الإعدادي.\n\n**قواعد الترجمة الإلزامية:**\n1. **الأرقام والرموز:** استخدم الأرقام الإنجليزية (0123456789) واحتفظ بالرموز الرياضية بالإنجليزية (x, y, z).\n2. **اتجاه النص:** اكتب التعبيرات الرياضية من اليسار لليمين (LTR).\n3. **استثناء مهم للتعبيرات التي تحتوي على وحدات قياس:**\n   - إذا كان التعبير يحتوي على وحدة (مثل: cm, m, kg, km):\n     * اكتب التعبير من اليمين لليسار (RTL)\n     * احتفظ بالأرقام والرموز بالإنجليزية\n     * ترجم الوحدة فقط للعربية (cm → سم، m → م، kg → كجم)\n   - مثال: "5 cm" → "5 سم" (من اليمين لليسار)\n   - مثال: "x meters" → "x متر" (من اليمين لليسار)\n4. **التسميات:** استخدم التسميات العربية (أ، ب، ج، د).\n5. **الفواصل:** استخدم الفواصل العربية (، و ؛).\n6. احتفظ بـ \\n<SEP>\\n كما هو.',
                            'Grade 8': 'ترجمة أسئلة الرياضيات للصف الثاني الإعدادي.\n\n**قواعد الترجمة الإلزامية:**\n1. **الأرقام والرموز:** استخدم الأرقام الإنجليزية (0123456789) واحتفظ بالرموز الرياضية بالإنجليزية (x, y, z).\n2. **اتجاه النص:** اكتب التعبيرات الرياضية من اليسار لليمين (LTR).\n3. **استثناء مهم للتعبيرات التي تحتوي على وحدات قياس:**\n   - إذا كان التعبير يحتوي على وحدة (مثل: cm, m, kg, km):\n     * اكتب التعبير من اليمين لليسار (RTL)\n     * احتفظ بالأرقام والرموز بالإنجليزية\n     * ترجم الوحدة فقط للعربية (cm → سم، m → م، kg → كجم)\n   - مثال: "5 cm" → "5 سم" (من اليمين لليسار)\n   - مثال: "x meters" → "x متر" (من اليمين لليسار)\n4. **التسميات:** استخدم التسميات العربية (أ، ب، ج، د).\n5. **الفواصل:** استخدم الفواصل العربية (، و ؛).\n6. احتفظ بـ \\n<SEP>\\n كما هو.',
                            'Grade 9': 'ترجمة أسئلة الرياضيات للصف الثالث الإعدادي.\n\n**قواعد الترجمة الإلزامية:**\n1. **الأرقام والرموز:** استخدم الأرقام العربية الهندية (٠١٢٣٤٥٦٧٨٩) وترجم جميع الرموز الرياضية للعربية (مثال: x → س، y → ص، z → ع).\n2. **اتجاه النص:** اكتب جميع التعبيرات الرياضية من اليمين لليسار (RTL).\n3. **الفواصل:** استخدم الفواصل العربية (، و ؛ و ؟).\n4. **قاعدة مهمة جداً:** عند ترجمة كلمة "and" التي تأتي بين أرقام أو رموز، حوّلها إلى فاصلة عربية (،) وليس واو العطف (و).\n   - مثال: "x and y" → "س، ص" (وليس "س و ص")\n   - مثال: "٣ and ٥" → "٣، ٥" (وليس "٣ و ٥")\n5. **التسميات:** استخدم التسميات العربية (أ، ب، ج، د).\n6. احتفظ بـ \\n<SEP>\\n كما هو.',
                            'Grade 10': 'ترجمة أسئلة الرياضيات للصف الأول الثانوي.\n\n**قواعد الترجمة الإلزامية:**\n1. **الأرقام والرموز:** استخدم الأرقام العربية الهندية (٠١٢٣٤٥٦٧٨٩) وترجم جميع الرموز الرياضية للعربية (مثال: x → س، y → ص، z → ع).\n2. **اتجاه النص:** اكتب جميع التعبيرات الرياضية من اليمين لليسار (RTL).\n3. **الفواصل:** استخدم الفواصل العربية (، و ؛ و ؟).\n4. **قاعدة مهمة جداً:** عند ترجمة كلمة "and" التي تأتي بين أرقام أو رموز، حوّلها إلى فاصلة عربية (،) وليس واو العطف (و).\n   - مثال: "x and y" → "س، ص" (وليس "س و ص")\n   - مثال: "٣ and ٥" → "٣، ٥" (وليس "٣ و ٥")\n5. **التسميات:** استخدم التسميات العربية (أ، ب، ج، د).\n6. احتفظ بـ \\n<SEP>\\n كما هو.',
                            'Grade 11': 'ترجمة أسئلة الرياضيات للصف الثاني الثانوي.\n\n**قواعد الترجمة الإلزامية:**\n1. **الأرقام والرموز:** استخدم الأرقام العربية الهندية (٠١٢٣٤٥٦٧٨٩) وترجم جميع الرموز الرياضية للعربية (مثال: x → س، y → ص، z → ع).\n2. **اتجاه النص:** اكتب جميع التعبيرات الرياضية من اليمين لليسار (RTL).\n3. **الفواصل:** استخدم الفواصل العربية (، و ؛ و ؟).\n4. **قاعدة مهمة جداً:** عند ترجمة كلمة "and" التي تأتي بين أرقام أو رموز، حوّلها إلى فاصلة عربية (،) وليس واو العطف (و).\n   - مثال: "x and y" → "س، ص" (وليس "س و ص")\n   - مثال: "٣ and ٥" → "٣، ٥" (وليس "٣ و ٥")\n5. **التسميات:** استخدم التسميات العربية (أ، ب، ج، د).\n6. احتفظ بـ \\n<SEP>\\n كما هو.',
                            'Grade 12': 'ترجمة أسئلة الرياضيات للصف الثالث الثانوي.\n\n**قواعد الترجمة الإلزامية:**\n1. **الأرقام والرموز:** استخدم الأرقام العربية الهندية (٠١٢٣٤٥٦٧٨٩) وترجم جميع الرموز الرياضية للعربية (مثال: x → س، y → ص، z → ع).\n2. **اتجاه النص:** اكتب جميع التعبيرات الرياضية من اليمين لليسار (RTL).\n3. **الفواصل:** استخدم الفواصل العربية (، و ؛ و ؟).\n4. **قاعدة مهمة جداً:** عند ترجمة كلمة "and" التي تأتي بين أرقام أو رموز، حوّلها إلى فاصلة عربية (،) وليس واو العطف (و).\n   - مثال: "x and y" → "س، ص" (وليس "س و ص")\n   - مثال: "٣ and ٥" → "٣، ٥" (وليس "٣ و ٥")\n5. **التسميات:** استخدم التسميات العربية (أ، ب، ج، د).\n6. احتفظ بـ \\n<SEP>\\n كما هو.'
                        }
                    },
                    'Physics': {
                        grades: ['Grades 10–12'], prompts: {
                            'Grades 10–12': 'Translate Physics questions.\nRules:\n1) Use official MoE phrasing.\n2) Use English numerals.\n3) Keep physical formulas (e.g., F=ma), variables, and units (cm, m, kg) in their original LTR format. Do NOT wrap them in any HTML tags.\n4) Keep subscripts and variables exact.\n5) If text contains \\n<SEP>\\n, translate parts separately and preserve separator.'
                        }
                    },
                    'Chemistry': {
                        grades: ['Grades 10–12'], prompts: {
                            'Grades 10–12': 'Translate Chemistry questions.\nRules:\n1) Use English numerals.\n2) Keep chemical formulas, symbols, and equations in their original LTR format. Do NOT wrap them in any HTML tags.\n3) Keep units in English abbreviations.\n4) If text contains \\n<SEP>\\n, preserve separator.'
                        }
                    },
                    'Biology': {
                        grades: ['Grades 10–12'], prompts: {
                            'Grades 10–12': 'Translate Biology questions.\nUse English numerals; Arabic labels (أ، ب، ج); translate text within figures; preserve \\n<SEP>\\n.'
                        }
                    },
                    'Science': {
                        grades: ['Grade 4', 'Grade 5', 'Grade 6', 'Grade 7', 'Grade 8', 'Grade 9'], 
                        prompts: {
                            'Grade 4': 'ترجمة أسئلة العلوم للصف الرابع.\nالقواعد:\n1) استخدم الأرقام الإنجليزية.\n2) استخدم التسميات العربية (أ، ب، ج).\n3) احتفظ بالرموز الكيميائية بالإنجليزية.\n4) استخدم مصطلحات مناسبة للعمر.\n5) احتفظ بـ \\n<SEP>\\n.',
                            'Grade 5': 'ترجمة أسئلة العلوم للصف الخامس.\nالقواعد:\n1) استخدم الأرقام الإنجليزية.\n2) استخدم التسميات العربية (أ، ب، ج).\n3) احتفظ بالرموز الكيميائية بالإنجليزية.\n4) استخدم مصطلحات مناسبة للعمر.\n5) احتفظ بـ \\n<SEP>\\n.',
                            'Grade 6': 'ترجمة أسئلة العلوم للصف السادس.\nالقواعد:\n1) استخدم الأرقام الإنجليزية.\n2) استخدم التسميات العربية (أ، ب، ج).\n3) احتفظ بالرموز الكيميائية بالإنجليزية.\n4) استخدم مصطلحات مناسبة للعمر.\n5) احتفظ بـ \\n<SEP>\\n.',
                            'Grade 7': 'ترجمة أسئلة العلوم للصف السابع.\nالقواعد:\n1) استخدم الأرقام الإنجليزية.\n2) استخدم التسميات العربية (أ، ب، ج).\n3) احتفظ بالرموز الكيميائية بالإنجليزية.\n4) استخدم مصطلحات مناسبة للعمر.\n5) احتفظ بـ \\n<SEP>\\n.',
                            'Grade 8': 'ترجمة أسئلة العلوم للصف الثامن.\nالقواعد:\n1) استخدم الأرقام الإنجليزية.\n2) استخدم التسميات العربية (أ، ب، ج).\n3) احتفظ بالرموز الكيميائية بالإنجليزية.\n4) استخدم مصطلحات مناسبة للعمر.\n5) احتفظ بـ \\n<SEP>\\n.',
                            'Grade 9': 'ترجمة أسئلة العلوم للصف التاسع.\nالقواعد:\n1) استخدم الأرقام العربية الهندية.\n2) استخدم التسميات العربية (أ، ب، ج).\n3) احتفظ بالرموز الكيميائية بالإنجليزية.\n4) استخدم مصطلحات مناسبة للعمر.\n5) احتفظ بـ \\n<SEP>\\n.'
                        }
                    },
                    'Integrated Science': {
                        grades: ['Grades 10–12'], prompts: {
                            'Grades 10–12': 'Translate Integrated Science.\nUse English numerals; Arabic labels; keep units; preserve \\n<SEP>\\n.'
                        }
                    },
                    'ICT': {
                        grades: ['Grade 4', 'Grade 5'], prompts: {
                            'Grade 4': 'Translate ICT (Grade 4).\nUse Arabic-Indic numerals; product names bilingual; preserve \\n<SEP>\\n.',
                            'Grade 5': 'Translate ICT (Grade 5).\nUse English numerals; Arabic labels; preserve \\n<SEP>\\n.'
                        }
                    },
                    'Discover': {
                        grades: ['Grades 1–3'], prompts: {
                            'Grades 1–3': 'Translate Discover (1-3).\nUse Arabic-Indic numerals; Arabic labels; preserve \\n<SEP>\\n.'
                        }
                    }
                },
                init() { this.populateSubjects(); this.updateUI(); },
                populateSubjects() {
                    TranslatorApp.dom.subjectSelect.innerHTML = '';
                    Object.keys(this.data).forEach(subject => {
                        const opt = document.createElement('option'); opt.value = subject; opt.textContent = subject;
                        TranslatorApp.dom.subjectSelect.appendChild(opt);
                    });
                },
                populateGrades(subject) {
                    TranslatorApp.dom.gradeSelect.innerHTML = '';
                    const subjectData = this.data[subject];
                    if (subjectData && subjectData.grades) subjectData.grades.forEach(grade => {
                        const opt = document.createElement('option'); opt.value = grade; opt.textContent = grade;
                        TranslatorApp.dom.gradeSelect.appendChild(opt);
                    });
                },
                onSubjectChange() { const s = TranslatorApp.dom.subjectSelect.value; this.populateGrades(s); this.updatePromptPreview(); },
                onGradeChange() { this.updatePromptPreview(); },
                updatePromptPreview() { TranslatorApp.dom.promptPreview.value = this.buildSystemPrompt(); },
                getCurrentPrompt() {
                    const subject = TranslatorApp.dom.subjectSelect.value;
                    const grade = TranslatorApp.dom.gradeSelect.value;
                    if (subject === 'None' || !this.data[subject]) return this.data['None'].prompt;
                    return this.data[subject].prompts?.[grade] || Object.values(this.data[subject].prompts)[0] || '';
                },
                buildSystemPrompt() {
                    const base = this.getCurrentPrompt();
                    const subject = TranslatorApp.dom.subjectSelect.value;
                    const grade = TranslatorApp.dom.gradeSelect.value;
                    
                    // Add subject and grade info to the prompt
                    const subjectInfo = subject !== 'None' && grade !== 'None' 
                        ? `\n\n--- معلومات المادة والجريد ---\nالمادة: ${subject}\nالجريد: ${grade}\n--- نهاية المعلومات ---\n\n`
                        : '';
                    const wantArabic = TranslatorApp.quality.wantsArabicIndicDigits(subject, grade);
                    const digitsRule = wantArabic ? 'Use Arabic-Indic numerals (٠١٢٣٤٥٦٧٨٩).' : 'Use English numerals (0123456789).';
                    
                    // Special rules for Mathematics based on grade
                    let mathRules = '';
                    if (subject === 'Mathematics') {
                        const arabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                        const englishGrades = ['Grade 4', 'Grade 5', 'Grade 6', 'Grade 7', 'Grade 8'];
                        
                        if (arabicGrades.includes(grade)) {
                            mathRules = `\n\n**قواعد خاصة للصفوف (${grade}):**
- يجب ترجمة جميع الرموز والأعداد إلى العربية (استخدام الأرقام العربية ٠١٢٣٤٥٦٧٨٩).
- يجب أن تكون اتجاهات التعبيرات الرياضية من اليمين لليسار (RTL).
- استخدام الفواصل العربية (، و ؛ و ؟).
- **مهم جداً**: عند ترجمة الأعداد والرموز، يجب تحويل كلمة "and" التي تأتي بين الرموز إلى فاصلة عربية (،) وليس إلى واو العطف (و).
  مثال: "x and y" يجب أن تصبح "س، ص" وليس "س و ص"
  مثال: "3 and 5" يجب أن تصبح "٣، ٥" وليس "٣ و ٥"\n`;
                        } else if (englishGrades.includes(grade)) {
                            mathRules = `\n\n**قواعد خاصة للصفوف (${grade}):**
- يجب عدم ترجمة الرموز والأعداد (استخدام الأرقام الإنجليزية 0123456789).
- يجب أن تكون اتجاهات التعبيرات الرياضية من اليسار لليمين (LTR).
- **استثناء مهم للتعبيرات التي تحتوي على وحدات قياس:**
  * إذا كان التعبير يحتوي على وحدة قياس (مثل cm, m, kg)، يجب:
    1. كتابة التعبير من اليمين لليسار (RTL)
    2. الاحتفاظ بالرموز والأعداد بالإنجليزية
    3. ترجمة الوحدة فقط إلى العربية
  * مثال: "5 cm" يجب أن تكتب "5 سم" (من اليمين لليسار، رقم إنجليزي ووحدة عربية)
  * مثال: "x meters" يجب أن تكتب "x متر" (من اليمين لليسار، رمز إنجليزي ووحدة عربية)
  * التعبيرات التي لا تحتوي على وحدات تبقى LTR مع أرقام ورموز إنجليزية.\n`;
                        }
                    }
                    
                    const core = [
                        // Move the critical rule to the top for emphasis
                        '**CRITICAL: Do NOT output any LaTeX commands for Arabic text. For example, the word "طالب" should be rendered exactly as "طالب" and NOT as "\\alt{\\ta}\\prime \\alt{\\alef}\\prime \\alt{\\la}\\prime \\alt{\\ba}\\prime".**',
                        '',
                        '**CRITICAL RULES FOR HTML TAGS:**',
                        '1. NEVER add any HTML tags (including <span>, <div>, <p>, etc.) to the translation.',
                        '2. NEVER wrap variables, units, or formulas in <span dir="ltr"> or any other HTML tags.',
                        '3. Keep all text content plain text without any HTML markup.',
                        '4. If you see <math-field> in the original, keep it exactly as-is with its LaTeX value.',
                        '5. DO NOT add irrelevant LaTeX inside math-field values.',
                        '6. DO NOT add English punctuation marks (?, !, .) inside <math-field> tags unless they are part of the original mathematical expression.',
                        '',
                        'Core rules:',
                        '- Do NOT add or remove content.',
                        '- Translate text content inside of HTML tags. Preserve the HTML tags themselves (e.g., <table>, <b>, <img>) and all LaTeX markup exactly as-is.',
                        '- If a text segment contains no translatable prose (e.g., it is only a table of numbers, a chemical formula, or a URL), you MUST return the original text segment completely unchanged.',
                        '- If present, keep placeholders __LOCK_n__ and __GLOSSARY_n__ unchanged.',
                        `- ${digitsRule}`,
                        `- If text contains the separator ${TranslatorApp.constants.CONTEXT_SEPARATOR}, translate each segment and preserve the separator exactly.`,
                        '- Keep the order of choices unchanged.',
                        '- Output in Arabic (MSA), formal tone.'
                    ].join('\n');
                    return `${subjectInfo}${base}${mathRules}\n\n${core}`;
                },
                async apply() {
                    TranslatorApp.state.selectedSubject = TranslatorApp.dom.subjectSelect.value;
                    TranslatorApp.state.selectedGrade = TranslatorApp.dom.gradeSelect.value;
                    TranslatorApp.state.hasUnsavedChanges = true;
                    TranslatorApp.ui.showSubjectsModal(false);
                    
                    // Show detailed success message
                    const subjectName = TranslatorApp.state.selectedSubject;
                    const gradeName = TranslatorApp.state.selectedGrade;
                    let message = `تم تطبيق: ${subjectName} - ${gradeName}`;
                    
                    if (subjectName !== 'None' && gradeName !== 'None') {
                        message += `\nسيتم جلب المصطلحات المخصصة لهذا الجريد عند الترجمة.`;
                    }
                    
                    TranslatorApp.ui.showAlert(message, 'success', 5000);
                },
                updateUI() {
                    TranslatorApp.dom.subjectSelect.value = TranslatorApp.state.selectedSubject;
                    this.populateGrades(TranslatorApp.state.selectedSubject);
                    TranslatorApp.dom.gradeSelect.value = TranslatorApp.state.selectedGrade;
                    this.updatePromptPreview();
                }
            },

            api: {
                abortController: null,
                createAbortController() { if (this.abortController) this.abortController.abort(); this.abortController = new AbortController(); return this.abortController; },
                cancel() { if (this.abortController) { this.abortController.abort(); TranslatorApp.ui.showAlert('تم إلغاء عملية الترجمة.', 'info'); TranslatorApp.state.isTranslating = false; TranslatorApp.ui.showScreen('setup'); } },

                async translateInChunks(jobs, apiKeyOrUrl, provider, localModelName = '', systemPrompt = '') {
                    const CHUNK_SIZE = TranslatorApp.constants.CHUNK_SIZE;
                    const total = jobs.length;
                    let done = 0;
                    jobs.forEach((job, idx) => job.uid = idx);

                    for (let i = 0; i < jobs.length; i += CHUNK_SIZE) {
                        const chunk = jobs.slice(i, i + CHUNK_SIZE);
                        const items = chunk.map(j => ({ id: j.uid, text: j.originalText }));
                        TranslatorApp.ui.updateProgress(`جاري الترجمة... (${Math.min(done + items.length, total)}/${total})`);
                        const outItems = await this.translateItemsBatch(items, apiKeyOrUrl, provider, localModelName, systemPrompt);
                        outItems.forEach(obj => {
                            const job = chunk.find(j => j.uid === obj.id);
                            if (!job) return;

                            // Get the translated text (which might still contain placeholders like __GLOSSARY_0__)
                            let translatedText = (obj.text || '').toString().trim();

                            // Revert the placeholders using the map we stored on the job object
                            if (job.placeholders) {
                                translatedText = TranslatorApp.remoteGlossary.revertPlaceholders(translatedText, job.placeholders);
                            }

                            // Apply post-processing (convert "and" to comma, enforce units, etc.)
                            const ctx = {
                                subject: TranslatorApp.state.selectedSubject,
                                grade: TranslatorApp.state.selectedGrade
                            };
                            translatedText = TranslatorApp.quality.postProcess(translatedText, ctx);

                            // Use the REAL original text as the key for the cache
                            const cacheKey = job.realOriginalText || job.originalText;
                            TranslatorApp.state.translationCache.set(cacheKey, translatedText);
                            
                            // Save to Translation Memory
                            if (TranslatorApp.dom.useTmCheckbox.checked) {
                                TranslatorApp.translationMemory.set(cacheKey, translatedText);
                            }
                        });
                        done += items.length;
                    }
                },

                async translateItemsBatch(items, apiKeyOrUrl, provider, localModelName = '', systemPrompt = '') {
                    const CONTEXT_SEPARATOR = TranslatorApp.constants.CONTEXT_SEPARATOR;
                    const userInstruction = `Translate all provided text to Modern Standard Arabic. Preserve HTML/LaTeX and placeholders.\nYou will receive a JSON object with an array "items": [{"id": number, "text": string}].\n- If "text" contains the exact separator "${CONTEXT_SEPARATOR}", translate each segment to Arabic and preserve the separator unchanged.\n- Preserve any HTML/LaTeX markup exactly.\n- Do NOT modify placeholders of the form __LOCK_n__ or __GLOSSARY_n__.\nReturn ONLY a valid JSON object: {"items":[{"id": number, "text": "translated"}]}.`;
                    const payload = { items };
                    const signal = this.abortController?.signal;

                    let responseText;
                    if (provider === 'gemini') responseText = await this.withGeminiJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, signal);
                    else if (provider === 'chatgpt') responseText = await this.withChatGPTJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, signal);
                    else responseText = await this.withLocalModelJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, localModelName, signal);

                    try {
                        const data = JSON.parse(responseText);
                        if (!data || !Array.isArray(data.items)) throw new Error('Invalid JSON structure from model.');
                        return data.items.map(x => ({ id: x.id, text: x.text }));
                    } catch (e) {
                        console.warn('JSON parse failed, falling back to delimiter mode.', e);
                        const BATCH_SEPARATOR = TranslatorApp.constants.BATCH_SEPARATOR;
                        const flat = items.map(it => `${it.id}:::${it.text}`).join(BATCH_SEPARATOR);
                        const fallbackPrompt = `${userInstruction}\nNow process items separated by "${BATCH_SEPARATOR}". Each starts with "<id>:::". Return ONLY valid JSON as specified.\n\n${flat}`;
                        let resp;
                        if (provider === 'gemini') resp = await this.withGeminiText(systemPrompt, fallbackPrompt, apiKeyOrUrl, signal);
                        else if (provider === 'chatgpt') resp = await this.withChatGPTText(systemPrompt, fallbackPrompt, apiKeyOrUrl, signal);
                        else resp = await this.withLocalModelText(systemPrompt, fallbackPrompt, apiKeyOrUrl, localModelName, signal);
                        const data2 = JSON.parse(resp);
                        if (!data2 || !Array.isArray(data2.items)) throw new Error('Invalid JSON structure from model (fallback).');
                        return data2.items.map(x => ({ id: x.id, text: x.text }));
                    }
                },

                async proofreadInChunks(items, apiKeyOrUrl, provider, localModelName = '') {
                    const CHUNK_SIZE = TranslatorApp.constants.CHUNK_SIZE;
                    const total = items.length;
                    let done = 0;
                    const allOut = [];
                    for (let i = 0; i < items.length; i += CHUNK_SIZE) {
                        const chunk = items.slice(i, i + CHUNK_SIZE);
                        TranslatorApp.ui.updateProgress(`تدقيق لغوي... (${Math.min(done + chunk.length, total)}/${total})`);
                        const out = await this.proofreadItemsBatch(chunk, apiKeyOrUrl, provider, localModelName);
                        allOut.push(...out);
                        done += chunk.length;
                    }
                    return allOut;
                },

                async proofreadItemsBatch(items, apiKeyOrUrl, provider, localModelName = '') {
                    const userInstruction = `You will receive JSON {"items":[{"id":number,"text":string}]}. Proofread Arabic grammar/style only.
- Do not add/remove content.
- Do not change digits, units, HTML, LaTeX, or any placeholders like __LOCK_n__ or __GLOSSARY_n__.
- Return ONLY {"items":[{"id":number,"text":"polished"}]}.`;
                    const payload = { items };
                    const signal = this.abortController?.signal;
                    let responseText;
                    if (provider === 'gemini') responseText = await this.withGeminiJSON('', userInstruction, payload, apiKeyOrUrl, signal);
                    else if (provider === 'chatgpt') responseText = await this.withChatGPTJSON('', userInstruction, payload, apiKeyOrUrl, signal);
                    else responseText = await this.withLocalModelJSON('', userInstruction, payload, apiKeyOrUrl, localModelName, signal);

                    const data = JSON.parse(responseText);
                    return data.items;
                },

                async withGeminiJSON(systemPrompt, userInstruction, payload, apiKey, signal) {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
                    const fullPrompt = `${systemPrompt || ''}\n\n${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}`;
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        signal,
                        body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }], generationConfig: { response_mime_type: "application/json" } })
                    });
                    if (!response.ok) { let err; try { err = await response.json(); } catch { } throw new Error(`Gemini API Error: ${err?.error?.message || response.statusText}`); }
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                },
                async withChatGPTJSON(systemPrompt, userInstruction, payload, apiKey, signal) {
                    const apiUrl = 'https://api.openai.com/v1/chat/completions';
                    const messages = [];
                    if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
                    messages.push({ role: 'user', content: `${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}` });
                    const candidateModels = ['gpt-4.1', 'gpt-4o-mini', 'gpt-4o', 'gpt-4.1-mini'];
                    let lastError = null;
                    for (const model of candidateModels) {
                        try {
                            const response = await fetch(apiUrl, {
                                method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, signal,
                                body: JSON.stringify({ model, messages, temperature: 0.2, response_format: { type: "json_object" } })
                            });
                            if (!response.ok) {
                                let err; try { err = await response.json(); } catch { }
                                lastError = new Error(`ChatGPT API Error: ${err?.error?.message || response.statusText}`);
                                continue;
                            }
                            const data = await response.json();
                            return data.choices?.[0]?.message?.content || '';
                        } catch (e) { lastError = e; }
                    }
                    throw lastError || new Error('ChatGPT API Error: Unable to complete request');
                },
                async withLocalModelJSON(systemPrompt, userInstruction, payload, url, modelName, signal) {
                    const fullPrompt = `${systemPrompt || ''}\n\n${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}\n\nReturn ONLY JSON.`;
                    const response = await fetch(url, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                        body: JSON.stringify({ model: modelName, prompt: fullPrompt, system: '', stream: false, format: 'json' })
                    });
                    if (!response.ok) throw new Error(`Local server error: ${response.status} ${response.statusText}`);
                    const data = await response.json();
                    return data.response || '';
                },
                async withGeminiText(systemPrompt, userPrompt, apiKey, signal) {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
                    const fullPrompt = systemPrompt ? `${systemPrompt}\n\n---\n\n${userPrompt}` : userPrompt;
                    const response = await fetch(apiUrl, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                        body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }] })
                    });
                    if (!response.ok) { const err = await response.json(); throw new Error(`Gemini API Error: ${err.error?.message || response.statusText}`); }
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                },
                async withChatGPTText(systemPrompt, userPrompt, apiKey, signal) {
                    const apiUrl = 'https://api.openai.com/v1/chat/completions';
                    const messages = []; if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
                    messages.push({ role: 'user', content: userPrompt });
                    const candidateModels = ['gpt-4.1', 'gpt-4o-mini', 'gpt-4o', 'gpt-4.1-mini'];
                    let lastError = null;
                    for (const model of candidateModels) {
                        try {
                            const response = await fetch(apiUrl, {
                                method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, signal,
                                body: JSON.stringify({ model, messages, temperature: 0.2 })
                            });
                            if (!response.ok) { const err = await response.json(); lastError = new Error(`ChatGPT API Error: ${err.error?.message || response.statusText}`); continue; }
                            const data = await response.json();
                            return data.choices?.[0]?.message?.content || '';
                        } catch (e) { lastError = e; }
                    }
                    throw lastError || new Error('ChatGPT API Error: Unable to complete request');
                },
                async withLocalModelText(systemPrompt, userPrompt, url, modelName, signal) {
                    const response = await fetch(url, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                        body: JSON.stringify({ model: modelName, prompt: userPrompt, system: systemPrompt, stream: false })
                    });
                    if (!response.ok) throw new Error(`Local server error: ${response.status} ${response.statusText}`);
                    const data = await response.json();
                    return data.response || '';
                }
            },

            history: {
                stack: [],
                currentIndex: -1,
                timeout: null,


                init() {
                    this.updateButtons();
                },

                push(state) {
                    const MAX_HISTORY = TranslatorApp.constants.HISTORY_MAX;
                    if (this.timeout) clearTimeout(this.timeout);

                    this.timeout = setTimeout(() => {
                        try {
                            this.stack = this.stack.slice(0, this.currentIndex + 1);
                            const snapshot = (window.structuredClone ? structuredClone(state) : JSON.parse(JSON.stringify(state)));
                            this.stack.push(snapshot);

                            if (this.stack.length > MAX_HISTORY) {
                                this.stack.shift();
                            } else {
                                this.currentIndex++;
                            }

                            this.updateButtons();
                        } catch (error) {
                            console.error('History push error:', error);
                            // Reset history if there's an error
                            this.stack = [];
                            this.currentIndex = -1;
                            this.updateButtons();
                        }
                    }, 400);
                },

                undo() {
                    if (this.currentIndex > 0) {
                        this.currentIndex--;
                        this.restore(this.stack[this.currentIndex]);
                    }
                },

                redo() {
                    if (this.currentIndex < this.stack.length - 1) {
                        this.currentIndex++;
                        this.restore(this.stack[this.currentIndex]);
                    }
                },

                restore(state) {
                    try {
                        TranslatorApp.state.translatedJsonData = (window.structuredClone ? structuredClone(state) : JSON.parse(JSON.stringify(state)));
                        TranslatorApp.preview.render();
                        this.updateButtons();
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('History restore error:', error);
                        TranslatorApp.ui.showAlert('فشل في استعادة الحالة السابقة.', 'error');
                    }
                },

                updateButtons() {
                    TranslatorApp.dom.undoBtn.disabled = this.currentIndex <= 0;
                    TranslatorApp.dom.redoBtn.disabled = this.currentIndex >= this.stack.length - 1;
                },

            },
            // استبدال الدالة بالكامل بالنسخة الجديدة (تحليل HTML وتوليد مهام لعُقد النص)
            async startTranslationProcess() {
                const apiProvider = document.querySelector('input[name="apiProvider"]:checked').value;
                let apiKeyOrUrl;
                let localModelName;
            
                try {
                    if (apiProvider === 'gemini') {
                        apiKeyOrUrl = this.dom.geminiKeyInput.value.trim();
                        if (!this.validation.validateApiKey(apiKeyOrUrl, 'gemini')) {
                            return this.ui.showAlert(`مفتاح API لـ Gemini غير صالح.`, 'error');
                        }
                    } else if (apiProvider === 'chatgpt') {
                        apiKeyOrUrl = this.dom.chatgptKeyInput.value.trim();
                        if (!this.validation.validateApiKey(apiKeyOrUrl, 'chatgpt')) {
                            return this.ui.showAlert(`مفتاح API لـ ChatGPT غير صالح.`, 'error');
                        }
                    } else if (apiProvider === 'local') {
                        apiKeyOrUrl = this.dom.localModelUrl.value.trim();
                        localModelName = this.dom.localModelName.value.trim();
                        const validation = this.validation.validateLocalModelSettings(apiKeyOrUrl, localModelName);
                        if (!validation.valid) {
                            return this.ui.showAlert(validation.message, 'error');
                        }
                    } else {
                        return this.ui.showAlert('يرجى اختيار مزود خدمة صالح.', 'error');
                    }
            
                    if (this.state.selectedFilesInfo.length === 0) {
                        return this.ui.showAlert('اختر ملف JSON واحد على الأقل.', 'error');
                    }
                } catch (validationError) {
                    return this.ui.showAlert('خطأ في التحقق من صحة البيانات المدخلة.', 'error');
                }
            
                this.ui.showScreen('progress');
                this.dom.translateBtn.disabled = true;
                this.state.translationCache.clear();
                this.state.startTime = Date.now();
                this.api.createAbortController();
                this.state.isTranslating = true;
            
                try {
                    this.ui.updateProgress('جاري قراءة الملفات...');
                    await this.fileHandler.readFilesFromInput();
                    this.state.translatedJsonData = JSON.parse(JSON.stringify(this.state.originalJsonData));
                    this.state.initialTranslatedJsonData = [];
            
                    const allJobs = [];
                    const parsedDataMap = new Map();
            
                    const processField = (htmlString, basePointer) => {
                        if (!htmlString || typeof htmlString !== 'string') return;
                        const { jobs, parsedBody } = this.utils.parseHtmlAndCreateJobs(htmlString, basePointer);
                        allJobs.push(...jobs);
                        const mapKey = JSON.stringify(basePointer);
                        parsedDataMap.set(mapKey, parsedBody);
                    };
                    
                    this.ui.updateProgress('جاري تحليل المحتوى وتجهيز النصوص...');
            
                    this.state.originalJsonData.forEach((file, fileIndex) => {
                        // Process statement field
                        processField(file.data.statement, { fileIndex, key: 'statement' });
                        
                        // Process parts
                        file.data.parts?.forEach((part, partIndex) => {
                            const originalPart = TranslatorApp.state.originalJsonData[fileIndex].data.parts[partIndex];
                            
                            // Process stem field
                            processField(part.stem, { fileIndex, partIndex, key: 'stem' });
            
                            // Process answer field
                            if (originalPart.answer) {
                                if (Array.isArray(originalPart.answer)) {
                                    originalPart.answer.forEach((answerItem, answerIndex) => {
                                        processField(answerItem, { fileIndex, partIndex, answerIndex, key: 'answer', isArray: true });
                                    });
                                } else if (typeof originalPart.answer === 'string') {
                                    processField(originalPart.answer, { fileIndex, partIndex, key: 'answer' });
                                } else if (typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('value')) {
                                    processField(originalPart.answer.value, { fileIndex, partIndex, key: 'answer', subKey: 'value' });
                                } else if (typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('key') && originalPart.answer.hasOwnProperty('value') && originalPart.answer.hasOwnProperty('unit')) {
                                    // Special case for a more complex object answer type
                                    processField(originalPart.answer.key, { fileIndex, partIndex, key: 'answer', subKey: 'key' });
                                    processField(originalPart.answer.value, { fileIndex, partIndex, key: 'answer', subKey: 'value' });
                                    // Translate unit directly using unitsMap instead of sending to AI
                                    const originalUnit = originalPart.answer.unit || '';
                                    const translatedUnit = TranslatorApp.quality.unitsMap[originalUnit.toLowerCase()] || originalUnit;
                                    this.state.translatedJsonData[fileIndex].data.parts[partIndex].answer.unit = translatedUnit;
                                }
                            }
                            
                            // Process choices
                            originalPart.choices?.forEach((choice, choiceIndex) => {
                                processField(choice.html_content, { fileIndex, partIndex, choiceIndex, key: 'choice' });
                            });
                            
                            // Process gap_text_keys
                            if (originalPart.gap_text_keys) {
                                originalPart.gap_text_keys.forEach((keyItem, keyIndex) => {
                                    processField(keyItem.value, { fileIndex, partIndex, key: 'gap_text_keys', keyIndex: keyIndex, subKey: 'value' });
                                });
                            }
                            
                            // Process ai.guidelines (for string type questions)
                            if (originalPart.ai && originalPart.ai.guidelines && Array.isArray(originalPart.ai.guidelines)) {
                                originalPart.ai.guidelines.forEach((guideline, guidelineIndex) => {
                                    // Translate student_answer
                                    if (guideline.student_answer && typeof guideline.student_answer === 'string') {
                                        processField(guideline.student_answer, { fileIndex, partIndex, key: 'ai_guideline', guidelineIndex, subKey: 'student_answer' });
                                    }
                                    // Translate comment
                                    if (guideline.comment && typeof guideline.comment === 'string') {
                                        processField(guideline.comment, { fileIndex, partIndex, key: 'ai_guideline', guidelineIndex, subKey: 'comment' });
                                    }
                                });
                            }
                        });
                    });
                    
                    const uniqueJobs = [];
                    const seen = new Set();
                    for (const job of allJobs) {
                        if (!seen.has(job.originalText)) {
                            seen.add(job.originalText);
                            uniqueJobs.push(job);
                        }
                    }
                    
                    // Check Translation Memory first
                    let tmHits = 0;
                    let jobsToTranslate = [];
                    
                    if (this.dom.useTmCheckbox.checked) {
                        this.ui.updateProgress('جاري فحص ذاكرة الترجمة...');
                        const ctx = {
                            subject: this.state.selectedSubject,
                            grade: this.state.selectedGrade
                        };
                        uniqueJobs.forEach(job => {
                            const tmEntry = this.translationMemory.get(job.originalText);
                            if (tmEntry && tmEntry.translation) {
                                // Use cached translation and apply post-processing for current context
                                let processedTranslation = this.quality.postProcess(tmEntry.translation, ctx);
                                this.state.translationCache.set(job.originalText, processedTranslation);
                                tmHits++;
                            } else {
                                // Need to translate this
                                jobsToTranslate.push(job);
                            }
                        });
                        
                        if (tmHits > 0) {
                            console.log(`TM hits: ${tmHits}/${uniqueJobs.length}`);
                            this.ui.updateProgress(`تم استرجاع ${tmHits} ترجمة من الذاكرة...`);
                        }
                    } else {
                        jobsToTranslate = uniqueJobs;
                    }
                    
                    this.ui.updateProgress('جاري جلب المصطلحات المعتمدة...');
                    const allTextsForGlossary = jobsToTranslate.map(j => j.originalText);
                    await this.remoteGlossary.fetchApproved(this.state.selectedSubject, this.state.selectedGrade, allTextsForGlossary);
            
                    jobsToTranslate.forEach(job => {
                        const { modifiedText, placeholders } = this.remoteGlossary.applyWithPlaceholders(job.originalText);
                        job.realOriginalText = job.originalText;
                        job.originalText = modifiedText;
                        job.placeholders = placeholders;
                    });
            
                    if (jobsToTranslate.length > 0) {
                        this.ui.updateProgress(`جاري ترجمة ${jobsToTranslate.length} نص جديد...`);
                        const systemPrompt = this.subjects.buildSystemPrompt();
                        await this.api.translateInChunks(jobsToTranslate, apiKeyOrUrl, apiProvider, localModelName, systemPrompt);
                    }
            
                    this.ui.updateProgress('جاري إعادة بناء المحتوى المترجم...');
            
                    allJobs.forEach(job => {
                        const cacheKey = job.realOriginalText || job.originalText;
                        let translatedText = this.state.translationCache.get(cacheKey);
                        if (translatedText && job.domNode) {
                            translatedText = this.quality.cleanLatexArabic(translatedText);
                            job.domNode.nodeValue = translatedText;
                        }
                    });
            
                    for (const [mapKey, parsedBody] of parsedDataMap.entries()) {
                        const pointer = JSON.parse(mapKey);
                        const finalHtml = parsedBody.innerHTML;
                        let cleanedHtml = TranslatorApp.quality.cleanLatexArabic(finalHtml);
                        // Ensure RTL direction for Arabic content
                        cleanedHtml = TranslatorApp.quality.ensureRTLDirection(cleanedHtml);
                        const { fileIndex, partIndex, choiceIndex, key, keyIndex, subKey, answerIndex, isArray } = pointer;
                        let target = this.state.translatedJsonData[fileIndex].data;
            
                        if (key === 'statement') {
                            target.statement = cleanedHtml;
                        } else if (key === 'stem') {
                            target.parts[partIndex].stem = cleanedHtml;
                        } else if (key === 'answer') {
                            if (isArray) { // Check if the original was an array
                                if (target.parts?.[partIndex]?.answer && target.parts[partIndex].answer.length > answerIndex) {
                                     target.parts[partIndex].answer[answerIndex] = cleanedHtml;
                                }
                            } else if (subKey === 'value') {
                                target.parts[partIndex].answer.value = cleanedHtml;
                            } else if (subKey === 'key') {
                                 target.parts[partIndex].answer.key = cleanedHtml;
                            } else if (subKey === 'unit') {
                                 target.parts[partIndex].answer.unit = cleanedHtml;
                            } else {
                                target.parts[partIndex].answer = cleanedHtml;
                            }
                        } else if (key === 'choice') {
                            target.parts[partIndex].choices[choiceIndex].html_content = cleanedHtml;
                        } else if (key === 'gap_text_keys' && subKey === 'value') {
                            if (target.parts[partIndex].gap_text_keys && target.parts[partIndex].gap_text_keys[keyIndex]) {
                                target.parts[partIndex].gap_text_keys[keyIndex].value = cleanedHtml;
                            }
                        } else if (key === 'ai_guideline') {
                            // Handle ai.guidelines translation
                            const guidelineIndex = pointer.guidelineIndex;
                            if (target.parts[partIndex].ai && target.parts[partIndex].ai.guidelines && target.parts[partIndex].ai.guidelines[guidelineIndex]) {
                                if (subKey === 'student_answer') {
                                    target.parts[partIndex].ai.guidelines[guidelineIndex].student_answer = cleanedHtml;
                                } else if (subKey === 'comment') {
                                    target.parts[partIndex].ai.guidelines[guidelineIndex].comment = cleanedHtml;
                                }
                            }
                        }
                    }
            
                    this.state.activeScreen = 'preview';
                    // Save initial translation for diff comparison
                    this.state.initialTranslatedJsonData = JSON.parse(JSON.stringify(this.state.translatedJsonData));
                    this.history.push(this.state.translatedJsonData);
                    
                    // Save Translation Memory to localStorage
                    if (this.dom.useTmCheckbox.checked) {
                        this.translationMemory.save();
                        this.translationMemory.updateUI();
                    }
                    
                    this.session.save();
                    this.ui.showScreen('preview');
                    this.preview.render();
                    const stats = this.statistics.calculate();
                    this.ui.renderStatistics(stats);
                    
                    // Show success message with TM stats
                    let successMessage = 'تمت الترجمة بنجاح';
                    if (this.dom.useTmCheckbox.checked && tmHits > 0) {
                        successMessage += ` (تم استخدام ${tmHits} ترجمة محفوظة)`;
                    }
                    this.ui.showAlert(successMessage, 'success');
            
                } catch (error) {
                    if (error?.name !== 'AbortError') {
                        console.error('Translation process failed:', error);
                        this.ui.showAlert(error.message, 'error');
                        this.ui.showScreen('setup');
                    }
                } finally {
                    this.dom.translateBtn.disabled = false;
                    this.state.isTranslating = false;
                }
            },

            statistics: {
                calculate() {
                    let totalTexts = 0, totalWords = 0;
                    const count = (text) => {
                        if (text && typeof text === 'string') {
                            totalTexts++;
                            const div = document.createElement('div'); div.innerHTML = text;
                            totalWords += (div.textContent || div.innerText || "").split(/\s+/).filter(Boolean).length;
                        }
                    };
                    TranslatorApp.state.originalJsonData.forEach(file => {
                        count(file.data.statement);
                        file.data.parts?.forEach(part => {
                            count(part.stem);
                            if (typeof part.answer === 'string') count(part.answer);
                            part.choices?.forEach(choice => count(choice.html_content));
                            part.gap_text_keys?.forEach(keyItem => count(keyItem.value));
                        });
                    });
                    const timeElapsed = TranslatorApp.state.startTime ? ((Date.now() - TranslatorApp.state.startTime) / 1000).toFixed(1) : 0;
                    return { totalFiles: TranslatorApp.state.selectedFilesInfo.length, totalTexts, totalWords, timeElapsed };
                }
            },

            ui: {
                showScreen(screen) {
                    try {
                        TranslatorApp.state.activeScreen = screen;
                        ['setupSection', 'progressContainer', 'previewSection', 'analyticsSection'].forEach(id => {
                            try {
                                TranslatorApp.dom[id]?.classList.add('hidden');
                            } catch (error) {
                                console.warn(`Error hiding ${id}:`, error);
                            }
                        });

                        if (screen === 'setup') {
                            try {
                                TranslatorApp.dom.setupSection.classList.remove('hidden');
                            } catch (error) {
                                console.warn('Error showing setup section:', error);
                            }
                        }
                        if (screen === 'progress') {
                            try {
                                TranslatorApp.dom.progressContainer.classList.remove('hidden');
                            } catch (error) {
                                console.warn('Error showing progress container:', error);
                            }
                        }
                        if (screen === 'preview') {
                            try {
                                TranslatorApp.dom.previewSection.classList.remove('hidden');
                                TranslatorApp.dom.analyticsSection.classList.remove('hidden');
                            } catch (error) {
                                console.warn('Error showing preview section:', error);
                            }
                        }

                        // Reset any error states
                        if (screen === 'setup') {
                            try {
                                TranslatorApp.dom.translateBtn.disabled = false;
                                TranslatorApp.state.isTranslating = false;
                            } catch (error) {
                                console.warn('Error resetting translate button:', error);
                            }
                        }
                    } catch (error) {
                        console.error('Show screen error:', error);
                    }
                },
                updateProgress(text) {
                    try {
                        TranslatorApp.dom.progressText.textContent = text;
                    } catch (error) {
                        console.error('Update progress error:', error);
                    }
                },
                showAlert(message, type = 'error', duration = 5000) {
                    const colors = { error: 'bg-red-500', success: 'bg-green-500', info: 'bg-blue-500', warning: 'bg-yellow-500' };
                    const alertBox = document.createElement('div');
                    alertBox.className = `alert flex justify-between items-center text-white p-4 rounded-lg shadow-xl ${colors[type] || 'bg-gray-500'}`;

                    // Sanitize message to prevent XSS
                    const sanitizedMessage = TranslatorApp.security.sanitize(message);
                    alertBox.innerHTML = `<span>${sanitizedMessage}</span><button class="mr-2 text-xl font-bold" aria-label="إغلاق">&times;</button>`;

                    alertBox.querySelector('button').onclick = () => alertBox.remove();
                    TranslatorApp.dom.alertContainer.appendChild(alertBox);

                    // Auto-remove after duration
                    if (duration) {
                        setTimeout(() => {
                            alertBox.classList.add('fade-out');
                            alertBox.addEventListener('transitionend', () => alertBox.remove());
                        }, duration);
                    }

                    // Log to console for debugging
                    console.log(`[${type.toUpperCase()}] ${message}`);
                },
                renderFileList() {
                    try {
                        const { fileList } = TranslatorApp.dom;
                        fileList.innerHTML = '';
                        if (TranslatorApp.state.selectedFilesInfo.length === 0) return;
                        const ul = document.createElement('ul');
                        ul.className = 'my-4 space-y-2';
                        TranslatorApp.state.selectedFilesInfo.forEach((fileInfo, index) => {
                            const li = document.createElement('li');
                            li.className = 'flex justify-between items-center p-2 rounded-lg';
                            li.style.backgroundColor = 'color-mix(in srgb, var (--primary-color) 5%, var(--card-bg))';
                            li.innerHTML = `<span class="font-medium">${TranslatorApp.security.sanitize(fileInfo.name)}</span><button data-index="${index}" class="remove-file-btn text-red-500 hover:text-red-700 font-bold text-xl" aria-label="إزالة">&times;</button>`;
                            ul.appendChild(li);
                        });
                        fileList.appendChild(ul);
                        fileList.querySelectorAll('.remove-file-btn').forEach(btn => {
                            btn.onclick = (e) => {
                                try {
                                    TranslatorApp.fileHandler.removeFile(parseInt(btn.dataset.index));
                                } catch (error) {
                                    console.error('Remove file error:', error);
                                    TranslatorApp.ui.showAlert('فشل في إزالة الملف.', 'error');
                                }
                            };
                        });
                    } catch (error) {
                        console.error('Render file list error:', error);
                        TranslatorApp.ui.showAlert('فشل في عرض قائمة الملفات.', 'error');
                    }
                },
                showGlossaryModal(show) {
                    try {
                        TranslatorApp.dom.glossaryModal.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show glossary modal error:', error);
                    }
                },
                showMappedIdsModal(show) {
                    try {
                        TranslatorApp.dom.mappedIdsModal.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show mapped IDs modal error:', error);
                    }
                },
                showSubjectsModal(show) {
                    try {
                        TranslatorApp.dom.subjectsModal.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show subjects modal error:', error);
                    }
                },
                showModal(id, show) {
                    try {
                        const el = TranslatorApp.dom[id];
                        if (el) el.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show modal error:', error);
                    }
                },
                renderStatistics(stats) {
                    try {
                        const { statsContainer } = TranslatorApp.dom;
                        statsContainer.innerHTML = '';
                        const map = {
                            'إجمالي الملفات': stats.totalFiles,
                            'إجمالي النصوص': stats.totalTexts,
                            'إجمالي الكلمات': stats.totalWords,
                            'زمن الترجمة (ث)': stats.timeElapsed
                        };
                        Object.entries(map).forEach(([label, value]) => {
                            const card = document.createElement('div');
                            card.className = 'p-4 rounded-lg';
                            card.style.backgroundColor = 'color-mix(in srgb, var (--primary-color) 10%, var (--card-bg))';
                            card.innerHTML = `<div class="text-2xl font-bold" style="color: var (--primary-color);">${value}</div><div class="text-sm" style="color: var (--secondary-text);">${label}</div>`;
                            statsContainer.appendChild(card);
                        });
                    } catch (error) {
                        console.error('Render statistics error:', error);
                    }
                },
                setSaveIndicator(state) {
                    try {
                        const el = TranslatorApp.dom.saveIndicator;
                        if (!el) return;

                        if (state === 'saving') {
                            el.textContent = 'جاري الحفظ...';
                            el.classList.remove('saved', 'error');
                        }
                        else if (state === 'saved') {
                            el.textContent = '✓ محفوظ';
                            el.classList.add('saved');
                            el.classList.remove('error');
                            setTimeout(() => {
                                el.textContent = '—';
                                el.classList.remove('saved');
                            }, 2000);
                        }
                        else if (state === 'error') {
                            el.textContent = '✗ خطأ في الحفظ';
                            el.classList.add('error');
                            el.classList.remove('saved');
                        }
                        else {
                            el.textContent = '—';
                            el.classList.remove('saved', 'error');
                        }
                    } catch (error) {
                        console.error('Save indicator error:', error);
                    }
                }
            },

            preview: {
                dmp: new diff_match_patch(),

                processBlankTags(htmlString) {
                    try {
                        if (!htmlString || typeof htmlString !== 'string') return htmlString;
                        
                        let processed = htmlString;
                        
                        // Handle data-node-type="blank-line" tags (like in the JSON file)
                        processed = processed.replace(
                            /<span\s+data-node-type=["']blank-line["'][^>]*>(.*?)<\/span>/gi,
                            (match, content) => {
                                // Convert &nbsp; to actual space and create a blank slot
                                const blankContent = content.replace(/&nbsp;/g, ' ').trim() || '___';
                                // Escape quotes in data-blank attribute
                                const escapedBlank = blankContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<span class="blank-slot rtl-auto" data-blank="${escapedBlank}" dir="rtl">${blankContent}</span>`;
                            }
                        );
                        
                        // Handle data-node-type="blank" tags
                        processed = processed.replace(
                            /<span\s+data-node-type=["']blank["'][^>]*>(.*?)<\/span>/gi,
                            (match, content) => {
                                const blankContent = content.replace(/&nbsp;/g, ' ').trim() || '___';
                                const escapedBlank = blankContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<span class="blank-slot rtl-auto" data-blank="${escapedBlank}" dir="rtl">${blankContent}</span>`;
                            }
                        );
                        
                        // Handle any span with data-node-variation="space"
                        processed = processed.replace(
                            /<span[^>]*data-node-variation=["']space["'][^>]*>(.*?)<\/span>/gi,
                            (match, content) => {
                                const blankContent = content.replace(/&nbsp;/g, ' ').trim() || '___';
                                const escapedBlank = blankContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<span class="blank-slot rtl-auto" data-blank="${escapedBlank}" dir="rtl">${blankContent}</span>`;
                            }
                        );
                        
                        // Handle any other blank-related attributes
                        processed = processed.replace(
                            /<span[^>]*data-blank[^>]*>(.*?)<\/span>/gi,
                            (match, content) => {
                                const blankContent = content.replace(/&nbsp;/g, ' ').trim() || '___';
                                const escapedBlank = blankContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<span class="blank-slot rtl-auto" data-blank="${escapedBlank}" dir="rtl">${blankContent}</span>`;
                            }
                        );
                        
                        return processed;
                    } catch (error) {
                        console.error('Process blank tags error:', error);
                        return htmlString;
                    }
                },
                
                processMathFieldTags(htmlString) {
                    try {
                        if (!htmlString || typeof htmlString !== 'string') return htmlString;
                        
                        let processed = htmlString;
                        
                        // First, remove ONLY LexicalTheme__math wrapper spans
                        // Be very specific to avoid removing other spans
                        processed = processed.replace(
                            /<span\s+class=["']LexicalTheme__math--inline["']\s+data-node-type=["']math["']\s+data-node-variation=["']inline["'][^>]*>(<math-field[^>]*>.*?<\/math-field>)<\/span>/gi,
                            '$1'
                        );
                        
                        // Remove ALL dir="ltr" spans FIRST - these are AI-generated and should be removed
                        // This is the most common issue, so handle it first
                        const beforeDirRemoval = processed;
                        processed = processed.replace(
                            /<span\s+dir=["']ltr["'][^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // Debug: log if we removed any dir="ltr" spans
                        if (beforeDirRemoval !== processed) {
                            console.log('Removed dir="ltr" spans:', beforeDirRemoval, '→', processed);
                        }
                        
                        // Also handle spans with dir="ltr" and other attributes
                        processed = processed.replace(
                            /<span[^>]*dir=["']ltr["'][^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // Remove white-space: pre-wrap spans (they're just wrappers for text)
                        processed = processed.replace(
                            /<span[^>]*style=["'][^"']*white-space:\s*pre-wrap[^"']*["'][^>]*>([^<]+)<\/span>/gi,
                            '$1'
                        );
                        
                        // Remove LexicalTheme__paragraph wrapper
                        processed = processed.replace(
                            /<p\s+class=["']LexicalTheme__paragraph["'][^>]*>(.*?)<\/p>/gi,
                            '$1'
                        );
                        
                        // Fix malformed tags like "yspan>", "xspan>", "gspan>" - these are broken AI output
                        processed = processed.replace(
                            /(\w+)span>/gi,
                            '$1'
                        );
                        
                        // Fix any remaining broken span tags
                        processed = processed.replace(
                            /<span[^>]*>([^<]*)span>/gi,
                            '$1'
                        );
                        
                        // Additional fix for specific malformed patterns
                        processed = processed.replace(
                            /(\d+\s*\w+)span>/gi,
                            '$1'
                        );
                        
                        // Fix common malformed patterns like "8 gspan>"
                        processed = processed.replace(
                            /(\d+\s*[a-zA-Z]+)span>/gi,
                            '$1'
                        );
                        
                        // Fix any remaining "span>" at the end of words
                        processed = processed.replace(
                            /([a-zA-Z0-9]+)span>/gi,
                            '$1'
                        );
                        
                        // Remove any remaining empty or unnecessary spans
                        processed = processed.replace(
                            /<span[^>]*><\/span>/gi,
                            ''
                        );
                        
                        // Clean up any orphaned closing tags
                        processed = processed.replace(
                            /<\/span>/gi,
                            ''
                        );
                        
                        // Final cleanup: remove any remaining spans with dir="ltr" (multiple passes to be sure)
                        processed = processed.replace(
                            /<span[^>]*dir\s*=\s*["']ltr["'][^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // Handle edge cases where quotes might be different
                        processed = processed.replace(
                            /<span[^>]*dir\s*=\s*['"]ltr['"][^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // NUCLEAR OPTION: Remove ALL remaining spans completely (no exceptions)
                        // This ensures absolutely NO span tags appear anywhere
                        const beforeNuclear = processed;
                        processed = processed.replace(
                            /<span[^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // Debug: log nuclear option results
                        if (beforeNuclear !== processed) {
                            console.log('NUCLEAR: Removed remaining spans:', beforeNuclear, '→', processed);
                        }
                        
                        // Remove any remaining opening span tags
                        processed = processed.replace(
                            /<span[^>]*>/gi,
                            ''
                        );
                        
                        // Remove any remaining closing span tags
                        processed = processed.replace(
                            /<\/span>/gi,
                            ''
                        );
                        
                        // Handle existing math-field tags from JSON
                        // Convert them to proper format with all necessary attributes
                        processed = processed.replace(
                            /<math-field([^>]*)>(.*?)<\/math-field>/gi,
                            (match, attrs, content) => {
                                // Extract value attribute
                                const valueMatch = attrs.match(/value=["']([^"']*)["']/i);
                                let value = valueMatch ? valueMatch[1] : content;
                                
                                // Clean up value - handle escaped characters and special cases
                                value = value.replace(/\\displaystyle\{([^}]+)\}/g, '$1')
                                           .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '\\frac{$1}{$2}')
                                           .replace(/​/g, ''); // Remove zero-width spaces
                                
                                // Extract or set default-mode
                                const modeMatch = attrs.match(/default-mode=["']([^"']*)["']/i);
                                const mode = modeMatch ? modeMatch[1] : 'inline-math';
                                
                                // Check if read-only (from source)
                                const isReadOnly = attrs.includes('read-only');
                                const readOnlyAttr = isReadOnly ? 'read-only="true"' : '';
                                
                                // Create proper math-field with all attributes
                                // Always force LTR for math content
                                // Escape the value properly for HTML attribute
                                const escapedValue = value.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<math-field default-mode="${mode}" value="${escapedValue}" ${readOnlyAttr} virtual-keyboard-mode="onfocus" use-shared-virtual-keyboard dir="ltr" style="direction: ltr; unicode-bidi: embed;"></math-field>`;
                            }
                        );
                        
                        return processed;
                    } catch (error) {
                        console.error('Process math field tags error:', error);
                        return htmlString;
                    }
                },

                renderContentWithMath(htmlString) {
                    try {
                        if (typeof htmlString !== 'string' || !htmlString) {
                            return '<div class="content-root" dir="rtl">&nbsp;</div>';
                        }
                        const cleanedHtml = htmlString.replace(/R\s*(\d+)/g, 'والباقي $1');

                        // 1. First, handle blank tags and math-field tags before sanitization
                        let processedHtml = this.processBlankTags(cleanedHtml);
                        processedHtml = this.processMathFieldTags(processedHtml);
                        
                        // 2. Sanitize the processed HTML (but keep math-field tags)
                        let sanitizedHtml = TranslatorApp.security.sanitize(processedHtml);
                        
                        // 3. Create a temporary DOM element to parse the sanitized HTML
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = sanitizedHtml;
                
                        // 3. Use a TreeWalker to process all nodes and convert LaTeX
                        const walker = document.createTreeWalker(
                            tempDiv,
                            NodeFilter.SHOW_TEXT,
                            null,
                            false
                        );
                        const nodesToReplace = [];
                        let node;
                        while ((node = walker.nextNode())) {
                            let textContent = node.textContent;

                            // Find and replace LaTeX expressions
                            const latexRegex = /(\$\$[\s\S]*?\$\$|\$[^$]*\$)/g;
                            const parts = textContent.split(latexRegex);
                
                            if (parts.length > 1) {
                                const fragment = document.createDocumentFragment();
                                parts.forEach(part => {
                                    const isDisplayMode = part.startsWith('$$') && part.endsWith('$$');
                                    const isInlineMode = part.startsWith('$') && part.endsWith('$');
                
                                    if (isDisplayMode || isInlineMode) {
                                        const latex = part.slice(isDisplayMode ? 2 : 1, isDisplayMode ? -2 : -1);

                                        const mf = document.createElement('math-field');
                                        mf.setAttribute('default-mode', isDisplayMode ? 'math' : 'inline-math');
                                        mf.setAttribute('value', latex);
                                        mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                        mf.setAttribute('use-shared-virtual-keyboard', '');
                                        mf.setAttribute('dir', 'ltr');
                                    
                                        // Create the delete button and add it directly to the math-field
                                        const deleteBtn = document.createElement('button');
                                        deleteBtn.className = 'math-field-delete-btn';
                                        deleteBtn.textContent = '×';
                                        deleteBtn.title = 'حذف المعادلة';
                                        deleteBtn.onclick = (event) => {
                                            event.stopPropagation();
                                            const fieldContainer = mf.closest('.editable-preview-field');
                                            mf.remove(); // This removes the math field itself
                                            if (fieldContainer) {
                                                TranslatorApp.preview.handlePreviewFieldUpdate(fieldContainer);
                                            }
                                        };
                                        mf.appendChild(deleteBtn);
                                        fragment.appendChild(mf);
                                    } else if (part) {
                                        fragment.appendChild(document.createTextNode(part));
                                    }
                                });
                                nodesToReplace.push({ oldNode: node, newNode: fragment });
                            }
                        }
                        nodesToReplace.forEach(({ oldNode, newNode }) => {
                            oldNode.parentNode.replaceChild(newNode, oldNode);
                        });
                        let finalHtml = tempDiv.innerHTML;
                        finalHtml = this.decorateBlanks(finalHtml);
                        finalHtml = this.injectChemistryMathFields(finalHtml);
                        finalHtml = TranslatorApp.utils.textDirection.enhancePreviewContent(finalHtml);
                
                        const textContent = tempDiv.textContent || '';
                        const containerDirection = TranslatorApp.utils.textDirection.getDominantDirection(textContent);
                        const dirAttr = containerDirection === 'rtl' ? 'rtl' : 'ltr';
                
                        return `<div class="content-root" dir="${dirAttr}">${finalHtml}</div>`;
                    } catch (error) {
                        console.error('Render content with math error:', error);
                        return '<div class="content-root" dir="rtl">فشل في عرض المحتوى</div>';
                    }
                },
                    
                handleCopyEvent(e) {
                    const selection = window.getSelection();
                    if (!selection.rangeCount) return;
                
                    const range = selection.getRangeAt(0);
                    const clonedContent = range.cloneContents();
                    const tempDiv = document.createElement('div');
                    tempDiv.appendChild(clonedContent);
                
                    const mathFields = tempDiv.querySelectorAll('math-field');
                    mathFields.forEach(mf => {
                        const mode = mf.getAttribute('default-mode');
                        const value = mf.value;
                        const delimiter = (mode === 'math') ? '$$' : '$';
                        const latexString = `${delimiter}${value}${delimiter}`;
                        
                        const textNode = document.createTextNode(latexString);
                        mf.parentNode.replaceChild(textNode, mf);
                    });
                    const html = tempDiv.innerHTML;
                    const text = tempDiv.textContent || '';
                    
                    e.clipboardData.setData('text/html', html);
                    e.clipboardData.setData('text/plain', text);
                    e.preventDefault();
                    
                },

                handlePasteEvent(e) {
                    try {
                        e.preventDefault();
                        const pasteHtml = e.clipboardData.getData('text/html');
                        const pasteText = e.clipboardData.getData('text/plain');
                        let contentToInsert = '';
                        if (pasteHtml) {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = pasteHtml;
                            contentToInsert = tempDiv.innerHTML;
                        } else {
                            contentToInsert = pasteText;
                        }
                        if (!contentToInsert) return;

                        const selection = window.getSelection();
                        if (!selection.rangeCount) return;
                        
                        const range = selection.getRangeAt(0);
                        range.deleteContents();
                        const processorDiv = document.createElement('div');
                        processorDiv.innerHTML = contentToInsert;
                        const walker = document.createTreeWalker(
                            processorDiv,
                            NodeFilter.SHOW_TEXT,
                            null,
                            false
                        );
                        let node;
                        const nodesToReplace = [];
                        
                        while ((node = walker.nextNode())) {
                            const textContent = node.textContent;
                            const latexRegex = /(\$\$[\s\S]*?\$\$|\$[^$]*\$)/g;
                            const parts = textContent.split(latexRegex);
                            
                            if (parts.length > 1) {
                                const fragment = document.createDocumentFragment();
                                parts.forEach(part => {
                                    if (part.startsWith('$$') && part.endsWith('$$')) {
                                        const latex = part.slice(2, -2);
                                        const mf = document.createElement('math-field');
                                        mf.setAttribute('default-mode', 'math');
                                        mf.setAttribute('value', latex);
                                        mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                        mf.setAttribute('use-shared-virtual-keyboard', '');
                                        mf.setAttribute('dir', 'ltr');
                                        fragment.appendChild(mf);
                                    } else if (part.startsWith('$') && part.endsWith('$')) {
                                        const latex = part.slice(1, -1);
                                        const mf = document.createElement('math-field');
                                        mf.setAttribute('default-mode', 'inline-math');
                                        mf.setAttribute('value', latex);
                                        mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                        mf.setAttribute('use-shared-virtual-keyboard', '');
                                        mf.setAttribute('dir', 'ltr');
                                        fragment.appendChild(mf);
                                    } else if (part) {
                                        fragment.appendChild(document.createTextNode(part));
                                    }
                                });
                                nodesToReplace.push({ oldNode: node, newNode: fragment });
                            }
                        }
                        nodesToReplace.forEach(({ oldNode, newNode }) => {
                            oldNode.parentNode.replaceChild(newNode, oldNode);
                        });
                        const finalFragment = document.createDocumentFragment();
                        while (processorDiv.firstChild) {
                            finalFragment.appendChild(processorDiv.firstChild);
                        }
                        range.insertNode(finalFragment);
                        selection.collapseToEnd();
                        
                        const fieldContainer = e.target.closest('.editable-preview-field');
                        if (fieldContainer) {
                            this.handlePreviewFieldUpdate(fieldContainer);
                        }
                    } catch (error) {
                        console.error('Paste event error:', error);
                        TranslatorApp.ui.showAlert('Paste failed. Plain text copied instead.', 'error');
                        document.execCommand('insertText', false, e.clipboardData.getData('text/plain'));
                    }
                    
                },      

                // Convert plain chemical formulas (e.g., NaHCO3, H2SO4, Ca(OH)2) into inline math-fields
                injectChemistryMathFields(text) {
                    try {
                        if (!text || typeof text !== 'string') return text;
                        const escapeAttr = (s) => (s || '').replace(/"/g, '&quot;');
                        // Basic LaTeX conversion: element digits -> _{digits}, parenthesis digits -> _{digits}
                        const toLatex = (formula) => {
                            try {
                                let out = formula;
                                out = out.replace(/([A-Za-z][a-z]?)\s*(\d+)/g, '$1_{$2}');
                                out = out.replace(/\)(\d+)/g, ')_{$1}');
                                return out;
                            } catch (error) {
                                console.warn('LaTeX conversion error:', error);
                                return formula;
                            }
                        };
                        // Regex for typical chemical formula tokens
                        const chemRegex = /\b(?:[A-Z][a-z]?\d*)+(?:\([A-Za-z\d]+\)\d*)*\b/g;
                        return text.replace(chemRegex, (match) => {
                            try {
                                // Avoid converting if already inside an HTML tag like <span> or attributes
                                // Heuristic: skip if match is immediately preceded by '&' (entity) or within a tag
                                // Since we sanitize later and we run on plain text chunks, this is usually safe
                                const latex = escapeAttr(toLatex(match));
                                return `<math-field default-mode="inline-math" value="${latex}" virtual-keyboard-mode="onfocus" use-shared-virtual-keyboard dir="ltr"></math-field>`;
                            } catch (error) {
                                console.warn('Chemistry field injection error:', error);
                                return match;
                            }
                        });
                    } catch (error) {
                        console.error('Inject chemistry math fields error:', error);
                        return text;
                    }
                },

                decorateBlanks(text) {
                    try {
                        if (!text || typeof text !== 'string') return text;
                        // Replace sequences of 3+ underscores with a visual blank slot
                        // Also handle other common blank patterns like [___], (___), etc.
                        let decorated = text;

                        // Detect text direction for appropriate blank styling
                        const textDirection = TranslatorApp.utils.textDirection.getDominantDirection(text);
                        const isMixed = TranslatorApp.utils.textDirection.isMixed(text);
                        const directionClass = isMixed ? 'mixed-content' : (textDirection === 'rtl' ? 'rtl-auto' : 'ltr-auto');

                        // Handle underscores: ___, ____, _____ etc. (preserve surrounding spaces)
                        decorated = decorated.replace(/(\s*)_{3,}(\s*)/g, (m, spaceBefore, spaceAfter) => {
                            const underscores = m.trim();
                            return `${spaceBefore}<span class="blank-slot ${directionClass}" data-blank="${underscores}" dir="${isMixed ? 'auto' : textDirection}"></span>${spaceAfter}`;
                        });

                        // Handle brackets with underscores: [___], (___), {___}
                        decorated = decorated.replace(/([\[\(\{])_{3,}([\]\)\}])/g, (m, open, close) => {
                            const underscores = m.slice(1, -1);
                            return `${open}<span class="blank-slot ${directionClass}" data-blank="${underscores}" dir="${isMixed ? 'auto' : textDirection}">${underscores}</span>${close}`;
                        });

                        // Handle simple brackets with spaces: [   ], (   ), {   }
                        decorated = decorated.replace(/([\[\(\{])\s{3,}([\]\)\}])/g, (m, open, close) => {
                            const spaces = m.slice(1, -1);
                            return `${open}<span class="blank-slot ${directionClass}" data-blank="${spaces}" dir="${isMixed ? 'auto' : textDirection}">${spaces}</span>${close}`;
                        });

                        // Handle other common blank patterns
                        // Handle question marks: ???, ???? etc.
                        decorated = decorated.replace(/\?{3,}/g, (m) => `<span class="blank-slot ${directionClass}" data-blank="${'?'.repeat(m.length)}" dir="${isMixed ? 'auto' : textDirection}">${m}</span>`);

                        // Handle dashes: ---, ---- etc.
                        decorated = decorated.replace(/-{3,}/g, (m) => `<span class="blank-slot ${directionClass}" data-blank="${'-'.repeat(m.length)}" dir="${isMixed ? 'auto' : textDirection}">${m}</span>`);

                        // Handle dots: ..., .... etc.
                        decorated = decorated.replace(/\.{3,}/g, (m) => `<span class="blank-slot ${directionClass}" data-blank="${'.'.repeat(m.length)}" dir="${isMixed ? 'auto' : textDirection}">${m}</span>`);

                        // Handle HTML content with blanks (preserve HTML structure)
                        if (decorated.includes('<') && decorated.includes('>')) {
                            // Create a temporary DOM element to process HTML content
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = decorated;

                            // Process text nodes within HTML
                            const walker = document.createTreeWalker(
                                tempDiv,
                                NodeFilter.SHOW_TEXT,
                                null,
                                false
                            );

                            const textNodes = [];
                            let node;
                            while (node = walker.nextNode()) {
                                textNodes.push(node);
                            }

                            // Process each text node
                            textNodes.forEach(textNode => {
                                const originalText = textNode.textContent;
                                let processedText = originalText;

                                // Detect direction for this specific text node
                                const nodeDirection = TranslatorApp.utils.textDirection.getDominantDirection(originalText);
                                const nodeIsMixed = TranslatorApp.utils.textDirection.isMixed(originalText);
                                const nodeDirectionClass = nodeIsMixed ? 'mixed-content' : (nodeDirection === 'rtl' ? 'rtl-auto' : 'ltr-auto');
                                const nodeDir = nodeIsMixed ? 'auto' : nodeDirection;

                                // Apply blank decoration to text content with proper direction (preserve spaces)
                                processedText = processedText.replace(/(\s*)_{3,}(\s*)/g, (m, spaceBefore, spaceAfter) => {
                                    const underscores = m.trim();
                                    return `${spaceBefore}<span class="blank-slot ${nodeDirectionClass}" data-blank="${underscores}" dir="${nodeDir}"></span>${spaceAfter}`;
                                });
                                processedText = processedText.replace(/([\[\(\{])_{3,}([\]\)\}])/g, (m, open, close) => {
                                    const underscores = m.slice(1, -1);
                                    return `${open}<span class="blank-slot ${nodeDirectionClass}" data-blank="${underscores}" dir="${nodeDir}">${underscores}</span>${close}`;
                                });
                                processedText = processedText.replace(/([\[\(\{])\s{3,}([\]\)\}])/g, (m, open, close) => {
                                    const spaces = m.slice(1, -1);
                                    return `${open}<span class="blank-slot ${nodeDirectionClass}" data-blank="${spaces}" dir="${nodeDir}">${spaces}</span>${close}`;
                                });
                                processedText = processedText.replace(/\?{3,}/g, (m) => `<span class="blank-slot ${nodeDirectionClass}" data-blank="${'?'.repeat(m.length)}" dir="${nodeDir}">${m}</span>`);
                                processedText = processedText.replace(/-{3,}/g, (m) => `<span class="blank-slot ${nodeDirectionClass}" data-blank="${'-'.repeat(m.length)}" dir="${nodeDir}">${m}</span>`);
                                processedText = processedText.replace(/\.{3,}/g, (m) => `<span class="blank-slot ${nodeDirectionClass}" data-blank="${'.'.repeat(m.length)}" dir="${nodeDir}">${m}</span>`);

                                if (processedText !== originalText) {
                                    const wrapper = document.createElement('span');
                                    wrapper.innerHTML = processedText;
                                    // Apply direction to the wrapper as well
                                    TranslatorApp.utils.textDirection.applySmartDirection(wrapper, originalText);
                                    textNode.parentNode.replaceChild(wrapper, textNode);
                                }
                            });

                            decorated = tempDiv.innerHTML;
                        }

                        return decorated;
                    } catch (error) {
                        console.error('Decorate blanks error:', error);
                        return text;
                    }
                },

                handleUnitUpdate(fieldContainer, newUnitValue) {
                    try {
                        if (!fieldContainer) return;
                
                        const path = fieldContainer.dataset.path;
                        const fileIndex = parseInt(fieldContainer.dataset.fileIndex, 10);
                        if (!path || isNaN(fileIndex)) {
                            console.warn('Invalid field container data for unit update:', { path, fileIndex });
                            return;
                        }
                
                        const pathParts = path.split('.');
                        const parentPath = pathParts.slice(0, pathParts.length - 1);
                        let targetObject = TranslatorApp.state.translatedJsonData[fileIndex].data;
                        for (const key of parentPath) {
                            targetObject = targetObject[key];
                        }
                
                        if (targetObject && typeof targetObject === 'object' && targetObject.hasOwnProperty('unit')) {
                            targetObject.unit = newUnitValue;
                        }
                        
                        this.updateDiff(fileIndex, path, newUnitValue);
                
                        const statusEl = document.getElementById(`status-field-${fileIndex}-${path.replace(/\./g, '-')}`);
                        if (statusEl) {
                            statusEl.className = 'status-dot status-edited';
                            statusEl.title = 'تم التعديل يدوياً';
                        }
                        
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('Handle unit update error:', error);
                        TranslatorApp.ui.showAlert('فشل في تحديث وحدة الإجابة.', 'error');
                    }
                },
                // New helper function to get data by path
                getDataByPath(obj, path) {
                    return path.split('.').reduce((o, i) => (o ? o[i] : undefined), obj);
                },

                handlePreviewFieldUpdate(fieldContainer) {
                    try {
                        if (!fieldContainer) return;

                        const path = fieldContainer.dataset.path;
                        const fileIndex = parseInt(fieldContainer.dataset.fileIndex, 10);
                
                        if (!path || isNaN(fileIndex)) {
                            console.warn('Invalid field container data:', { path, fileIndex });
                            return;
                        }
                        let newContent = '';
                        const root = fieldContainer.querySelector('.content-root');
                        if (root) {
                            root.childNodes.forEach(node => {
                                if (node.tagName === 'MATH-FIELD') {
                                    const delimiter = node.getAttribute('default-mode') === 'math' ? '$$' : '$';
                                    newContent += `${delimiter}${node.value}${delimiter}`;
                                } else {
                                    newContent += node.outerHTML || node.textContent;
                                }
                            });
                        }
                        
                        // Remove the visual blank slots from the final HTML before saving
                        // Handle both empty blank slots and those with content
                        newContent = newContent.replace(/<span class="blank-slot"[^>]*>(.*?)<\/span>/g, (match, content) => {
                            // If content is empty or just spaces, use ___
                            if (!content || content.trim() === '') {
                                return '___';
                            }
                            // If content has actual text, preserve it but convert to underscores
                            return content.replace(/\S/g, '_').replace(/_+/g, '___');
                        });
                        this.updateData(fileIndex, path, newContent);
                        this.updateDiff(fileIndex, path);
                        const statusEl = document.getElementById(`status-field-${fileIndex}-${path.replace(/\./g, '-')}`);
                        if (statusEl) {
                            statusEl.className = 'status-dot status-edited';
                            statusEl.title = 'تم التعديل يدوياً';
                        }

                        // Push to history after update is complete
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        TranslatorApp.state.hasUnsavedChanges = true;
                        
                        // Update quality indicators and word count for this field
                        const fieldId = fieldContainer.id;
                        setTimeout(() => {
                            this.updateQualityIndicators(fieldId, fileIndex, path);
                            this.updateWordCount(fieldId);
                            this.updateStats();
                            this.checkAndAlert(fieldId, fileIndex, path);
                        }, 100);

                    } catch (error) {
                        console.error('Handle preview field update error:', error);
                        TranslatorApp.ui.showAlert('فشل في تحديث حقل المعاينة.', 'error');
                    }
                },

                render() {
                    try {
                        const { previewContainer } = TranslatorApp.dom;
                        previewContainer.innerHTML = '';
                        
                        // Get the mapped IDs from the input field once before the loop
                        let mappedIdsArray = [];
                        try {
                            if (TranslatorApp.dom.useMappedIdsCheckbox.checked && TranslatorApp.dom.mappedIdsInput.value.trim()) {
                                mappedIdsArray = JSON.parse(TranslatorApp.dom.mappedIdsInput.value);
                            }
                        } catch (e) {
                            console.error('Error parsing mapped IDs from input:', e);
                            TranslatorApp.ui.showAlert('قائمة المعرفات (mapped_id) غير صالحة. يرجى التأكد من أنها مصفوفة JSON صحيحة.', 'error');
                        }
                
                        TranslatorApp.state.translatedJsonData.forEach((file, fileIndex) => {
                            try {
                                const fileAccordion = document.createElement('div');
                                fileAccordion.className = 'preview-card rounded-2xl shadow-lg overflow-hidden';
                
                                const header = document.createElement('button');
                                header.className = 'accordion-header';
                                
                                const originalId = TranslatorApp.state.originalJsonData[fileIndex]?.data?.id || file.name.replace('.json', '');
                                const currentMappedId = mappedIdsArray[fileIndex] || null;
                                const sourceId = TranslatorApp.state.originalJsonData[fileIndex]?.data?.metadata?.source_id?.value || 
                                                TranslatorApp.state.originalJsonData[fileIndex]?.data?.source_id?.value || null;
                
                                header.innerHTML = `
                                    <div style="width: 100%;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px;">
                                            <div style="display: flex; align-items: center;">
                                                <span style="font-weight: normal; font-size: 0.9em; color: var(--secondary-text);">Translation ID:</span>
                                                <span dir="ltr" style="font-family: monospace; margin-left: 8px; color: var(--primary-color); font-weight: 600;">${originalId}</span>
                                            </div>
                                            ${sourceId ? `
                                            <div style="display: flex; align-items: center;">
                                                <span style="font-weight: normal; font-size: 0.9em; color: var(--secondary-text);">Source ID:</span>
                                                <span dir="ltr" style="font-family: monospace; margin-left: 8px; color: var(--success-color); font-weight: 600;">${sourceId}</span>
                                            </div>
                                            ` : ''}
                                            ${currentMappedId ? `
                                            <div style="display: flex; align-items: center;">
                                                <span style="font-weight: normal; font-size: 0.9em; color: var(--secondary-text);">Mapped ID:</span>
                                                <span dir="ltr" style="font-family: monospace; margin-left: 8px;">${currentMappedId}</span>
                                            </div>
                                            ` : ''}
                                        </div>
                                        <div class="file-progress-bar">
                                            <div class="file-progress-fill" id="file-progress-fill-${fileIndex}" style="width: 0%"></div>
                                        </div>
                                        <div class="text-xs text-center mt-1" style="color: var(--secondary-text);">
                                            <span id="file-progress-text-${fileIndex}">0 من 0 حقول</span>
                                        </div>
                                    </div>
                                `;
                
                                header.onclick = (e) => {
                                    const content = e.currentTarget.nextElementSibling;
                                    const accordionParent = e.currentTarget.closest('.preview-card');
                                    const isOpen = content.style.maxHeight && content.style.maxHeight !== '0px';
                                    
                                    if (isOpen) {
                                        content.style.maxHeight = null;
                                        accordionParent.style.boxShadow = null;
                                        accordionParent.style.transform = null;
                                        accordionParent.classList.remove('open');
                                    } else {
                                        content.style.maxHeight = content.scrollHeight + "px";
                                        accordionParent.style.boxShadow = '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)';
                                        accordionParent.style.transform = 'scale(1.01)';
                                        accordionParent.classList.add('open');
                                    }
                                };
                                
                                const content = document.createElement('div');
                                content.className = 'accordion-content';
                                content.innerHTML = this.renderFileContent(file.data, fileIndex, currentMappedId);
                
                                fileAccordion.appendChild(header);
                                fileAccordion.appendChild(content);
                                previewContainer.appendChild(fileAccordion);
                
                                this.generateInitialDiffs(fileIndex);
                            } catch (fileError) {
                                console.warn('Error rendering file:', fileError);
                                const errorDiv = document.createElement('div');
                                errorDiv.className = 'preview-card rounded-2xl shadow-lg overflow-hidden';
                                errorDiv.innerHTML = `<div class="p-4" style="color: var(--error-color);">خطأ في عرض الملف: ${file.name}</div>`;
                                previewContainer.appendChild(errorDiv);
                            }
                        });
                        this.prepareInteractiveMathFields();
                        
                        // Update stats and quality indicators after render
                        setTimeout(() => {
                            this.updateStats();
                            this.updateAllQualityIndicators();
                            this.updateAllWordCounts();
                            this.loadNotes();
                        }, 100);
                    } catch (error) {
                        console.error('Preview render error:', error);
                        const { previewContainer } = TranslatorApp.dom;
                        previewContainer.innerHTML = '<div class="p-4" style="color: var(--error-color);">فشل في عرض المعاينة</div>';
                    }
                },
                
                updateStats() {
                    try {
                        let total = 0, completed = 0, edited = 0, warnings = 0;
                        
                        document.querySelectorAll('.status-dot').forEach(dot => {
                            total++;
                            if (dot.classList.contains('status-translated')) completed++;
                            if (dot.classList.contains('status-edited')) edited++;
                        });
                        
                        document.querySelectorAll('.field-error, .field-warning').forEach(() => warnings++);
                        
                        const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
                        
                        if (TranslatorApp.dom.totalFieldsCount) TranslatorApp.dom.totalFieldsCount.textContent = total;
                        if (TranslatorApp.dom.completedFieldsCount) TranslatorApp.dom.completedFieldsCount.textContent = completed;
                        if (TranslatorApp.dom.editedFieldsCount) TranslatorApp.dom.editedFieldsCount.textContent = edited;
                        if (TranslatorApp.dom.warningsCount) TranslatorApp.dom.warningsCount.textContent = warnings;
                        if (TranslatorApp.dom.progressPercentage) TranslatorApp.dom.progressPercentage.textContent = `${percentage}%`;
                    } catch (error) {
                        console.error('Update stats error:', error);
                    }
                },
                
                updateAllQualityIndicators() {
                    try {
                        document.querySelectorAll('[id^="field-"]').forEach(field => {
                            if (field.contentEditable === 'true') {
                                const fieldId = field.id;
                                const fileIndex = parseInt(field.dataset.fileIndex);
                                const path = field.dataset.path;
                                this.updateQualityIndicators(fieldId, fileIndex, path);
                            }
                        });
                    } catch (error) {
                        console.error('Update all quality indicators error:', error);
                    }
                },
                
                updateQualityIndicators(fieldId, fileIndex, path) {
                    try {
                        const field = document.getElementById(fieldId);
                        if (!field) return;
                        
                        const translatedText = field.textContent || '';
                        const originalText = this.getOriginalTextByPath(fileIndex, path);
                        
                        // Check numbers
                        const numbersCheck = document.getElementById(`numbers-check-${fieldId}`);
                        if (numbersCheck) {
                            const hasNumbers = TranslatorApp.quality.qa.checkNumbers(originalText, translatedText);
                            numbersCheck.classList.toggle('valid', hasNumbers.length === 0);
                            numbersCheck.classList.toggle('invalid', hasNumbers.length > 0);
                        }
                        
                        // Check HTML balance
                        const htmlCheck = document.getElementById(`html-check-${fieldId}`);
                        if (htmlCheck) {
                            const htmlErrors = TranslatorApp.quality.qa.checkHtmlBalance(translatedText);
                            htmlCheck.classList.toggle('valid', htmlErrors.length === 0);
                            htmlCheck.classList.toggle('invalid', htmlErrors.length > 0);
                        }
                        
                        // Check LaTeX
                        const latexCheck = document.getElementById(`latex-check-${fieldId}`);
                        if (latexCheck) {
                            const hasLatex = translatedText.includes('$') || translatedText.includes('\\');
                            const isValid = !translatedText.includes('\\alt{') && !translatedText.includes('\\prime');
                            latexCheck.classList.toggle('valid', !hasLatex || isValid);
                            latexCheck.classList.toggle('invalid', hasLatex && !isValid);
                        }
                        
                        // Check blanks
                        const blanksCheck = document.getElementById(`blanks-check-${fieldId}`);
                        if (blanksCheck) {
                            const originalBlanks = (originalText.match(/_{3,}/g) || []).length;
                            const translatedBlanks = (translatedText.match(/_{3,}/g) || []).length + 
                                                     (field.querySelectorAll('.blank-slot').length || 0);
                            blanksCheck.classList.toggle('valid', originalBlanks === translatedBlanks);
                            blanksCheck.classList.toggle('invalid', originalBlanks !== translatedBlanks);
                        }
                    } catch (error) {
                        console.error('Update quality indicators error:', error);
                    }
                },
                
                updateAllWordCounts() {
                    try {
                        document.querySelectorAll('[id^="field-"]').forEach(field => {
                            if (field.contentEditable === 'true') {
                                const fieldId = field.id;
                                this.updateWordCount(fieldId);
                            }
                        });
                    } catch (error) {
                        console.error('Update all word counts error:', error);
                    }
                },
                
                updateWordCount(fieldId) {
                    try {
                        const field = document.getElementById(fieldId);
                        if (!field) return;
                        
                        const text = field.textContent || '';
                        const words = text.trim().split(/\s+/).filter(Boolean).length;
                        const chars = text.length;
                        
                        const wordCountEl = document.getElementById(`wordCount-${fieldId}`);
                        const charCountEl = document.getElementById(`charCount-${fieldId}`);
                        
                        if (wordCountEl) wordCountEl.textContent = words;
                        if (charCountEl) charCountEl.textContent = chars;
                    } catch (error) {
                        console.error('Update word count error:', error);
                    }
                },
                
                getOriginalTextByPath(fileIndex, path) {
                    try {
                        let data = TranslatorApp.state.originalJsonData[fileIndex]?.data;
                        const keys = path.split('.');
                        for (let key of keys) {
                            data = data?.[key];
                        }
                        return data || '';
                    } catch (error) {
                        return '';
                    }
                },
                
                validateAllFields() {
                    try {
                        let totalWarnings = 0;
                        document.querySelectorAll('[id^="field-"]').forEach(field => {
                            if (field.contentEditable === 'true') {
                                const fieldId = field.id;
                                const fileIndex = parseInt(field.dataset.fileIndex);
                                const path = field.dataset.path;
                                
                                this.updateQualityIndicators(fieldId, fileIndex, path);
                                this.updateWordCount(fieldId);
                                
                                const warnings = field.closest('.border').querySelectorAll('.quality-badge.invalid').length;
                                if (warnings > 0) {
                                    field.closest('.border').classList.add('field-warning');
                                    totalWarnings++;
                                }
                            }
                        });
                        
                        this.updateStats();
                        TranslatorApp.ui.showAlert(`التحقق مكتمل - ${totalWarnings} تحذير`, totalWarnings > 0 ? 'warning' : 'success');
                    } catch (error) {
                        console.error('Validate all fields error:', error);
                    }
                },
                
                applyFilters() {
                    try {
                        const typeFilter = this.dom.filterByType?.value || 'all';
                        const statusFilter = this.dom.filterByStatus?.value || 'all';
                        const sortBy = this.dom.sortBy?.value || 'default';
                        
                        // Apply filters logic here
                        // This is a placeholder - full implementation would filter based on part.type and status
                        
                        TranslatorApp.ui.showAlert('تم تطبيق الفلاتر', 'info', 2000);
                    } catch (error) {
                        console.error('Apply filters error:', error);
                    }
                },
                
                checkAndAlert(fieldId, fileIndex, path) {
                    try {
                        const field = document.getElementById(fieldId);
                        if (!field) return;
                        
                        const translatedText = field.textContent || '';
                        const originalText = this.getOriginalTextByPath(fileIndex, path);
                        
                        const alerts = [];
                        
                        // Check if field is empty
                        if (!translatedText.trim()) {
                            alerts.push('⚠️ الحقل فارغ');
                        }
                        
                        // Check numbers mismatch
                        const numbersCheck = TranslatorApp.quality.qa.checkNumbers(originalText, translatedText);
                        if (numbersCheck.length > 0) {
                            alerts.push('🔢 اختلاف في الأرقام');
                        }
                        
                        // Check missing blanks
                        const originalBlanks = (originalText.match(/_{3,}/g) || []).length;
                        const translatedBlanks = (translatedText.match(/_{3,}/g) || []).length + 
                                                 (field.querySelectorAll('.blank-slot').length || 0);
                        if (originalBlanks !== translatedBlanks) {
                            alerts.push(`__ فراغات ناقصة (${translatedBlanks}/${originalBlanks})`);
                        }
                        
                        // Check HTML balance
                        const htmlErrors = TranslatorApp.quality.qa.checkHtmlBalance(translatedText);
                        if (htmlErrors.length > 0) {
                            alerts.push('🏷️ HTML غير متوازن');
                        }
                        
                        // Check LaTeX errors
                        if (translatedText.includes('\\alt{') || translatedText.includes('\\prime')) {
                            alerts.push('📐 LaTeX خاطئ (نص عربي)');
                        }
                        
                        // Apply visual indicators
                        const fieldWrapper = field.closest('.border');
                        if (alerts.length > 0) {
                            fieldWrapper?.classList.add('field-error');
                            // Show subtle notification
                            console.warn(`Field ${fieldId}:`, alerts.join(', '));
                        } else {
                            fieldWrapper?.classList.remove('field-error', 'field-warning');
                            fieldWrapper?.classList.add('field-success');
                        }
                        
                    } catch (error) {
                        console.error('Check and alert error:', error);
                    }
                },
                renderReadOnlyField(label, originalValue, translatedValue) {
                    try {
                        if (originalValue === undefined || originalValue === null) return '';
                        const displayOriginalValue = Array.isArray(originalValue) ? originalValue.join(', ') : String(originalValue);
                        const displayTranslatedValue = Array.isArray(translatedValue) ? translatedValue.join(', ') : String(translatedValue);
                        
                        // This is a new check for numeric values to determine direction, but it's not applied correctly.
                        // const isNumeric = !isNaN(parseFloat(displayOriginalValue)) && isFinite(displayOriginalValue);
                        // const dirAttr = isNumeric ? 'ltr' : 'rtl'; 
                        
                        // Let's assume the original values are always English and force LTR for them.
                        const originalDir = 'ltr'; 
                
                        const enhancedOriginal = TranslatorApp.utils.textDirection.enhancePreviewContent(displayOriginalValue);
                        const enhancedTranslated = TranslatorApp.utils.textDirection.enhancePreviewContent(displayTranslatedValue);
                
                        return `
                            <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                                <h5 class="font-bold flex items-center mb-2">${TranslatorApp.security.sanitize(label)}</h5>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">الأصلي</p>
                                        <div class="p-3 rounded-lg text-sm h-full" dir="${originalDir}" style="background-color: var(--bg-color); color: var(--secondary-text);">${enhancedOriginal}</div>
                                    </div>
                                    <div>
                                        <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">المترجم (قابل للتعديل)</p>
                                        <div class="p-3 rounded-lg text-sm h-full" dir="rtl" style="background-color: var(--bg-color); color: var(--secondary-text);">${enhancedTranslated}</div>
                                    </div>
                                </div>
                            </div>`;
                    } catch (error) {
                        console.error('Render read only field error:', error);
                        return `
                        <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                            <h5 class="font-bold flex items-center mb-2">خطأ في العرض</h5>
                            <div class="p-3 rounded-lg text-sm" style="background-color: var(--bg-color); color: var(--error-color);">فشل في عرض المحتوى</div>
                        </div>`;
                    }
                },
                renderInputField(label, originalValue, translatedValue, originalUnit, translatedUnit, path, fileIndex) {
                    if (originalValue === undefined || originalValue === null) return '';
                
                    const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                    const statusId = `status-${fieldId}`;
                
                    // Get the translated unit from the new map
                    const translatedUnitText = TranslatorApp.quality.unitsMap[originalUnit.toLowerCase()] || originalUnit;
                
                    return `
                        <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                            <div class="flex justify-between items-center mb-2">
                                <h5 class="font-bold flex items-center">${TranslatorApp.security.sanitize(label)} <span id="${statusId}" class="status-dot status-translated" title="تمت الترجمة"></span></h5>
                                <div class="flex gap-2">
                                    <button class="text-xs font-semibold py-1 px-2 rounded" onclick="TranslatorApp.preview.copyOriginalText(this)">نسخ الأصلي</button>
                                    <button class="text-xs font-semibold py-1 px-2 rounded" onclick="document.getElementById('diff-field-${fileIndex}-${path.replace(/\./g, '-')}').parentNode.classList.toggle('hidden')">عرض/إخفاء الفروقات</button>
                                </div>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">الأصلي</p>
                                    <div class="original-text-readonly p-3 rounded-lg text-sm h-full flex items-center justify-end" dir="rtl" style="background-color: var(--bg-color); color: var(--secondary-text); overflow:auto;">
                                        <span style="font-family: monospace;">${TranslatorApp.security.sanitize(originalValue)}</span>
                                        <span class="mr-2">${TranslatorApp.security.sanitize(originalUnit)}</span>
                                    </div>
                                </div>
                                <div>
                                    <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">المترجم (قابل للتعديل)</p>
                                    <div id="${fieldId}" 
                                        class="editable-preview-field flex items-center justify-end"
                                        data-path="${path}"
                                        data-file-index="${fileIndex}"
                                        dir="rtl">
                                        <span contenteditable="true" dir="ltr" class="flex-grow text-right">${TranslatorApp.security.sanitize(translatedValue)}</span>
                                        <span contenteditable="true" dir="rtl" class="flex-shrink-0 mr-2 editable-unit">${TranslatorApp.security.sanitize(translatedUnitText)}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-4 hidden">
                                <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">مقارنة الفروقات (الترجمة الأولية مقابل الترجمة الحالية)</p>
                                <div id="diff-field-${fileIndex}-${path.replace(/\./g, '-')}" class="diff-view"></div>
                            </div>
                        </div>
                    `;
                },
                        
                renderReadOnlyLTRField(label, value) {
                    if (value === undefined || value === null) return '';
                    const displayValue = Array.isArray(value) ? value.join(', ') : String(value);
                
                    return `
                    <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                        <h5 class="font-bold flex items-center mb-2">${TranslatorApp.security.sanitize(label)}</h5>
                        <div>
                            <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">الأصلي</p>
                            <div class="p-3 rounded-lg text-sm h-full" dir="ltr" style="background-color: var(--bg-color); color: var(--secondary-text);">${TranslatorApp.security.sanitize(displayValue)}</div>
                        </div>
                    </div>`;
                },

                renderFileContent(data, fileIndex, mappedId) {
                    try {
                        let html = '<div class="space-y-6">';
                
                        const originalId = TranslatorApp.state.originalJsonData[fileIndex]?.data?.id;
                
                        // Display both original and mapped IDs with labels
                        if (originalId) {
                            html += `<div class="p-4 bg-gray-100 rounded-lg shadow-inner mb-4 flex items-center justify-between">
                                <div class="flex items-center text-sm font-semibold" style="color: var(--text-color);">
                                    <span class="ml-2">original_id:</span> <span dir="ltr" style="font-family: monospace;">${originalId}</span>
                                </div>`;
                            
                            // Show mapped_id if it exists
                            if (mappedId) {
                                html += `
                                <div class="flex items-center text-sm font-semibold" style="color: var(--text-color);">
                                    <span class="ml-2">mapped_id:</span> <span dir="ltr" style="font-family: monospace;">${mappedId}</span>
                                </div>`;
                            }
                            html += `</div>`;
                        }
                
                        const renderField = (label, originalValue, translatedValue, path, editableDir = 'rtl') => {
                            try {
                                if (originalValue === undefined || originalValue === null || (Array.isArray(originalValue) && originalValue.length === 0)) {
                                    return '';
                                }
                                const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                                const diffId = `diff-${fieldId}`;
                                const statusId = `status-${fieldId}`;
                                
                                const displayOriginalValue = (Array.isArray(originalValue) ? originalValue.join('') : String(originalValue));
                                const displayTranslatedValue = (Array.isArray(translatedValue) ? translatedValue.join('') : String(translatedValue));
                                
                                const finalTranslatedValue = displayTranslatedValue || displayOriginalValue;
                                
                                return `
                                    <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                                        <div class="flex justify-between items-center mb-2">
                                            <h5 class="font-bold flex items-center">${TranslatorApp.security.sanitize(label)} <span id="${statusId}" class="status-dot status-translated" title="تمت الترجمة"></span></h5>
                                            <div class="flex gap-2">
                                                <button class="text-xs font-semibold py-1 px-2 rounded" onclick="TranslatorApp.preview.copyOriginalText(this)">نسخ الأصلي</button>
                                                <button class="text-xs font-semibold py-1 px-2 rounded" onclick="document.getElementById('${diffId}').parentNode.classList.toggle('hidden')">عرض/إخفاء الفروقات</button>
                                            </div>
                                        </div>
                                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                            <div>
                                                <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">الأصلي</p>
                                                <div class="original-text-readonly p-3 rounded-lg text-sm h-full" style="background-color: var(--bg-color); overflow:auto;">
                                                    <div dir="ltr">${this.renderContentWithMath(displayOriginalValue)}</div>
                                                </div>
                                            </div>
                                            <div>
                                                <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">المترجم (قابل للتعديل)</p>
                                                <div id="${fieldId}" 
                                                     contenteditable="true"
                                                     class="editable-preview-field"
                                                     data-path="${path}"
                                                     data-file-index="${fileIndex}"
                                                     dir="${editableDir}"
                                                     style="unicode-bidi: embed;">
                                                     ${this.renderContentWithMath(finalTranslatedValue)}
                                                </div>
                                            </div>
                                        </div>
                                        <!-- عداد الكلمات ومؤشرات الجودة -->
                                        <div class="flex justify-between items-center mt-3 pt-3 border-t" style="border-color: var(--card-border);">
                                            <div class="flex gap-3 text-xs" style="color: var(--secondary-text);">
                                                <span>الكلمات: <span class="font-bold" id="wordCount-${fieldId}">-</span></span>
                                                <span>الأحرف: <span class="font-bold" id="charCount-${fieldId}">-</span></span>
                                            </div>
                                            <div class="flex gap-1" id="quality-indicators-${fieldId}">
                                                <span class="quality-badge" id="numbers-check-${fieldId}" title="تطابق الأرقام">🔢</span>
                                                <span class="quality-badge" id="html-check-${fieldId}" title="توازن HTML">🏷️</span>
                                                <span class="quality-badge" id="latex-check-${fieldId}" title="صحة LaTeX">📐</span>
                                                <span class="quality-badge" id="blanks-check-${fieldId}" title="Blanks سليمة">__</span>
                                            </div>
                                        </div>
                                        
                                        <!-- أزرار الإجراءات السريعة -->
                                        <div class="flex gap-1 mt-2">
                                            <button class="action-btn" title="نسخ الترجمة" onclick="TranslatorApp.preview.copyTranslation('${fieldId}')">📋</button>
                                            <button class="action-btn" title="استعادة الترجمة الآلية" onclick="TranslatorApp.preview.restoreAI('${fieldId}', '${path}', ${fileIndex})">🤖</button>
                                            <button class="action-btn" title="إضافة ملاحظة" onclick="TranslatorApp.preview.toggleNotes('${fieldId}')">📝</button>
                                        </div>
                                        
                                        <!-- قسم الملاحظات -->
                                        <div id="notes-${fieldId}" class="hidden mt-2">
                                            <textarea class="w-full text-xs p-2 border rounded" 
                                                      placeholder="اكتب ملاحظاتك هنا..." 
                                                      rows="2"
                                                      onchange="TranslatorApp.preview.saveNote('${fieldId}', this.value)"></textarea>
                                        </div>
                                        
                                        <div class="mt-4 hidden">
                                             <p class="text-sm font-semibold mb-1" style="color: var (--secondary-text);">مقارنة الفروقات (الترجمة الأولية مقابل الترجمة الحالية)</p>
                                            <div id="${diffId}" class="diff-view"></div>
                                        </div>
                                    </div>`;
                            } catch (fieldError) {
                                console.warn('Error rendering field:', fieldError);
                                return '';
                            }
                        };
                
                        html += renderField('البيان (Statement)', TranslatorApp.state.originalJsonData[fileIndex].data.statement, data.statement, 'statement');
                
                        data.parts?.forEach((part, partIndex) => {
                            try {
                                const originalPart = TranslatorApp.state.originalJsonData[fileIndex].data.parts[partIndex];
                                if (!originalPart) return;
                
                                html += '<div class="border-t pt-4 mt-4 space-y-4" style="border-color: var(--card-border);">';
                                html += `<h5 class="font-semibold text-md" style="color: var(--secondary-text);">الجزء ${partIndex + 1} (النوع: ${part.type || 'غير محدد'})</h5>`;
                
                                // Check if stem exists and is not empty
                                if (originalPart.stem && originalPart.stem.trim()) {
                                    html += renderField('السؤال (Stem)', originalPart.stem, part.stem, `parts.${partIndex}.stem`);
                                } else {
                                    html += `<div class="border rounded-lg p-4 bg-yellow-50" style="border-color: #f59e0b;">
                                        <p class="text-sm font-semibold text-yellow-700">⚠️ تحذير: السؤال (Stem) فارغ في الملف الأصلي</p>
                                    </div>`;
                                }
                
                                if (originalPart.answer) {
                                    if (part.type === 'input_box' && typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('value')) {
                                        const originalValue = originalPart.answer.value;
                                        const originalUnit = originalPart.answer.unit || '';
                                        const translatedValue = part.answer.value;
                                        const translatedUnit = part.answer.unit || '';
                                        html += this.renderInputField('الإجابة (Answer)', originalValue, translatedValue, originalUnit, translatedUnit, `parts.${partIndex}.answer.value`, fileIndex);
                                    } else if (Array.isArray(originalPart.answer)) {
                                        html += renderField('الإجابة (Answer)', originalPart.answer, part.answer, `parts.${partIndex}.answer`);
                                    } else if (typeof originalPart.answer === 'string') {
                                        html += renderField('الإجابة (Answer)', originalPart.answer, part.answer, `parts.${partIndex}.answer`);
                                    } else if (typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('value')) {
                                        const originalValue = originalPart.answer.value;
                                        const translatedValue = (part.answer && part.answer.value) || originalPart.answer.value;
                                        html += renderField('الإجابة (Answer)', originalValue, translatedValue, `parts.${partIndex}.answer.value`);
                                    } else {
                                        html += this.renderReadOnlyField('الإجابة (Answer - غير قابلة للترجمة)', JSON.stringify(originalPart.answer));
                                    }
                                }
                
                                // Add choices section header for better organization
                                if (part.choices && part.choices.length > 0) {
                                    html += '<div class="mt-4 mb-2"><h6 class="font-semibold text-sm" style="color: var(--secondary-text);">الخيارات (Choices):</h6></div>';
                                }
                                
                                part.choices?.forEach((choice, choiceIndex) => {
                                    const originalChoice = originalPart.choices[choiceIndex];
                                    const isCorrect = choice.is_correct || false;
                                    const correctBadge = isCorrect ? ' <span style="background-color: #10b981; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: bold;">✓ صحيح</span>' : '';
                                    // Use 'auto' for choices to respect math-field LTR while keeping text RTL
                                    html += renderField(`خيار ${choiceIndex + 1}${correctBadge}`, originalChoice.html_content, choice.html_content, `parts.${partIndex}.choices.${choiceIndex}.html_content`, 'auto');
                                });
                
                                if (originalPart.gap_text_keys) {
                                    const sortedOriginalKeys = [...originalPart.gap_text_keys].sort((a, b) => a.correct_order - b.correct_order);
                                    const translatedPart = data.parts[partIndex];
                                    const sortedTranslatedKeys = [...(translatedPart.gap_text_keys || [])].sort((a, b) => a.correct_order - b.correct_order);
                
                                    sortedOriginalKeys.forEach((originalKeyItem, index) => {
                                        const translatedKeyItem = sortedTranslatedKeys[index] || { value: '' };
                                        const path = `parts.${partIndex}.gap_text_keys.${originalPart.gap_text_keys.findIndex(item => item.value === originalKeyItem.value)}.value`;
                
                                        html += `<div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                                            <div class="flex justify-between items-center mb-2">
                                                <h5 class="font-bold flex items-center">كلمة الفراغ ${originalKeyItem.correct_order}</h5>
                                            </div>
                                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                                <div>
                                                    <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">الأصلي</p>
                                                    <div class="p-3 rounded-lg text-sm h-full" dir="ltr" style="background-color: var(--bg-color); color: var(--secondary-text);">${TranslatorApp.security.sanitize(originalKeyItem.value)}</div>
                                                </div>
                                                <div>
                                                    <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">المترجم (قابل للتعديل)</p>
                                                    <div id="field-${fileIndex}-${path.replace(/\./g, '-')}"
                                                        contenteditable="true"
                                                        class="editable-preview-field"
                                                        data-path="${path}"
                                                        data-file-index="${fileIndex}"
                                                        dir="rtl">
                                                        ${TranslatorApp.security.sanitize(translatedKeyItem.value)}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>`;
                                    });
                                }
                                
                                // Add ai.guidelines section for string type questions
                                if (originalPart.ai && originalPart.ai.guidelines && Array.isArray(originalPart.ai.guidelines) && originalPart.ai.guidelines.length > 0) {
                                    html += '<div class="mt-4 mb-2"><h6 class="font-semibold text-sm" style="color: var(--secondary-text);">إرشادات التصحيح (AI Guidelines):</h6></div>';
                                    
                                    originalPart.ai.guidelines.forEach((originalGuideline, guidelineIndex) => {
                                        const translatedGuideline = part.ai?.guidelines?.[guidelineIndex] || {};
                                        
                                        html += `<div class="border rounded-lg p-4 mb-3" style="border-color: var(--card-border); background-color: rgba(59, 130, 246, 0.05);">
                                            <div class="mb-2">
                                                <span class="text-xs font-semibold px-2 py-1 rounded" style="background-color: #3b82f6; color: white;">إرشاد ${guidelineIndex + 1}</span>
                                                ${originalGuideline.mark ? `<span class="text-xs font-semibold px-2 py-1 rounded ml-2" style="background-color: #10b981; color: white;">العلامة: ${originalGuideline.mark}</span>` : ''}
                                            </div>`;
                                        
                                        // Render student_answer
                                        if (originalGuideline.student_answer && typeof originalGuideline.student_answer === 'string') {
                                            html += renderField('إجابة الطالب (Student Answer)', 
                                                originalGuideline.student_answer, 
                                                translatedGuideline.student_answer || originalGuideline.student_answer, 
                                                `parts.${partIndex}.ai.guidelines.${guidelineIndex}.student_answer`);
                                        }
                                        
                                        // Render comment
                                        if (originalGuideline.comment && typeof originalGuideline.comment === 'string') {
                                            html += renderField('التعليق (Comment)', 
                                                originalGuideline.comment, 
                                                translatedGuideline.comment || originalGuideline.comment, 
                                                `parts.${partIndex}.ai.guidelines.${guidelineIndex}.comment`);
                                        }
                                        
                                        html += '</div>';
                                    });
                                }
                
                                html += '</div>';
                            } catch (partError) {
                                console.warn('Error rendering part:', partError);
                                html += '<div class="border-t pt-4 mt-4 space-y-4" style="border-color: var(--card-border);">';
                                html += `<h5 class="font-semibold text-md" style="color: var(--error-color);">خطأ في عرض الجزء ${partIndex + 1}</h5>`;
                                html += '</div>';
                            }
                        });
                
                        html += '</div>';
                        return html;
                    } catch (error) {
                        console.error('Render file content error:', error);
                        return '<div class="space-y-6"><div class="border rounded-lg p-4" style="border-color: var(--card-border);"><h5 class="font-bold flex items-center mb-2" style="color: var(--error-color);">خطأ في عرض المحتوى</h5><div class="p-3 rounded-lg text-sm" style="background-color: var(--bg-color); color: var(--error-color);">فشل في عرض محتوى الملف</div></div></div>';
                    }
                },
                updateData(fileIndex, path, value) {
                    try {
                        const keys = path.split('.');
                        let current = TranslatorApp.state.translatedJsonData[fileIndex].data;
                        const original = TranslatorApp.state.originalJsonData[fileIndex].data; // Keep original for reference
                        for (let i = 0; i < keys.length - 1; i++) {
                            current = current[keys[i]];
                        }
                        const lastKey = keys[keys.length - 1];
                
                        // Correctly handle the case for gap_text_keys
                        if (keys[keys.length - 2] === 'gap_text_keys') {
                            const keyIndex = parseInt(keys[keys.length - 1], 10);
                            if (current.gap_text_keys && current.gap_text_keys[keyIndex]) {
                                current.gap_text_keys[keyIndex].value = value;
                            }
                        } 
                        // Handle ai.guidelines paths (e.g., parts.0.ai.guidelines.0.student_answer)
                        else if (keys.includes('guidelines') && keys[keys.length - 2] && !isNaN(keys[keys.length - 2])) {
                            const guidelineIndex = parseInt(keys[keys.length - 2], 10);
                            const fieldName = keys[keys.length - 1]; // 'student_answer' or 'comment'
                            
                            // Navigate to the guidelines array
                            let guidelinesParent = TranslatorApp.state.translatedJsonData[fileIndex].data;
                            for (let i = 0; i < keys.length - 2; i++) {
                                guidelinesParent = guidelinesParent[keys[i]];
                            }
                            
                            if (guidelinesParent && guidelinesParent[guidelineIndex]) {
                                guidelinesParent[guidelineIndex][fieldName] = value;
                            }
                        } 
                        else {
                            // Otherwise, set the value directly
                            current[lastKey] = value;
                        }
                
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('Update data error:', error);
                        TranslatorApp.ui.showAlert('فشل في تحديث البيانات.', 'error');
                    }
                },

                generateInitialDiffs(fileIndex) {
                    try {
                        const originalData = TranslatorApp.state.originalJsonData[fileIndex].data;
                        const processPath = (path) => {
                            try {
                                if (originalData === undefined || originalData === null) return;
                                this.updateDiff(fileIndex, path);
                            } catch (error) {
                                console.warn(`Error processing path ${path}:`, error);
                            }
                        };
                        processPath('statement');
                        originalData.parts?.forEach((part, partIndex) => {
                            processPath(`parts.${partIndex}.stem`);
                            if (typeof part.answer === 'string') processPath(`parts.${partIndex}.answer`);
                            part.choices?.forEach((choice, choiceIndex) => {
                                processPath(`parts.${partIndex}.choices.${choiceIndex}.html_content`);
                            });
                            part.gap_text_keys?.forEach((keyItem, keyIndex) => {
                                processPath(`parts.${partIndex}.gap_text_keys.${keyIndex}.value`);
                            });
                            // Process ai.guidelines
                            part.ai?.guidelines?.forEach((guideline, guidelineIndex) => {
                                if (guideline.student_answer) processPath(`parts.${partIndex}.ai.guidelines.${guidelineIndex}.student_answer`);
                                if (guideline.comment) processPath(`parts.${partIndex}.ai.guidelines.${guidelineIndex}.comment`);
                            });
                        });
                    } catch (error) {
                        console.error('Generate initial diffs error:', error);
                    }
                },

                updateDiff(fileIndex, path) {
                    try {
                        const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                        const diffId = `diff-${fieldId}`;
                        const diffContainer = document.getElementById(diffId);
                        if (!diffContainer) return;

                        const keys = path.split('.');
                        // Compare initial translation with current translation (both in Arabic)
                        let initialText = TranslatorApp.state.initialTranslatedJsonData[fileIndex]?.data;
                        let currentText = TranslatorApp.state.translatedJsonData[fileIndex].data;
                        
                        for (let i = 0; i < keys.length; i++) {
                            initialText = initialText ? initialText[keys[i]] : '';
                            currentText = currentText ? currentText[keys[i]] : '';
                        }

                        const cleanInitial = this.plainTextForDiff(initialText || '');
                        const cleanCurrent = this.plainTextForDiff(currentText || '');

                        diffContainer.innerHTML = this.createDiffHtml(cleanInitial, cleanCurrent);
                    } catch (error) {
                        console.error('Update diff error:', error);
                    }
                },

                prepareInteractiveMathFields() {
                    try {
                        const mathFields = TranslatorApp.dom.previewContainer.querySelectorAll('math-field');
                        mathFields.forEach(mf => {
                            try {
                                // Check if this math-field is in an editable area
                                const isInEditableArea = mf.closest('.editable-preview-field');
                                const isInOriginal = mf.closest('.original-text-readonly');
                                
                                // Only remove read-only from editable areas
                                if (isInEditableArea) {
                                    mf.removeAttribute('read-only');
                                } else if (isInOriginal) {
                                    // Keep read-only for original text
                                    mf.setAttribute('read-only', 'true');
                                }
                                
                                mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                mf.setAttribute('use-shared-virtual-keyboard', '');
                                
                                // Add delete button only for editable math-fields
                                if (isInEditableArea && !mf.querySelector('.math-field-delete-btn')) {
                                    const deleteBtn = document.createElement('button');
                                    deleteBtn.className = 'math-field-delete-btn';
                                    deleteBtn.textContent = '×';
                                    deleteBtn.title = 'حذف المعادلة';
                                    deleteBtn.onclick = (event) => {
                                        event.stopPropagation();
                                        event.preventDefault();
                                        const fieldContainer = mf.closest('.editable-preview-field');
                                        mf.remove();
                                        if (fieldContainer) {
                                            TranslatorApp.preview.handlePreviewFieldUpdate(fieldContainer);
                                        }
                                    };
                                    mf.appendChild(deleteBtn);
                                }
                                
                                // Add copy button for original math-fields
                                if (isInOriginal && !mf.querySelector('.math-field-copy-btn')) {
                                    const copyBtn = document.createElement('button');
                                    copyBtn.className = 'math-field-copy-btn';
                                    copyBtn.textContent = '📋';
                                    copyBtn.title = 'نسخ المعادلة';
                                    copyBtn.onclick = (event) => {
                                        event.stopPropagation();
                                        event.preventDefault();
                                        const value = mf.value || '';
                                        navigator.clipboard.writeText(`$${value}$`).then(() => {
                                            TranslatorApp.ui.showAlert('تم نسخ المعادلة', 'success', 1500);
                                        });
                                    };
                                    mf.appendChild(copyBtn);
                                }

                                // Enhanced language support for MathLive
                                mf.setAttribute('virtual-keyboard-layout', 'qwerty');
                                mf.setAttribute('virtual-keyboard-theme', 'material');

                                // Enable Arabic and English input
                                mf.setAttribute('virtual-keyboard-languages', 'ar,en');
                                mf.setAttribute('virtual-keyboard-default-language', 'ar');

                                // Set direction based on content
                                const currentValue = mf.value || '';
                                const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(currentValue);
                                const direction = hasArabic ? 'rtl' : 'ltr';
                                mf.setAttribute('dir', direction);

                                // Add language toggle functionality
                                mf.addEventListener('keydown', (e) => {
                                    try {
                                        // Alt + L to toggle language
                                        if (e.altKey && e.key === 'l') {
                                            e.preventDefault();
                                            const currentLang = mf.getAttribute('virtual-keyboard-default-language');
                                            const newLang = currentLang === 'ar' ? 'en' : 'ar';
                                            mf.setAttribute('virtual-keyboard-default-language', newLang);

                                            // Update direction
                                            mf.setAttribute('dir', newLang === 'ar' ? 'rtl' : 'ltr');

                                            // Show feedback
                                            const langText = newLang === 'ar' ? 'العربية' : 'English';
                                            TranslatorApp.ui.showAlert(`تم التبديل إلى ${langText}`, 'info', 1500);
                                        }
                                    } catch (langError) {
                                        console.warn('Language toggle error:', langError);
                                    }
                                });

                                mf.addEventListener('focus', () => {
                                    try {
                                        if (typeof mf.executeCommand === 'function') {
                                            setTimeout(() => {
                                                try {
                                                    mf.executeCommand('showVirtualKeyboard');

                                                    // Set initial language based on content
                                                    const value = mf.value || '';
                                                    const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(value);
                                                    if (hasArabic) {
                                                        mf.setAttribute('virtual-keyboard-default-language', 'ar');
                                                        mf.setAttribute('dir', 'rtl');
                                                    } else {
                                                        mf.setAttribute('virtual-keyboard-default-language', 'en');
                                                        mf.setAttribute('dir', 'ltr');
                                                    }
                                                } catch (keyboardError) {
                                                    console.warn('MathLive keyboard error:', keyboardError);
                                                }
                                            }, 100);
                                        }
                                    } catch (focusError) {
                                        console.warn('MathLive focus error:', focusError);
                                    }
                                }, { once: false });

                                // Add input event to detect language changes
                                mf.addEventListener('input', (e) => {
                                    try {
                                        const value = e.target.value || '';
                                        const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(value);
                                        const hasEnglish = /[a-zA-Z]/.test(value);

                                        // Auto-switch language based on input
                                        if (hasArabic && !hasEnglish) {
                                            mf.setAttribute('virtual-keyboard-default-language', 'ar');
                                            mf.setAttribute('dir', 'rtl');
                                        } else if (hasEnglish && !hasArabic) {
                                            mf.setAttribute('virtual-keyboard-default-language', 'en');
                                            mf.setAttribute('dir', 'ltr');
                                        }
                                        // For mixed content, keep current setting
                                    } catch (inputError) {
                                        console.warn('MathLive input error:', inputError);
                                    }
                                });

                            } catch (fieldError) {
                                console.warn('MathLive field setup error:', fieldError);
                            }
                        });
                    } catch (generalError) {
                        console.warn('MathLive general setup error:', generalError);
                    }
                },

                createDiffHtml(text1, text2) {
                    try {
                        const d = this.dmp.diff_main(text1, text2);
                        this.dmp.diff_cleanupSemantic(d);
                        return this.dmp.diff_prettyHtml(d);
                    } catch (error) {
                        console.error('Create diff HTML error:', error);
                        return `<div style="color: var (--error-color);">فشل في إنشاء مقارنة الفروقات</div>`;
                    }
                },

                plainTextForDiff(html) {
                    try {
                        const div = document.createElement('div');
                        div.innerHTML = html || '';
                        return div.textContent || div.innerText || '';
                    } catch (error) {
                        console.error('Plain text for diff error:', error);
                        return '';
                    }
                },

                // Helper functions for new features
                copyTranslation(fieldId) {
                    try {
                        const field = document.getElementById(fieldId);
                        if (field) {
                            const text = field.textContent || '';
                            navigator.clipboard.writeText(text).then(() => {
                                TranslatorApp.ui.showAlert('تم نسخ الترجمة', 'success', 2000);
                            });
                        }
                    } catch (error) {
                        console.error('Copy translation error:', error);
                    }
                },
                
                restoreAI(fieldId, path, fileIndex) {
                    try {
                        const initialData = TranslatorApp.state.initialTranslatedJsonData[fileIndex];
                        if (!initialData) {
                            TranslatorApp.ui.showAlert('لا توجد ترجمة آلية محفوظة', 'info', 3000);
                            return;
                        }
                        
                        const field = document.getElementById(fieldId);
                        if (field) {
                            // Get initial translation from saved data
                            let data = initialData.data;
                            const keys = path.split('.');
                            for (let key of keys) {
                                data = data[key];
                            }
                            field.innerHTML = TranslatorApp.preview.renderContentWithMath(data);
                            TranslatorApp.preview.handlePreviewFieldUpdate(field);
                            TranslatorApp.ui.showAlert('تم استعادة الترجمة الآلية', 'success', 2000);
                        }
                    } catch (error) {
                        console.error('Restore AI error:', error);
                        TranslatorApp.ui.showAlert('فشل في استعادة الترجمة', 'error');
                    }
                },
                
                toggleNotes(fieldId) {
                    try {
                        const notesDiv = document.getElementById(`notes-${fieldId}`);
                        if (notesDiv) {
                            notesDiv.classList.toggle('hidden');
                        }
                    } catch (error) {
                        console.error('Toggle notes error:', error);
                    }
                },
                
                saveNote(fieldId, noteText) {
                    try {
                        const notes = JSON.parse(localStorage.getItem('translationNotes') || '{}');
                        notes[fieldId] = noteText;
                        localStorage.setItem('translationNotes', JSON.stringify(notes));
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('Save note error:', error);
                    }
                },
                
                loadNotes() {
                    try {
                        const notes = JSON.parse(localStorage.getItem('translationNotes') || '{}');
                        Object.keys(notes).forEach(fieldId => {
                            const textarea = document.querySelector(`#notes-${fieldId} textarea`);
                            if (textarea) {
                                textarea.value = notes[fieldId];
                            }
                        });
                    } catch (error) {
                        console.error('Load notes error:', error);
                    }
                },

                copyOriginalText(button) {
                    try {
                        const fieldContainer = button.closest('.border').querySelector('.original-text-readonly');
                        if (fieldContainer) {
                            const textToCopy = fieldContainer.innerHTML;
                            const textArea = document.createElement('textarea');
                            textArea.value = textToCopy;

                            textArea.style.position = 'fixed';
                            textArea.style.top = '0';
                            textArea.style.left = '0';
                            textArea.style.width = '2em';
                            textArea.style.height = '2em';
                            textArea.style.padding = '0';
                            textArea.style.border = 'none';
                            textArea.style.outline = 'none';
                            textArea.style.boxShadow = 'none';
                            textArea.style.background = 'transparent';

                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();

                            try {
                                const successful = document.execCommand('copy');
                                if (successful) {
                                    TranslatorApp.ui.showAlert('تم نسخ النص الأصلي!', 'success', 2000);
                                } else {
                                    TranslatorApp.ui.showAlert('فشل نسخ النص.', 'error', 2000);
                                }
                            } catch (err) {
                                console.error('Fallback: Oops, unable to copy', err);
                                TranslatorApp.ui.showAlert('فشل نسخ النص.', 'error', 2000);
                            }

                            document.body.removeChild(textArea);
                        } else {
                            TranslatorApp.ui.showAlert('لم يتم العثور على النص المراد نسخه.', 'error', 2000);
                        }
                    } catch (error) {
                        console.error('Copy original text error:', error);
                        TranslatorApp.ui.showAlert('فشل في نسخ النص الأصلي.', 'error', 2000);
                    }
                },

                filter() {
                    try {
                        const term = TranslatorApp.dom.searchPreview.value.toLowerCase();
                        const accordions = document.querySelectorAll('#previewContainer > div');
                        accordions.forEach(accordion => {
                            try {
                                const content = accordion.textContent.toLowerCase();
                                const isVisible = content.includes(term);
                                accordion.style.display = isVisible ? '' : 'none';
                            } catch (error) {
                                console.warn('Error filtering accordion:', error);
                            }
                        });
                    } catch (error) {
                        console.error('Filter error:', error);
                    }
                }
            },
            export: {
                exportAs(format) {
                    return this.toJson();
                },

                async toJson() {
                    const useMappedIds = TranslatorApp.dom.useMappedIdsCheckbox.checked;
                    let mappedIds = [];
                    let idCounter = 0;
                    
                    if (useMappedIds) {
                        try {
                            mappedIds = JSON.parse(TranslatorApp.dom.mappedIdsInput.value);
                            if (!Array.isArray(mappedIds)) throw new Error('not array');
                        } catch (e) {
                            return TranslatorApp.ui.showAlert('قائمة المعرفات (mapped_id) غير صالحة. يرجى التأكد من أنها مصفوفة JSON صحيحة.', 'error');
                        }
                    }
                    
                    const selectedTranslator = TranslatorApp.state.selectedTranslator;
                    const sourceId = TranslatorApp.state.translators[selectedTranslator];
                    
                    const zip = new JSZip();
                    
                    for (const translatedFile of TranslatorApp.state.translatedJsonData) {
                        const finalData = JSON.parse(JSON.stringify(translatedFile.data));
                        const originalId = TranslatorApp.state.originalJsonData.find(f => f.name === translatedFile.name)?.data?.id;
                    
                        finalData.metadata = finalData.metadata || {};
                        finalData.metadata.title = "";
                        finalData.metadata.language = 'ar';
                        finalData.metadata.dialect = ['modern_standard'];
                        finalData.metadata.country = 'eg';
                    
                        if (sourceId) {
                            finalData.metadata.source_id = {
                                "value": parseInt(sourceId),
                                "page_number": null
                            };
                        } else {
                            finalData.metadata.source_id = null;
                        }
                    
                        const stripHtml = (html) => {
                            if (!html) return "";
                            const doc = new DOMParser().parseFromString(html, 'text/html');
                            return doc.body.textContent || "";
                        };
                    
                        const cleanStatement = stripHtml(finalData.statement);
                        const cleanStem = finalData.parts?.[0]?.stem ? stripHtml(finalData.parts[0].stem) : '';
                        let description = (cleanStatement + ' ' + cleanStem).trim();
                        finalData.metadata.description = description;
                    
                        if (finalData.parts) {
                            finalData.parts.forEach((part) => {
                                if (part.type === 'input_box' && part.answer && part.answer.hasOwnProperty('value')) {
                                    const originalUnit = TranslatorApp.state.originalJsonData
                                        .find(f => f.name === translatedFile.name)?.data.parts
                                        .find(p => p.n === part.n)?.answer.unit || '';
                                    part.answer.unit = TranslatorApp.quality.unitsMap[originalUnit.toLowerCase()] || originalUnit;
                                }
                            });
                        }
                    
                        let fileNameToUse = translatedFile.name;
                        // Assign the mapped ID for both export and display
                        if (useMappedIds && idCounter < mappedIds.length) {
                            const newMappedId = mappedIds[idCounter];
                            finalData.metadata.mapped_id = newMappedId;
                            fileNameToUse = `${newMappedId}.json`;
                            idCounter++;
                        } else {
                            finalData.metadata.mapped_id = originalId; // Fallback to original ID for the mapped_id field
                        }
                    
                        zip.file(fileNameToUse, JSON.stringify(finalData, null, 2));
                    }
                    
                    if (useMappedIds && idCounter < TranslatorApp.state.translatedJsonData.length) {
                        TranslatorApp.ui.showAlert(`تحذير: عدد المعرفات (${idCounter}) أقل من عدد الملفات (${TranslatorApp.state.translatedJsonData.length}).`, 'error');
                    }
                    
                    try {
                        const content = await zip.generateAsync({ type: "blob" });
                        const link = document.createElement("a");
                        link.href = URL.createObjectURL(content);
                        link.download = `translated_questions_${new Date().toISOString().replace(/[:.]/g, '-')}.zip`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                        TranslatorApp.ui.showAlert('تم تصدير ملفات JSON بنجاح!', 'success');
                    } catch (e) {
                        console.error('ZIP creation error:', e);
                        TranslatorApp.ui.showAlert(`فشل إنشاء ملف ZIP: ${e.message}`, 'error');
                    }
                },
                annotator: {
                    canvas: null,
                    fabricCanvas: null,
                    currentImage: null,
                    open() {
                        try {
                            const images = TranslatorApp.dom.previewContainer.querySelectorAll('img');
                            if (!images.length) {
                                TranslatorApp.ui.showAlert('لا توجد صور في الصفحة الحالية.', 'info');
                                return;
                            }

                            // Use the first image in view for simplicity
                            this.currentImage = images[0];
                            if (!this.currentImage || !this.currentImage.src) {
                                TranslatorApp.ui.showAlert('الصورة المحددة غير صالحة.', 'error');
                                return;
                            }

                            TranslatorApp.ui.showModal('imageAnnotatorModal', true);
                            setTimeout(() => this.initCanvas(), 0);
                        } catch (error) {
                            console.error('Image annotator open error:', error);
                            TranslatorApp.ui.showAlert(`فشل في فتح محرر الصور: ${error.message}`, 'error');
                        }
                    },
                    close() {
                        try {
                            // Clean up Fabric.js canvas
                            if (this.fabricCanvas) {
                                this.fabricCanvas.dispose();
                                this.fabricCanvas = null;
                            }
                            this.currentImage = null;
                            TranslatorApp.ui.showModal('imageAnnotatorModal', false);
                        } catch (error) {
                            console.error('Image annotator close error:', error);
                            TranslatorApp.ui.showModal('imageAnnotatorModal', false);
                        }
                    },
                    initCanvas() {
                        try {
                            const canvasEl = TranslatorApp.dom.imageAnnotatorCanvas;
                            const img = this.currentImage;
                            if (!canvasEl || !img) {
                                TranslatorApp.ui.showAlert('عناصر Canvas أو الصورة غير متوفرة.', 'error');
                                return;
                            }

                            // Set canvas dimensions
                            canvasEl.width = img.naturalWidth || img.width || 800;
                            canvasEl.height = img.naturalHeight || img.height || 600;

                            // Initialize Fabric.js canvas
                            this.fabricCanvas = new fabric.Canvas(canvasEl, { selection: true });

                            // Load image into canvas
                            fabric.Image.fromURL(img.src, (oImg) => {
                                try {
                                    oImg.selectable = false;
                                    oImg.evented = false;
                                    oImg.scaleToWidth(canvasEl.width);
                                    this.fabricCanvas.add(oImg).sendToBack(oImg);
                                } catch (imgError) {
                                    console.error('Image loading error:', imgError);
                                    TranslatorApp.ui.showAlert('فشل في تحميل الصورة إلى المحرر.', 'error');
                                }
                            }, { crossOrigin: 'anonymous' });

                            // Add helper text tool with RTL support
                            this.fabricCanvas.on('mouse:dblclick', (e) => {
                                try {
                                    const pointer = this.fabricCanvas.getPointer(e.e);
                                    const textbox = new fabric.Textbox('نص', {
                                        left: pointer.x,
                                        top: pointer.y,
                                        fontSize: 24,
                                        fill: '#111827',
                                        backgroundColor: 'rgba(255,255,255,0.7)'
                                    });
                                    this.fabricCanvas.add(textbox).setActiveObject(textbox);
                                } catch (textError) {
                                    console.error('Text tool error:', textError);
                                }
                            });
                        } catch (error) {
                            console.error('Canvas initialization error:', error);
                            TranslatorApp.ui.showAlert(`فشل في تهيئة محرر الصور: ${error.message}`, 'error');
                        }
                    },
                    save() {
                        if (!this.fabricCanvas) {
                            TranslatorApp.ui.showAlert('لا يوجد محتوى للحفظ.', 'error');
                            return;
                        }

                        try {
                            const dataUrl = this.fabricCanvas.toDataURL({ format: 'png', quality: 1 });
                            if (!dataUrl || dataUrl === 'data:,') {
                                throw new Error('فشل في إنشاء صورة البيانات');
                            }

                            // Replace the image in preview with annotated version (non-destructive – just in UI)
                            this.currentImage.src = dataUrl;
                            TranslatorApp.state.hasUnsavedChanges = true;
                            this.close();
                            TranslatorApp.ui.showAlert('تم حفظ التعديلات على الصورة (محلياً).', 'success');
                        } catch (error) {
                            console.error('Image save error:', error);
                            TranslatorApp.ui.showAlert(`فشل في حفظ الصورة: ${error.message}`, 'error');
                        }
                    }
                }
            },
            
            /**
             * Validate that all required fields are selected before enabling translation
             */
            validateTranslationRequirements() {
                try {
                    const subject = this.state.selectedSubject || this.dom.subjectSelect?.value || 'None';
                    const grade = this.state.selectedGrade || this.dom.gradeSelect?.value || 'None';
                    const translator = this.state.selectedTranslator || this.dom.translatorSelect?.value || '';
                    const hasFiles = this.state.selectedFilesInfo && this.state.selectedFilesInfo.length > 0;
                    
                    // Check if all required fields are filled
                    const isSubjectValid = subject && subject !== 'None';
                    const isGradeValid = grade && grade !== 'None';
                    const isTranslatorValid = translator && translator !== '';
                    const allValid = isSubjectValid && isGradeValid && isTranslatorValid && hasFiles;
                    
                    // Enable or disable the translate button
                    if (this.dom.translateBtn) {
                        this.dom.translateBtn.disabled = !allValid;
                        
                        // Update button appearance
                        if (!allValid) {
                            this.dom.translateBtn.style.opacity = '0.5';
                            this.dom.translateBtn.style.cursor = 'not-allowed';
                            
                            // Show helpful message
                            const missingFields = [];
                            if (!isSubjectValid) missingFields.push('المادة');
                            if (!isGradeValid) missingFields.push('الصف');
                            if (!isTranslatorValid) missingFields.push('اسم المترجم');
                            if (!hasFiles) missingFields.push('الملفات');
                            
                            this.dom.translateBtn.title = `يرجى اختيار: ${missingFields.join(' و ')}`;
                        } else {
                            this.dom.translateBtn.style.opacity = '1';
                            this.dom.translateBtn.style.cursor = 'pointer';
                            this.dom.translateBtn.title = 'ابدأ عملية الترجمة (Ctrl + Enter)';
                        }
                    }
                    
                    return allValid;
                } catch (error) {
                    console.error('Validate translation requirements error:', error);
                    return false;
                }
            }
        };


        document.addEventListener('DOMContentLoaded', () => TranslatorApp.init());

    </script>



    <script>
        // هذه الدالة تقوم بإنشاء زر تبديل اللغة وإضافته إلى لوحة المفاتيح
        function addLanguageToggleButton() {
            // ابحث عن لوحة المفاتيح في الصفحة
            const keyboard = document.querySelector('.ML__keyboard');

            // إذا لم تكن لوحة المفاتيح موجودة، أو كان الزر موجودًا بالفعل، لا تفعل شيئًا
            if (!keyboard || keyboard.querySelector('.lang-toggle-btn')) {
                return;
            }

            // قم بإنشاء عنصر الزر الجديد
            const btn = document.createElement('button');

            // النص الذي سيظهر على الزر
            btn.textContent = 'عربي / EN';

            // كلاس CSS لتمييز الزر
            btn.className = 'lang-toggle-btn';

            // تصميم بسيط للزر ليتناسب مع لوحة المفاتيح
            btn.style.cssText = `
            position: absolute;
            top: 5px;
            right: 170px; /* تم تعديل الموضع ليكون مناسبًا */
            padding: 5px 10px;
            font-size: 14px;
            font-weight: bold;
            background-color: #555;
            color: white;
            border: 1px solid #777;
            border-radius: 6px;
            cursor: pointer;
            z-index: 100;
        `;

            // عند النقر على الزر، قم بتنفيذ نفس الدالة التي كان الاختصار ينفذها
            btn.onclick = () => TranslatorApp.utils.mathLive.toggleLanguage();

            // أضف الزر الجديد إلى لوحة المفاتيح
            keyboard.appendChild(btn);
        }

        // بما أن لوحة المفاتيح تظهر وتختفي، سنقوم بتشغيل الدالة بشكل دوري
        // للتحقق من ظهورها وإضافة الزر كل نصف ثانية
        setInterval(addLanguageToggleButton, 500);
    </script>
</body>

</html>
