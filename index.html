<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…ØªØ±Ø¬Ù… Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ø­ØªØ±Ù</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Quill.js Editor -->
    <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- General Styles & Theming --- */
        :root {
            --bg-color: #f3f4f6;
            --text-color: #1f2937;
            --card-bg: #ffffff;
            --card-border: #e5e7eb;
            --input-bg: #ffffff;
            --input-border: #d1d5db;
            --primary-color: #4f46e5;
            --primary-hover: #4338ca;
            --secondary-text: #6b7280;
            --success-color: #10b981;
            --error-color: #ef4444;
            --highlight-bg: #fef9c3; /* Yellow-100 */
        }

        [data-theme="dark"] {
            --bg-color: #111827;
            --text-color: #f9fafb;
            --card-bg: #1f2937;
            --card-border: #374151;
            --input-bg: #374151;
            --input-border: #4b5563;
            --primary-color: #6366f1;
            --primary-hover: #818cf8;
            --secondary-text: #9ca3af;
            --highlight-bg: #4d4318;
        }

        body {
            font-family: 'Cairo', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        .main-card, .preview-card {
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        input, select {
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
        }

        .dragover {
            border-color: var(--primary-color);
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--bg-color));
        }

        .api-selector input[type="radio"]:checked + label {
            border-color: var(--primary-color);
            background-color: color-mix(in srgb, var(--primary-color) 15%, var(--card-bg));
            color: var(--primary-color);
        }
        
        /* --- Quill Editor Styles --- */
        .ql-editor {
            min-height: 80px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-family: 'Cairo', sans-serif;
        }
        .ql-toolbar {
            background-color: color-mix(in srgb, var(--card-border) 50%, var(--card-bg));
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
            border-bottom: 1px solid var(--card-border) !important;
        }
        .ql-container {
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
        .ql-snow .ql-stroke {
            stroke: var(--text-color);
        }
        .ql-snow .ql-picker-label {
            color: var(--text-color);
        }

        /* --- Alert System --- */
        .alert {
            transition: all 0.5s ease-in-out;
            opacity: 1;
            transform: translateX(0);
        }
        .alert.fade-out {
            opacity: 0;
            transform: translateX(100%);
        }
        
        /* --- Search Highlight --- */
        .search-highlight {
            background-color: var(--highlight-bg);
            color: var(--text-color);
            border-radius: 3px;
        }

        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            .comparison-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body class="text-gray-800">

    <!-- Container for alerts -->
    <div id="alertContainer" class="fixed top-0 right-0 p-4 w-full max-w-md z-50 space-y-3"></div>

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-4xl md:text-5xl font-bold" style="color: var(--primary-color);">ğŸŒ Ù…ØªØ±Ø¬Ù… Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ø­ØªØ±Ù</h1>
            <div class="flex items-center gap-4">
                <button id="theme-toggle" class="text-2xl">â˜€ï¸</button>
                <button id="newSessionBtn" class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition">
                    Ø¨Ø¯Ø¡ Ø¬Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©
                </button>
            </div>
        </div>
        <p class="mt-2 mb-8 text-center text-lg" style="color: var(--secondary-text);">ØªØ±Ø¬Ù…Ø© Ù…Ù„ÙØ§Øª JSONØŒ Ù…Ø¹ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØ§Ù„ØªØ¹Ø¯ÙŠÙ„ØŒ Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§ØªØŒ ÙˆØ¯Ø¹Ù… Ø§Ù„Ø³Ù…Ø§Øª.</p>
        
        <!-- Step 1: Settings and Upload -->
        <div id="setupSection" class="main-card p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4 border-b-2 pb-2" style="color: var(--primary-color); border-color: var(--primary-color-light);">Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª</h3>
            
            <div class="grid md:grid-cols-2 gap-6">
                <!-- Left Column: Settings -->
                <div>
                    <div class="mb-6">
                        <label class="block mb-2 font-semibold">Ø§Ø®ØªØ± Ù…ÙØ²ÙˆÙ‘Ø¯ Ø§Ù„Ø®Ø¯Ù…Ø©:</label>
                        <div class="api-selector grid grid-cols-2 gap-4">
                            <div>
                                <input type="radio" id="geminiProvider" name="apiProvider" value="gemini" class="hidden" checked>
                                <label for="geminiProvider" class="block text-center p-4 border-2 rounded-lg cursor-pointer transition">
                                    <span class="font-bold">ğŸ¤– Google Gemini</span>
                                </label>
                            </div>
                            <div>
                                <input type="radio" id="chatgptProvider" name="apiProvider" value="chatgpt" class="hidden">
                                <label for="chatgptProvider" class="block text-center p-4 border-2 rounded-lg cursor-pointer transition">
                                    <span class="font-bold">ğŸ’¬ OpenAI ChatGPT</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div id="geminiKeyGroup" class="mb-6">
                        <label for="geminiKey" class="block mb-2 font-semibold">Ù…ÙØªØ§Ø­ Gemini API:</label>
                        <input type="password" id="geminiKey" placeholder="ÙŠØ¨Ø¯Ø£ Ø¨Ù€ AIza..." class="w-full p-3 rounded-lg focus:ring-2 transition" style="border-color: var(--input-border); focus-ring-color: var(--primary-color);">
                    </div>
                    
                    <div id="chatgptKeyGroup" class="mb-6 hidden">
                        <label for="chatgptKey" class="block mb-2 font-semibold">Ù…ÙØªØ§Ø­ OpenAI API:</label>
                        <input type="password" id="chatgptKey" placeholder="ÙŠØ¨Ø¯Ø£ Ø¨Ù€ sk-..." class="w-full p-3 rounded-lg focus:ring-2 transition" style="border-color: var(--input-border); focus-ring-color: var(--primary-color);">
                    </div>

                    <div class="flex items-center justify-between mb-6 p-3 rounded-lg" style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                        <button id="manageGlossaryBtn" type="button" class="font-semibold" style="color: var(--primary-color);">ğŸ“– Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚Ø§Ù…ÙˆØ³ Ø§Ù„Ù…Ø®ØµØµ</button>
                        <div class="flex items-center">
                            <input id="useGlossaryCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2" style="color: var(--primary-color); border-color: var(--input-border); focus-ring-color: var(--primary-color);">
                            <label for="useGlossaryCheckbox" class="mr-2 text-sm font-medium">Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù‚Ø§Ù…ÙˆØ³</label>
                        </div>
                    </div>
                </div>

                <!-- Right Column: File Upload -->
                <div>
                    <div class="mb-4">
                        <label class="block mb-2 font-semibold">Ù…Ù„ÙØ§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (JSON):</label>
                        <div id="fileUpload" class="border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition" style="border-color: var(--input-border);">
                            <div style="color: var(--primary-color);" class="text-4xl mb-2">ğŸ“¤</div>
                            <p class="font-semibold">Ø§Ø³Ø­Ø¨ ÙˆØ£ÙÙ„Øª Ø§Ù„Ù…Ù„ÙØ§Øª Ù‡Ù†Ø§ Ø£Ùˆ Ø§Ù†Ù‚Ø± Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±</p>
                            <p class="text-sm mt-1" style="color: var(--secondary-text);">ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ù…Ù„ÙØ§Øª Ø¨ØµÙŠØºØ© JSON</p>
                            <input type="file" id="fileInput" multiple accept=".json" class="hidden">
                        </div>
                    </div>
                    <div id="fileList" class="space-y-2 max-h-40 overflow-y-auto"></div>
                </div>
            </div>
            
            <button id="translateBtn" class="w-full text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none mt-6" style="background-color: var(--primary-color);">
                ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ù„ÙØ§Øª (Ctrl + Enter)
            </button>
        </div>

        <!-- Step 2: Progress -->
        <div id="progressContainer" class="hidden main-card p-6 rounded-2xl shadow-lg mb-6 text-center">
             <div class="w-16 h-16 border-4 border-dashed rounded-full animate-spin mx-auto" style="border-color: var(--primary-color); border-top-color: transparent;"></div>
             <p id="progressText" class="mt-4 text-lg font-semibold">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©...</p>
        </div>
        
        <!-- Analytics Section -->
        <div id="analyticsSection" class="hidden main-card p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4" style="color: var(--primary-color);">ğŸ“Š ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¬Ù…Ø©</h3>
            <div id="statsContainer" class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                <!-- Stats will be injected here -->
            </div>
        </div>


        <!-- Step 3: Preview and Edit -->
        <div id="previewSection" class="hidden">
            <div class="main-card p-4 rounded-2xl shadow-lg mb-6">
                <div class="flex flex-wrap gap-4 items-center justify-between">
                    <div>
                        <h3 class="text-2xl font-bold" style="color: var(--success-color);">Ø§Ù„Ø®Ø·ÙˆØ© 2: Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ±Ø¬Ù…Ø©</h3>
                        <p class="mt-1" style="color: var(--secondary-text);">Ø±Ø§Ø¬Ø¹ Ø§Ù„ØªØ±Ø§Ø¬Ù…ØŒ Ø¹Ø¯Ù‘Ù„Ù‡Ø§ØŒ ÙˆØ§Ø¨Ø­Ø« ÙÙŠÙ‡Ø§.</p>
                    </div>
                    <div class="flex items-center gap-2">
                        <button id="undoBtn" disabled class="px-3 py-2 rounded-lg disabled:opacity-50">â†©ï¸ ØªØ±Ø§Ø¬Ø¹</button>
                        <button id="redoBtn" disabled class="px-3 py-2 rounded-lg disabled:opacity-50">â†ªï¸ Ø¥Ø¹Ø§Ø¯Ø©</button>
                    </div>
                </div>
                 <!-- Preview Controls -->
                <div class="preview-controls my-4 p-4 rounded-lg" style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                    <div class="flex flex-wrap gap-4 items-center">
                        <div class="flex-grow">
                            <input type="text" id="searchPreview" placeholder="Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†ØµÙˆØµ..." class="w-full p-2 border rounded-lg">
                        </div>
                    </div>
                </div>
            </div>

            <div id="previewContainer" class="space-y-8">
                <!-- Preview cards will be inserted here -->
            </div>

            <div class="main-card mt-8 p-4 rounded-2xl shadow-lg flex items-center justify-center gap-4">
                <label for="exportFormat" class="font-semibold">ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØµØ¯ÙŠØ±:</label>
                <select id="exportFormat" class="p-2 rounded-lg">
                    <option value="json">JSON</option>
                    <option value="csv">CSV</option>
                </select>
                <button id="exportBtn" class="text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105" style="background-color: var(--success-color);">
                    ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ØªØ±Ø¬Ù…Ø©
                </button>
            </div>
        </div>

    </div>

    <!-- Glossary Modal -->
    <div id="glossaryModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-2xl transform transition-all">
            <div class="flex justify-between items-center">
                <h3 class="text-2xl font-bold" style="color: var(--primary-color);">Ø§Ù„Ù‚Ø§Ù…ÙˆØ³ Ø§Ù„Ù…Ø®ØµØµ</h3>
                <button id="closeGlossaryModalBtn" class="text-2xl hover:opacity-75">&times;</button>
            </div>
            <p class="text-sm mt-1 mb-4" style="color: var(--secondary-text);">Ø£Ø¶Ù Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª ÙˆØªØ±Ø¬Ù…ØªÙ‡Ø§ Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø© Ù„Ø¶Ù…Ø§Ù† Ø§Ù„Ø§ØªØ³Ø§Ù‚.</p>
            
            <!-- Glossary Controls -->
            <div class="flex flex-wrap gap-2 mb-4">
                <button id="importGlossaryBtn" class="flex-1 px-4 py-2 text-white rounded-lg" style="background-color: var(--primary-color);">Ø§Ø³ØªÙŠØ±Ø§Ø¯</button>
                <button id="exportGlossaryBtn" class="flex-1 px-4 py-2 text-white rounded-lg" style="background-color: var(--success-color);">ØªØµØ¯ÙŠØ±</button>
                <input type="file" id="glossaryFileInput" accept=".json" class="hidden">
            </div>
            <input type="text" id="glossarySearch" placeholder="Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù‚Ø§Ù…ÙˆØ³..." class="w-full p-2 mb-4 border rounded-lg">

            <!-- Add Term Form -->
            <div class="grid md:grid-cols-3 gap-4 mb-4">
                <input type="text" id="glossaryTerm" placeholder="Ø§Ù„Ù…ØµØ·Ù„Ø­ Ø§Ù„Ø£ØµÙ„ÙŠ" class="md:col-span-1 block w-full p-2 border rounded-md shadow-sm">
                <input type="text" id="glossaryTranslation" placeholder="Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø©" class="md:col-span-1 block w-full p-2 border rounded-md shadow-sm">
                <select id="glossaryCategory" class="md:col-span-1 block w-full p-2 border rounded-md shadow-sm">
                    <option value="general">Ø¹Ø§Ù…</option>
                    <option value="technical">ØªÙ‚Ù†ÙŠ</option>
                    <option value="medical">Ø·Ø¨ÙŠ</option>
                    <option value="legal">Ù‚Ø§Ù†ÙˆÙ†ÙŠ</option>
                </select>
            </div>
            <button id="addGlossaryTermBtn" class="text-white px-4 py-2 rounded-lg w-full mb-4" style="background-color: var(--primary-color);">Ø¥Ø¶Ø§ÙØ© Ù…ØµØ·Ù„Ø­</button>
            
            <hr class="my-4" style="border-color: var(--card-border);">
            <h4 class="text-lg font-semibold mb-2">Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©</h4>
            <div id="glossaryListContainer" class="max-h-60 overflow-y-auto p-2 rounded-md" style="background-color: var(--bg-color);">
                <!-- Glossary items will be rendered here -->
            </div>
        </div>
    </div>

    <script>
        const TranslatorApp = {
            // --- STATE ---
            state: {
                selectedFilesInfo: [],
                originalJsonData: [],
                translatedJsonData: [],
                glossary: [],
                activeScreen: 'setup',
                translationCache: new Map(),
                startTime: null,
                hasUnsavedChanges: false,
            },

            // --- DOM ELEMENTS ---
            dom: {},

            // --- INITIALIZATION ---
            init() {
                this.cacheDomElements();
                this.bindEvents();
                this.theme.init();
                this.history.init();
                this.session.load();
                this.shortcuts.init();
                this.autoSave.init();
            },

            cacheDomElements() {
                const elementMap = {
                    alertContainer: 'alertContainer', newSessionBtn: 'newSessionBtn',
                    fileUpload: 'fileUpload', fileInput: 'fileInput', fileList: 'fileList',
                    translateBtn: 'translateBtn', geminiKeyInput: 'geminiKey', chatgptKeyInput: 'chatgptKey',
                    geminiKeyGroup: 'geminiKeyGroup', chatgptKeyGroup: 'chatgptKeyGroup',
                    setupSection: 'setupSection', progressContainer: 'progressContainer', progressText: 'progressText',
                    previewSection: 'previewSection', previewContainer: 'previewContainer', exportBtn: 'exportBtn',
                    manageGlossaryBtn: 'manageGlossaryBtn', glossaryModal: 'glossaryModal',
                    closeGlossaryModalBtn: 'closeGlossaryModalBtn', addGlossaryTermBtn: 'addGlossaryTermBtn',
                    glossaryTermInput: 'glossaryTerm', glossaryTranslationInput: 'glossaryTranslation',
                    glossaryListContainer: 'glossaryListContainer', useGlossaryCheckbox: 'useGlossaryCheckbox',
                    themeToggle: 'theme-toggle', analyticsSection: 'analyticsSection',
                    statsContainer: 'statsContainer', exportFormat: 'exportFormat',
                    searchPreview: 'searchPreview', undoBtn: 'undoBtn', redoBtn: 'redoBtn',
                    importGlossaryBtn: 'importGlossaryBtn', exportGlossaryBtn: 'exportGlossaryBtn',
                    glossaryFileInput: 'glossaryFileInput', glossarySearch: 'glossarySearch',
                    glossaryCategory: 'glossaryCategory'
                };
                for (const key in elementMap) { this.dom[key] = document.getElementById(elementMap[key]); }
                this.dom.apiProviderRadios = document.querySelectorAll('input[name="apiProvider"]');
            },
            
            // --- EVENTS ---
            bindEvents() {
                // Main App Events
                this.dom.newSessionBtn.addEventListener('click', this.session.clear.bind(this));
                this.dom.apiProviderRadios.forEach(radio => radio.addEventListener('change', this.events.onApiProviderChange.bind(this)));
                this.dom.fileUpload.addEventListener('click', () => this.dom.fileInput.click());
                this.dom.fileUpload.addEventListener('dragover', this.events.onDragOver);
                this.dom.fileUpload.addEventListener('dragleave', this.events.onDragLeave);
                this.dom.fileUpload.addEventListener('drop', this.events.onFileDrop.bind(this));
                this.dom.fileInput.addEventListener('change', this.events.onFileSelect.bind(this));
                this.dom.translateBtn.addEventListener('click', this.startTranslationProcess.bind(this));
                this.dom.exportBtn.addEventListener('click', () => this.export.exportAs(this.dom.exportFormat.value));
                this.dom.geminiKeyInput.addEventListener('input', () => this.state.hasUnsavedChanges = true);
                this.dom.chatgptKeyInput.addEventListener('input', () => this.state.hasUnsavedChanges = true);
                this.dom.themeToggle.addEventListener('click', this.theme.toggle.bind(this));
                
                // Preview Events
                this.dom.searchPreview.addEventListener('input', this.preview.filter.bind(this.preview));
                this.dom.undoBtn.addEventListener('click', this.history.undo.bind(this.history));
                this.dom.redoBtn.addEventListener('click', this.history.redo.bind(this.history));

                // Glossary Events
                this.dom.manageGlossaryBtn.addEventListener('click', () => this.ui.showGlossaryModal(true));
                this.dom.closeGlossaryModalBtn.addEventListener('click', () => this.ui.showGlossaryModal(false));
                this.dom.addGlossaryTermBtn.addEventListener('click', this.glossary.add.bind(this));
                this.dom.exportGlossaryBtn.addEventListener('click', this.glossary.export.bind(this.glossary));
                this.dom.importGlossaryBtn.addEventListener('click', () => this.dom.glossaryFileInput.click());
                this.dom.glossaryFileInput.addEventListener('change', (e) => this.glossary.import(e.target.files[0]));
                this.dom.glossarySearch.addEventListener('input', (e) => this.glossary.filter(e.target.value));
            },
            
            events: {
                onApiProviderChange(e) {
                    const isGemini = e.target.value === 'gemini';
                    this.dom.geminiKeyGroup.classList.toggle('hidden', !isGemini);
                    this.dom.chatgptKeyGroup.classList.toggle('hidden', isGemini);
                    this.state.hasUnsavedChanges = true;
                },
                onDragOver(e) { e.preventDefault(); e.currentTarget.classList.add('dragover'); },
                onDragLeave(e) { e.currentTarget.classList.remove('dragover'); },
                onFileDrop(e) { e.preventDefault(); this.dom.fileUpload.classList.remove('dragover'); this.fileHandler.addFiles(e.dataTransfer.files); },
                onFileSelect(e) { this.fileHandler.addFiles(e.target.files); }
            },

            // --- THEME MANAGEMENT ---
            theme: {
                init() {
                    const savedTheme = localStorage.getItem('translatorTheme') || 'light';
                    this.set(savedTheme);
                },
                toggle() {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                    this.set(newTheme);
                },
                set(themeName) {
                    document.documentElement.setAttribute('data-theme', themeName);
                    localStorage.setItem('translatorTheme', themeName);
                    TranslatorApp.dom.themeToggle.textContent = themeName === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
                }
            },

            // --- SHORTCUTS ---
            shortcuts: {
                init() {
                    document.addEventListener('keydown', (e) => {
                        if (e.ctrlKey || e.metaKey) {
                            switch(e.key.toLowerCase()) {
                                case 's': 
                                    e.preventDefault(); 
                                    TranslatorApp.session.save();
                                    TranslatorApp.ui.showAlert('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¬Ù„Ø³Ø©!', 'success', 2000);
                                    break;
                                case 'o': 
                                    e.preventDefault(); 
                                    TranslatorApp.dom.fileInput.click(); 
                                    break;
                                case 'enter': 
                                    if(TranslatorApp.state.activeScreen === 'setup' && !e.target.closest('.ql-editor')) {
                                        e.preventDefault(); 
                                        TranslatorApp.dom.translateBtn.click();
                                    }
                                    break;
                                case 'z':
                                    e.preventDefault();
                                    TranslatorApp.history.undo();
                                    break;
                                case 'y':
                                    e.preventDefault();
                                    TranslatorApp.history.redo();
                                    break;
                            }
                        }
                    });
                }
            },
            
            // --- SECURITY ---
            security: {
                SALT: "a-secure-static-salt-for-obfuscation",
                encrypt(key) {
                    try {
                        return btoa(key + this.SALT);
                    } catch {
                        return '';
                    }
                },
                decrypt(encryptedKey) {
                    try {
                        const decoded = atob(encryptedKey);
                        if (decoded.endsWith(this.SALT)) {
                            return decoded.slice(0, -this.SALT.length);
                        }
                        return ''; // Or handle as tampered key
                    } catch {
                        return '';
                    }
                },
                sanitize(text) {
                    if (typeof text !== 'string') return text;
                    // This is a basic sanitizer. For production, a library like DOMPurify is recommended.
                    return text.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                }
            },

            // --- SESSION & AUTOSAVE ---
            session: {
                save() {
                    const sessionData = {
                        apiKeys: {
                            gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                            chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value),
                        },
                        selectedProvider: document.querySelector('input[name="apiProvider"]:checked').value,
                        selectedFilesInfo: TranslatorApp.state.selectedFilesInfo,
                        originalJsonData: TranslatorApp.state.originalJsonData,
                        translatedJsonData: TranslatorApp.state.translatedJsonData,
                        glossary: TranslatorApp.state.glossary,
                        activeScreen: TranslatorApp.state.activeScreen,
                    };
                    localStorage.setItem('translatorSession', JSON.stringify(sessionData));
                    TranslatorApp.state.hasUnsavedChanges = false;
                },
                load() {
                    const savedSession = localStorage.getItem('translatorSession');
                    if (!savedSession) return;
                    
                    const sessionData = JSON.parse(savedSession);
                    TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(sessionData.apiKeys?.gemini || '');
                    TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(sessionData.apiKeys?.chatgpt || '');
                    
                    TranslatorApp.state.selectedFilesInfo = sessionData.selectedFilesInfo || [];
                    TranslatorApp.state.originalJsonData = sessionData.originalJsonData || [];
                    TranslatorApp.state.translatedJsonData = sessionData.translatedJsonData || [];
                    TranslatorApp.state.glossary = sessionData.glossary || [];
                    TranslatorApp.state.activeScreen = sessionData.activeScreen || 'setup';
                    
                    if (sessionData.selectedProvider) {
                        document.querySelector(`input[name="apiProvider"][value="${sessionData.selectedProvider}"]`).checked = true;
                        TranslatorApp.events.onApiProviderChange({ target: { value: sessionData.selectedProvider } });
                    }
                    
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.glossary.render();
                    
                    if (TranslatorApp.state.activeScreen === 'preview' && TranslatorApp.state.translatedJsonData.length > 0) {
                        TranslatorApp.ui.showScreen('preview');
                        TranslatorApp.preview.render();
                        const stats = TranslatorApp.statistics.calculate();
                        TranslatorApp.ui.renderStatistics(stats);
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                    } else {
                        TranslatorApp.ui.showScreen('setup');
                    }
                    TranslatorApp.ui.showAlert('ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                },
                clear() {
                    localStorage.removeItem('translatorSession');
                    location.reload();
                }
            },
            
            autoSave: {
                init() {
                    setInterval(() => {
                        if (TranslatorApp.state.hasUnsavedChanges) {
                            TranslatorApp.session.save();
                            TranslatorApp.ui.showAlert('ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ', 'info', 1500);
                        }
                    }, 10000); // Check for changes every 10 seconds
                }
            },

            // --- VALIDATION ---
            validation: {
                validateJsonStructure(data, fileName) {
                    const requiredFields = ['statement', 'parts'];
                    const hasAllFields = requiredFields.every(field => data.hasOwnProperty(field));
                    if (!hasAllFields) {
                        throw new Error(`Ù…Ù„Ù ${fileName} ÙŠÙØªÙ‚Ø¯ Ù„Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© (statement, parts).`);
                    }
                    return true;
                },
                validateApiKey(key, provider) {
                    if (!key) return false;
                    if (provider === 'gemini') return key.startsWith('AIza') && key.length > 30;
                    if (provider === 'chatgpt') return key.startsWith('sk-') && key.length > 40;
                    return false;
                }
            },

            // --- FILE HANDLING ---
            fileHandler: {
                addFiles(files) {
                    const fileList = Array.from(files).filter(f => f.name.endsWith('.json'));
                    fileList.forEach(file => {
                        if (!TranslatorApp.state.selectedFilesInfo.some(f => f.name === file.name)) {
                            TranslatorApp.state.selectedFilesInfo.push({ name: file.name, size: file.size });
                        }
                    });
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.state.hasUnsavedChanges = true;
                },
                removeFile(index) {
                    TranslatorApp.state.selectedFilesInfo.splice(index, 1);
                    TranslatorApp.state.originalJsonData.splice(index, 1);
                    TranslatorApp.state.translatedJsonData.splice(index, 1);
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.state.hasUnsavedChanges = true;
                },
                async readFilesFromInput() {
                    const fileInputFiles = TranslatorApp.dom.fileInput.files;
                    if (fileInputFiles.length === 0 && TranslatorApp.state.originalJsonData.length === 0) {
                         throw new Error("Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ±Ø¬Ù…Ø©.");
                    }
                    TranslatorApp.state.originalJsonData = [];
                    for (const fileInfo of TranslatorApp.state.selectedFilesInfo) {
                       const file = Array.from(fileInputFiles).find(f => f.name === fileInfo.name);
                       if(file) {
                           const content = await file.text();
                           const jsonData = JSON.parse(content);
                           TranslatorApp.validation.validateJsonStructure(jsonData, file.name);
                           TranslatorApp.state.originalJsonData.push({ name: file.name, data: jsonData });
                       } else if (!TranslatorApp.state.originalJsonData.find(d => d.name === fileInfo.name)) {
                           throw new Error(`Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù ${fileInfo.name}. ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ø¯ÙŠØ¯Ù‡.`);
                       }
                    }
                }
            },

            // --- GLOSSARY ---
            glossary: {
                add() {
                    const term = TranslatorApp.dom.glossaryTermInput.value.trim();
                    const translation = TranslatorApp.dom.glossaryTranslationInput.value.trim();
                    if (!term || !translation) return TranslatorApp.ui.showAlert('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…ØµØ·Ù„Ø­ ÙˆØªØ±Ø¬Ù…ØªÙ‡.', 'error');
                    if (TranslatorApp.state.glossary.some(e => e.term.toLowerCase() === term.toLowerCase())) return TranslatorApp.ui.showAlert('Ù‡Ø°Ø§ Ø§Ù„Ù…ØµØ·Ù„Ø­ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ø§Ù„Ù‚Ø§Ù…ÙˆØ³.', 'error');
                    
                    TranslatorApp.state.glossary.push({ 
                        term, 
                        translation,
                        category: TranslatorApp.dom.glossaryCategory.value,
                        dateAdded: new Date().toISOString()
                    });
                    
                    TranslatorApp.dom.glossaryTermInput.value = '';
                    TranslatorApp.dom.glossaryTranslationInput.value = '';
                    this.render();
                    TranslatorApp.state.hasUnsavedChanges = true;
                },
                delete(index) {
                    TranslatorApp.state.glossary.splice(index, 1);
                    this.render();
                    TranslatorApp.state.hasUnsavedChanges = true;
                },
                render(filteredList = null) {
                    const list = filteredList || TranslatorApp.state.glossary;
                    TranslatorApp.ui.renderGlossaryList(list);
                },
                filter(searchTerm) {
                    const term = searchTerm.toLowerCase();
                    const filtered = TranslatorApp.state.glossary.filter(entry => 
                        entry.term.toLowerCase().includes(term) ||
                        entry.translation.toLowerCase().includes(term)
                    );
                    this.render(filtered);
                },
                export() {
                    if (TranslatorApp.state.glossary.length === 0) {
                        return TranslatorApp.ui.showAlert('Ø§Ù„Ù‚Ø§Ù…ÙˆØ³ ÙØ§Ø±ØºØŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø´ÙŠØ¡ Ù„ØªØµØ¯ÙŠØ±Ù‡.', 'error');
                    }
                    const data = JSON.stringify(TranslatorApp.state.glossary, null, 2);
                    const blob = new Blob([data], { type: 'application/json;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'translator_glossary.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                },
                async import(file) {
                    if (!file) return;
                    try {
                        const text = await file.text();
                        const imported = JSON.parse(text);
                        if (!Array.isArray(imported)) throw new Error("Ø§Ù„Ù…Ù„Ù ØºÙŠØ± ØµØ§Ù„Ø­.");
                        
                        const newEntries = imported.filter(newEntry => 
                            newEntry.term && newEntry.translation &&
                            !TranslatorApp.state.glossary.some(existing => existing.term.toLowerCase() === newEntry.term.toLowerCase())
                        );

                        TranslatorApp.state.glossary = [...TranslatorApp.state.glossary, ...newEntries];
                        this.render();
                        TranslatorApp.state.hasUnsavedChanges = true;
                        TranslatorApp.ui.showAlert(`ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${newEntries.length} Ù…ØµØ·Ù„Ø­ Ø¬Ø¯ÙŠØ¯.`, 'success');
                    } catch (e) {
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù‚Ø§Ù…ÙˆØ³. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ù„Ù Ø¨ØµÙŠØºØ© JSON ØµØ­ÙŠØ­Ø©.', 'error');
                    } finally {
                        TranslatorApp.dom.glossaryFileInput.value = '';
                    }
                },
                apply(text) {
                    const { glossary } = TranslatorApp.state;
                    if (!text || !glossary || glossary.length === 0) return { modifiedText: text, placeholders: {} };
                    let modifiedText = text;
                    const placeholders = {};
                    let placeholderIndex = 0;
                    const sortedGlossary = [...glossary].sort((a, b) => b.term.length - a.term.length);
                    sortedGlossary.forEach(entry => {
                        const regex = new RegExp(`\\b${entry.term}\\b`, 'gi');
                        modifiedText = modifiedText.replace(regex, () => {
                            const placeholder = `__GLOSSARY_${placeholderIndex}__`;
                            placeholders[placeholder] = entry.translation;
                            placeholderIndex++;
                            return placeholder;
                        });
                    });
                    return { modifiedText, placeholders };
                },
                revert(text, placeholders) {
                    if (!placeholders || Object.keys(placeholders).length === 0) return text;
                    return Object.entries(placeholders).reduce((acc, [key, value]) => acc.replaceAll(key, value), text);
                }
            },

            // --- API & TRANSLATION ---
            api: {
                async translateWithRetry(texts, apiKey, provider, maxRetries = 3) {
                    for (let attempt = 1; attempt <= maxRetries; attempt++) {
                        try {
                            TranslatorApp.ui.updateProgress(`Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©... (Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ${attempt}/${maxRetries})`);
                            return await this.translateBatch(texts, apiKey, provider);
                        } catch (error) {
                            console.error(`Attempt ${attempt} failed:`, error);
                            if (attempt === maxRetries) throw error;
                            await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); // Exponential backoff
                        }
                    }
                },
                async translateBatch(texts, apiKey, provider) {
                    const BATCH_SEPARATOR = "\n|||---|||\n";
                    const prompt = `Translate each of the following texts to Arabic, separated by "${BATCH_SEPARATOR}". Keep any HTML tags, LaTeX equations, or placeholders like __GLOSSARY_0__ unchanged. Maintain the exact number of separated texts in your response.\n\n${texts.join(BATCH_SEPARATOR)}`;
                    
                    let responseText;
                    if (provider === 'gemini') {
                        responseText = await this.withGemini(prompt, apiKey);
                    } else {
                        responseText = await this.withChatGPT(prompt, apiKey);
                    }
                    
                    const translatedTexts = responseText.split(BATCH_SEPARATOR.trim());
                    if (translatedTexts.length !== texts.length) {
                        console.error("Mismatch in translated texts count.", { sent: texts.length, received: translatedTexts.length });
                        throw new Error("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ø¬Ù…Ø¹Ø©ØŒ Ø¹Ø¯Ø¯ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ù…ØªØ±Ø¬Ù…Ø© Ù„Ø§ ÙŠØªØ·Ø§Ø¨Ù‚.");
                    }
                    return translatedTexts.map(t => t.trim());
                },
                async withGemini(prompt, apiKey) {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    const response = await fetch(apiUrl, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    });
                    if (!response.ok) { const err = await response.json(); throw new Error(`Gemini API Error: ${err.error?.message || response.statusText}`); }
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                },
                async withChatGPT(prompt, apiKey) {
                    const apiUrl = 'https://api.openai.com/v1/chat/completions';
                    const response = await fetch(apiUrl, {
                        method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify({
                            model: 'gpt-4o',
                            messages: [
                                { role: 'system', content: 'You are a professional translator. You will receive a batch of texts separated by a unique delimiter. Translate each text to Modern Standard Arabic and return them separated by the same delimiter. Do not alter the number of texts.' },
                                { role: 'user', content: prompt }
                            ],
                            temperature: 0.3
                        })
                    });
                    if (!response.ok) { const err = await response.json(); throw new Error(`ChatGPT API Error: ${err.error?.message || response.statusText}`); }
                    const data = await response.json();
                    return data.choices?.[0]?.message?.content || '';
                }
            },
            
            // --- HISTORY (UNDO/REDO) ---
            history: {
                stack: [],
                currentIndex: -1,
                init() {
                    this.updateButtons();
                },
                push(state) {
                    // Debounce pushing to history
                    if (this.timeout) clearTimeout(this.timeout);
                    this.timeout = setTimeout(() => {
                        this.stack = this.stack.slice(0, this.currentIndex + 1);
                        this.stack.push(JSON.parse(JSON.stringify(state)));
                        this.currentIndex++;
                        this.updateButtons();
                    }, 500); // Push state only after 500ms of inactivity
                },
                undo() {
                    if (this.currentIndex > 0) {
                        this.currentIndex--;
                        this.restore(this.stack[this.currentIndex]);
                    }
                },
                redo() {
                    if (this.currentIndex < this.stack.length - 1) {
                        this.currentIndex++;
                        this.restore(this.stack[this.currentIndex]);
                    }
                },
                restore(state) {
                    TranslatorApp.state.translatedJsonData = JSON.parse(JSON.stringify(state));
                    TranslatorApp.preview.render();
                    this.updateButtons();
                    TranslatorApp.state.hasUnsavedChanges = true;
                },
                updateButtons() {
                    TranslatorApp.dom.undoBtn.disabled = this.currentIndex <= 0;
                    TranslatorApp.dom.redoBtn.disabled = this.currentIndex >= this.stack.length - 1;
                }
            },

            // --- MAIN PROCESS ---
            async startTranslationProcess() {
                const apiProvider = document.querySelector('input[name="apiProvider"]:checked').value;
                const apiKey = (apiProvider === 'gemini' ? this.dom.geminiKeyInput.value : this.dom.chatgptKeyInput.value).trim();
                
                if (!this.validation.validateApiKey(apiKey, apiProvider)) {
                    return this.ui.showAlert(`Ù…ÙØªØ§Ø­ API Ù„Ù€ ${apiProvider} ØºÙŠØ± ØµØ§Ù„Ø­ Ø£Ùˆ Ù…ÙÙ‚ÙˆØ¯.`, 'error');
                }
                if (this.state.selectedFilesInfo.length === 0) return this.ui.showAlert('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù JSON ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„.', 'error');

                this.ui.showScreen('progress');
                this.dom.translateBtn.disabled = true;
                this.state.translationCache.clear();
                this.state.startTime = Date.now();

                try {
                    this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„ÙØ§Øª...');
                    await this.fileHandler.readFilesFromInput();
                    this.state.translatedJsonData = JSON.parse(JSON.stringify(this.state.originalJsonData));

                    this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù†ØµÙˆØµ Ù„Ù„ØªØ±Ø¬Ù…Ø©...');
                    const textsToTranslate = [];
                    const useGlossary = this.dom.useGlossaryCheckbox.checked;

                    this.state.originalJsonData.forEach(file => {
                        const processText = (text) => {
                            if (!text || typeof text !== 'string' || !text.trim()) return;
                            const sanitizedText = this.security.sanitize(text);
                            const { modifiedText } = useGlossary ? this.glossary.apply(sanitizedText) : { modifiedText: sanitizedText };
                            if (!this.state.translationCache.has(modifiedText)) {
                                textsToTranslate.push(modifiedText);
                                this.state.translationCache.set(modifiedText, null); // Reserve a spot
                            }
                        };
                        
                        processText(file.data.statement);
                        file.data.parts?.forEach(part => {
                            processText(part.stem);
                            processText(part.answer);
                            part.choices?.forEach(choice => processText(choice.html_content));
                        });
                    });

                    const uniqueTexts = [...new Set(textsToTranslate)];
                    this.ui.updateProgress(`Ø¬Ø§Ø±ÙŠ ØªØ±Ø¬Ù…Ø© ${uniqueTexts.length} Ù†Øµ ÙØ±ÙŠØ¯...`);
                    if (uniqueTexts.length > 0) {
                        const translatedTexts = await this.api.translateWithRetry(uniqueTexts, apiKey, apiProvider);
                        uniqueTexts.forEach((originalText, i) => {
                            this.state.translationCache.set(originalText, translatedTexts[i]);
                        });
                    }

                    this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...');
                    this.state.translatedJsonData.forEach((file, fileIndex) => {
                        const originalFile = this.state.originalJsonData[fileIndex];
                        const updateField = (originalText) => {
                            if (!originalText || typeof originalText !== 'string' || !originalText.trim()) return originalText;
                             const sanitizedText = this.security.sanitize(originalText);
                            const { modifiedText, placeholders } = useGlossary ? this.glossary.apply(sanitizedText) : { modifiedText: sanitizedText, placeholders: {} };
                            const translatedText = this.state.translationCache.get(modifiedText);
                            return translatedText ? this.glossary.revert(translatedText, placeholders) : originalText;
                        };
                        
                        file.data.statement = updateField(originalFile.data.statement);
                        file.data.parts?.forEach((part, partIndex) => {
                            const originalPart = originalFile.data.parts[partIndex];
                            part.stem = updateField(originalPart.stem);
                            part.answer = updateField(originalPart.answer);
                            part.choices?.forEach((choice, choiceIndex) => {
                                choice.html_content = updateField(originalPart.choices[choiceIndex].html_content);
                            });
                        });
                    });

                    this.state.activeScreen = 'preview';
                    this.history.push(this.state.translatedJsonData);
                    this.session.save();
                    this.ui.showScreen('preview');
                    this.preview.render();
                    const stats = this.statistics.calculate();
                    this.ui.renderStatistics(stats);
                    this.ui.showAlert('ØªÙ…Øª Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­!', 'success');

                } catch (error) {
                    console.error('Translation process failed:', error);
                    this.ui.showAlert(error.message, 'error');
                    this.ui.showScreen('setup');
                } finally {
                    this.dom.translateBtn.disabled = false;
                }
            },
            
            // --- STATISTICS ---
            statistics: {
                calculate() {
                    let totalTexts = 0;
                    let totalWords = 0;
                    const count = (text) => {
                        if (text && typeof text === 'string') {
                            totalTexts++;
                            const div = document.createElement('div');
                            div.innerHTML = text;
                            totalWords += (div.textContent || div.innerText || "").split(/\s+/).filter(Boolean).length;
                        }
                    };
                    TranslatorApp.state.originalJsonData.forEach(file => {
                        count(file.data.statement);
                        file.data.parts?.forEach(part => {
                            count(part.stem);
                            count(part.answer);
                            part.choices?.forEach(choice => count(choice.html_content));
                        });
                    });
                    const timeElapsed = TranslatorApp.state.startTime ? ((Date.now() - TranslatorApp.state.startTime) / 1000).toFixed(1) : 0;
                    return {
                        totalFiles: TranslatorApp.state.selectedFilesInfo.length,
                        totalTexts: totalTexts,
                        totalWords: totalWords,
                        timeElapsed: timeElapsed,
                    };
                }
            },

            // --- UI & RENDER ---
            ui: {
                showScreen(screenName) { // screenName can be 'setup', 'progress', or 'preview'
                    TranslatorApp.state.activeScreen = screenName;
                    
                    ['setupSection', 'progressContainer', 'previewSection', 'analyticsSection'].forEach(id => {
                        if (TranslatorApp.dom[id]) {
                            TranslatorApp.dom[id].classList.add('hidden');
                        }
                    });

                    switch(screenName) {
                        case 'setup':
                            if (TranslatorApp.dom.setupSection) TranslatorApp.dom.setupSection.classList.remove('hidden');
                            break;
                        case 'progress':
                            if (TranslatorApp.dom.progressContainer) TranslatorApp.dom.progressContainer.classList.remove('hidden');
                            break;
                        case 'preview':
                            if (TranslatorApp.dom.previewSection) TranslatorApp.dom.previewSection.classList.remove('hidden');
                            if (TranslatorApp.dom.analyticsSection) TranslatorApp.dom.analyticsSection.classList.remove('hidden');
                            break;
                    }
                },
                updateProgress(text) { TranslatorApp.dom.progressText.textContent = text; },
                showAlert(message, type = 'error', duration = 5000) {
                    const colors = { error: 'bg-red-500', success: 'bg-green-500', info: 'bg-blue-500' };
                    const alertBox = document.createElement('div');
                    alertBox.className = `alert flex justify-between items-center text-white p-4 rounded-lg shadow-xl ${colors[type] || 'bg-gray-500'}`;
                    alertBox.innerHTML = `<span>${message}</span><button class="mr-2 text-xl font-bold">&times;</button>`;
                    alertBox.querySelector('button').onclick = () => alertBox.remove();
                    TranslatorApp.dom.alertContainer.appendChild(alertBox);
                    if (duration) { setTimeout(() => { alertBox.classList.add('fade-out'); alertBox.addEventListener('transitionend', () => alertBox.remove()); }, duration); }
                },
                renderFileList() {
                    const { fileList } = TranslatorApp.dom;
                    fileList.innerHTML = '';
                    if (TranslatorApp.state.selectedFilesInfo.length === 0) return;
                    const listContainer = document.createElement('ul');
                    listContainer.className = 'my-4 space-y-2';
                    TranslatorApp.state.selectedFilesInfo.forEach((fileInfo, index) => {
                        const li = document.createElement('li');
                        li.className = 'flex justify-between items-center p-2 rounded-lg'
                        li.style.backgroundColor = 'color-mix(in srgb, var(--primary-color) 5%, var(--card-bg))';
                        li.innerHTML = `<span class="font-medium">${fileInfo.name}</span><button data-index="${index}" class="remove-file-btn text-red-500 hover:text-red-700 font-bold text-xl">&times;</button>`;
                        listContainer.appendChild(li);
                    });
                    fileList.appendChild(listContainer);
                    fileList.querySelectorAll('.remove-file-btn').forEach(btn => { btn.onclick = () => TranslatorApp.fileHandler.removeFile(parseInt(btn.dataset.index)); });
                },
                showGlossaryModal(show) { TranslatorApp.dom.glossaryModal.classList.toggle('hidden', !show); },
                renderGlossaryList(list) {
                    const { glossaryListContainer } = TranslatorApp.dom;
                    glossaryListContainer.innerHTML = '';
                    if (list.length === 0) {
                        glossaryListContainer.innerHTML = `<p class="text-center" style="color: var(--secondary-text)">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ØµØ·Ù„Ø­Ø§Øª.</p>`;
                        return;
                    }
                    const ul = document.createElement('ul');
                    ul.className = 'space-y-2';
                    list.forEach((entry) => {
                        const li = document.createElement('li');
                        li.className = 'flex justify-between items-center p-2 rounded-md border';
                        li.style.backgroundColor = 'var(--card-bg)';
                        li.style.borderColor = 'var(--card-border)';
                        
                        const originalIndex = TranslatorApp.state.glossary.findIndex(g => g.term === entry.term);

                        li.innerHTML = `
                            <div>
                                <span class="font-semibold">${entry.term}</span>
                                <span class="mx-2" style="color: var(--secondary-text)">â†’</span>
                                <span>${entry.translation}</span>
                                <span class="text-xs mr-2 px-2 py-1 rounded-full" style="background-color: var(--bg-color);">${entry.category || 'Ø¹Ø§Ù…'}</span>
                            </div>
                            <button data-index="${originalIndex}" class="remove-glossary-btn text-red-500 hover:text-red-700 font-bold">&times;</button>
                        `;
                        ul.appendChild(li);
                    });
                    glossaryListContainer.appendChild(ul);
                    glossaryListContainer.querySelectorAll('.remove-glossary-btn').forEach(btn => { 
                        btn.onclick = () => TranslatorApp.glossary.delete(parseInt(btn.dataset.index)); 
                    });
                },
                renderStatistics(stats) {
                    const { statsContainer } = TranslatorApp.dom;
                    statsContainer.innerHTML = '';
                    const statsMap = {
                        'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ù„ÙØ§Øª': stats.totalFiles,
                        'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù†ØµÙˆØµ': stats.totalTexts,
                        'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙƒÙ„Ù…Ø§Øª': stats.totalWords,
                        'Ø²Ù…Ù† Ø§Ù„ØªØ±Ø¬Ù…Ø© (Ø«)': stats.timeElapsed,
                    };
                    Object.entries(statsMap).forEach(([label, value]) => {
                        const statCard = document.createElement('div');
                        statCard.className = 'p-4 rounded-lg';
                        statCard.style.backgroundColor = 'color-mix(in srgb, var(--primary-color) 10%, var(--card-bg))';
                        statCard.innerHTML = `
                            <div class="text-2xl font-bold" style="color: var(--primary-color);">${value}</div>
                            <div class="text-sm" style="color: var(--secondary-text);">${label}</div>
                        `;
                        statsContainer.appendChild(statCard);
                    });
                },
            },
            
            // --- ADVANCED PREVIEW MODULE ---
            preview: {
                editorInstances: new Map(),
                
                render() {
                    const { previewContainer } = TranslatorApp.dom;
                    previewContainer.innerHTML = '';
                    this.editorInstances.clear();

                    TranslatorApp.state.translatedJsonData.forEach((file, fileIndex) => {
                        const originalFile = TranslatorApp.state.originalJsonData[fileIndex];
                        const card = document.createElement('div');
                        card.className = 'preview-card p-6 rounded-2xl shadow-lg';
                        card.id = `file-card-${fileIndex}`;
                        
                        card.innerHTML = `
                            <div class="flex flex-wrap justify-between items-center mb-4 gap-2">
                                <h3 class="text-xl font-bold">ğŸ“„ ${file.name}</h3>
                            </div>
                            <div class="comparison-content grid grid-cols-1 lg:grid-cols-2 gap-6">
                                <div class="original-content">
                                    <h4 class="font-semibold mb-3 border-b pb-2" style="color: var(--secondary-text);">Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ</h4>
                                    ${this.renderReadOnlyContent(originalFile.data)}
                                </div>
                                <div class="translated-content">
                                    <h4 class="font-semibold mb-3 border-b pb-2" style="color: var(--success-color);">Ø§Ù„Ù†Øµ Ø§Ù„Ù…ØªØ±Ø¬Ù… (Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„)</h4>
                                    ${this.renderEditableContent(file.data, fileIndex)}
                                </div>
                            </div>
                        `;
                        previewContainer.appendChild(card);
                        this.initEditorsForFile(fileIndex);
                    });
                },

                renderReadOnlyContent(data) {
                    let content = '';
                    const createField = (label, value) => {
                        if (value === undefined || value === null) return '';
                        // FIX: Changed this.security to TranslatorApp.security
                        return `<div class="mb-4"><p class="font-semibold text-sm mb-1">${label}</p><div class="p-3 rounded-lg text-sm" style="background-color: var(--bg-color);">${TranslatorApp.security.sanitize(value)}</div></div>`;
                    };
                    content += createField('Ø§Ù„Ø¨ÙŠØ§Ù† (Statement)', data.statement);
                    data.parts?.forEach((part, partIndex) => {
                        content += `<div class="border-t pt-4 mt-4" style="border-color: var(--card-border);"><h5 class="font-semibold text-md mb-2" style="color: var(--secondary-text);">Ø§Ù„Ø¬Ø²Ø¡ ${partIndex + 1}</h5>`;
                        content += createField('Ø§Ù„Ø³Ø¤Ø§Ù„ (Stem)', part.stem);
                        content += createField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer)', part.answer);
                        if (part.choices) {
                            content += `<div class="mb-3"><p class="font-semibold text-sm mb-1">Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª (Choices):</p><ul class="list-disc list-inside space-y-2 mr-4">`;
                            part.choices.forEach(choice => {
                                // FIX: Changed this.security to TranslatorApp.security
                                content += `<li><div class="p-2 rounded-lg text-sm" style="background-color: var(--bg-color);">${TranslatorApp.security.sanitize(choice.html_content)}</div></li>`;
                            });
                            content += `</ul></div>`;
                        }
                        content += `</div>`;
                    });
                    return content;
                },

                renderEditableContent(data, fileIndex) {
                    let content = '';
                    const createField = (label, value, path) => {
                        if (value === undefined || value === null) return '';
                        const editorId = `editor-${fileIndex}-${path.replace(/\./g, '-')}`;
                        return `<div class="mb-4"><p class="font-semibold text-sm mb-1">${label}</p><div id="${editorId}"></div></div>`;
                    };
                    content += createField('Ø§Ù„Ø¨ÙŠØ§Ù† (Statement)', data.statement, 'statement');
                    data.parts?.forEach((part, partIndex) => {
                        content += `<div class="border-t pt-4 mt-4" style="border-color: var(--card-border);"><h5 class="font-semibold text-md mb-2" style="color: var(--secondary-text);">Ø§Ù„Ø¬Ø²Ø¡ ${partIndex + 1}</h5>`;
                        content += createField('Ø§Ù„Ø³Ø¤Ø§Ù„ (Stem)', part.stem, `parts.${partIndex}.stem`);
                        content += createField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer)', part.answer, `parts.${partIndex}.answer`);
                        if (part.choices) {
                             content += `<div class="mb-3"><p class="font-semibold text-sm mb-1">Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª (Choices):</p><ul class="space-y-2">`;
                            part.choices.forEach((choice, choiceIndex) => {
                                content += `<li>${createField(`Ø®ÙŠØ§Ø± ${choiceIndex + 1}`, choice.html_content, `parts.${partIndex}.choices.${choiceIndex}.html_content`)}</li>`;
                            });
                            content += `</ul></div>`;
                        }
                        content += `</div>`;
                    });
                    return content;
                },

                initEditorsForFile(fileIndex) {
                    const fileData = TranslatorApp.state.translatedJsonData[fileIndex].data;
                    const createEditor = (path, initialContent) => {
                        const editorId = `editor-${fileIndex}-${path.replace(/\./g, '-')}`;
                        const editorDiv = document.getElementById(editorId);
                        if (!editorDiv) return;

                        const quill = new Quill(editorDiv, {
                            theme: 'snow',
                            modules: { toolbar: [['bold', 'italic', 'underline'], [{ 'list': 'ordered'}, { 'list': 'bullet' }]] },
                        });
                        quill.root.innerHTML = initialContent || '';
                        
                        quill.on('text-change', () => {
                            this.updateData(fileIndex, path, quill.root.innerHTML);
                        });
                        this.editorInstances.set(editorId, quill);
                    };

                    createEditor('statement', fileData.statement);
                    fileData.parts?.forEach((part, partIndex) => {
                        createEditor(`parts.${partIndex}.stem`, part.stem);
                        createEditor(`parts.${partIndex}.answer`, part.answer);
                        part.choices?.forEach((choice, choiceIndex) => {
                            createEditor(`parts.${partIndex}.choices.${choiceIndex}.html_content`, choice.html_content);
                        });
                    });
                },

                updateData(fileIndex, path, value) {
                    const keys = path.split('.');
                    let current = TranslatorApp.state.translatedJsonData[fileIndex].data;
                    for (let i = 0; i < keys.length - 1; i++) {
                        current = current[keys[i]];
                    }
                    current[keys[keys.length - 1]] = value;
                    TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                    TranslatorApp.state.hasUnsavedChanges = true;
                },
                
                filter() {
                    const searchTerm = TranslatorApp.dom.searchPreview.value.toLowerCase();
                    const cards = document.querySelectorAll('.preview-card');
                    
                    cards.forEach(card => {
                        const content = card.textContent.toLowerCase();
                        const isVisible = content.includes(searchTerm);
                        card.style.display = isVisible ? '' : 'none';
                        
                        // Highlight logic
                        if (isVisible && searchTerm) {
                           this.highlightInCard(card, searchTerm);
                        } else {
                           this.clearHighlight(card);
                        }
                    });
                },

                highlightInCard(card, term) {
                    this.clearHighlight(card);
                    const regex = new RegExp(`(${this.escapeRegex(term)})`, 'gi');
                    
                    const processNode = (node) => {
                        if (node.nodeType === 3) { // Text node
                            const text = node.textContent;
                            if (text.toLowerCase().includes(term)) {
                                const span = document.createElement('span');
                                span.innerHTML = text.replace(regex, `<span class="search-highlight">$1</span>`);
                                node.parentNode.replaceChild(span, node);
                            }
                        } else if (node.nodeType === 1 && node.nodeName !== 'SPAN' && !node.classList.contains('search-highlight')) {
                            // Element node, recurse
                            Array.from(node.childNodes).forEach(processNode);
                        }
                    };

                    processNode(card);
                },

                clearHighlight(card) {
                    const highlights = card.querySelectorAll('span.search-highlight');
                    highlights.forEach(hl => {
                        const parent = hl.parentNode;
                        parent.replaceChild(document.createTextNode(hl.textContent), hl);
                        parent.normalize();
                    });
                },

                getTextNodes(node) {
                    let all = [];
                    for (node = node.firstChild; node; node = node.nextSibling) {
                        if (node.nodeType === 3) all.push(node);
                        else if (node.nodeName !== 'SCRIPT' && node.nodeName !== 'STYLE') {
                            all = all.concat(this.getTextNodes(node));
                        }
                    }
                    return all;
                },
                
                escapeRegex(string) {
                    return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                }
            },

            // --- EXPORT ---
            export: {
                async exportAs(format) {
                    switch(format) {
                        case 'csv': return this.toCsv();
                        case 'json':
                        default: return this.toJson();
                    }
                },
                async toJson() {
                    const zip = new JSZip();
                    TranslatorApp.state.translatedJsonData.forEach(file => {
                        const originalFile = TranslatorApp.state.originalJsonData.find(f => f.name === file.name);
                        const finalData = JSON.parse(JSON.stringify(originalFile.data));
                        
                        const updateField = (original, translated) => (translated !== undefined ? translated : original);

                        finalData.statement = updateField(originalFile.data.statement, file.data.statement);
                        if (finalData.parts) {
                            finalData.parts.forEach((part, partIndex) => {
                                const translatedPart = file.data.parts[partIndex];
                                if(translatedPart){
                                    part.stem = updateField(part.stem, translatedPart.stem);
                                    part.answer = updateField(part.answer, translatedPart.answer);
                                    if (part.choices) {
                                        part.choices.forEach((choice, choiceIndex) => {
                                            if(translatedPart.choices && translatedPart.choices[choiceIndex]){
                                                choice.html_content = updateField(choice.html_content, translatedPart.choices[choiceIndex].html_content);
                                            }
                                        });
                                    }
                                }
                            });
                        }
                        zip.file(file.name, JSON.stringify(finalData, null, 2));
                    });
                    try {
                        const content = await zip.generateAsync({ type: "blob" });
                        const link = document.createElement("a");
                        link.href = URL.createObjectURL(content);
                        link.download = "translated_questions_json.zip";
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        TranslatorApp.ui.showAlert('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ZIP Ø¨Ù†Ø¬Ø§Ø­!', 'success');
                    } catch (error) {
                        console.error("Failed to generate zip file:", error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ZIP.', 'error');
                    }
                },
                async toCsv() {
                    let csvContent = "data:text/csv;charset=utf-8,\uFEFF"; // Add BOM for Excel
                    csvContent += "FileName,PartIndex,Type,OriginalText,TranslatedText\r\n";

                    TranslatorApp.state.originalJsonData.forEach((originalFile, fileIndex) => {
                        const translatedFile = TranslatorApp.state.translatedJsonData[fileIndex];
                        const fileName = originalFile.name;

                        const addRow = (partIndex, type, originalText, translatedText) => {
                            const escape = (str) => {
                                const div = document.createElement('div');
                                div.innerHTML = str || '';
                                return `"${(div.textContent || div.innerText || '').replace(/"/g, '""')}"`;
                            };
                            csvContent += [fileName, partIndex, type, escape(originalText), escape(translatedText)].join(',') + '\r\n';
                        };

                        addRow(0, 'statement', originalFile.data.statement, translatedFile.data.statement);
                        originalFile.data.parts.forEach((part, partIndex) => {
                            const translatedPart = translatedFile.data.parts[partIndex];
                            addRow(partIndex + 1, 'stem', part.stem, translatedPart.stem);
                            addRow(partIndex + 1, 'answer', part.answer, translatedPart.answer);
                            part.choices.forEach((choice, choiceIndex) => {
                                addRow(partIndex + 1, `choice_${choiceIndex + 1}`, choice.html_content, translatedPart.choices[choiceIndex].html_content);
                            });
                        });
                    });

                    const encodedUri = encodeURI(csvContent);
                    const link = document.createElement("a");
                    link.setAttribute("href", encodedUri);
                    link.setAttribute("download", "translated_data.csv");
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    TranslatorApp.ui.showAlert('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù CSV Ø¨Ù†Ø¬Ø§Ø­!', 'success');
                }
            }
        };

        document.addEventListener('DOMContentLoaded', () => TranslatorApp.init());
    </script>
</body>
</html>
