<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…ØªØ±Ø¬Ù… Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ø­ØªØ±Ù</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Cairo', sans-serif;
        }
        .dragover {
            border-color: #4f46e5;
            background-color: #e0e7ff;
        }
        .preview-card h4 {
            border-bottom: 2px solid #6366f1;
            padding-bottom: 8px;
            margin-bottom: 12px;
        }
        [contenteditable]:focus {
            outline: 2px solid #818cf8;
            background-color: #f0f9ff;
            border-radius: 4px;
        }
        /* Custom styles for radio buttons */
        .api-selector input[type="radio"]:checked + label {
            border-color: #4f46e5;
            background-color: #eef2ff;
            color: #4338ca;
        }
        .editable-content {
            white-space: pre-wrap;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-indigo-600">ğŸŒ Ù…ØªØ±Ø¬Ù… Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ø­ØªØ±Ù</h1>
            <p class="text-gray-600 mt-2 text-lg">ØªØ±Ø¬Ù…Ø© Ù…Ù„ÙØ§Øª JSONØŒ Ù…Ø¹ Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØ§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‚Ø¨Ù„ Ø§Ù„ØªØµØ¯ÙŠØ±</p>
        </header>

        <!-- Step 1: Settings and Upload -->
        <div id="setupSection" class="bg-white p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4 text-indigo-700 border-b-2 border-indigo-200 pb-2">Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª</h3>
            
            <div class="mb-6">
                <label class="block mb-2 font-semibold text-gray-700">Ø§Ø®ØªØ± Ù…ÙØ²ÙˆÙ‘Ø¯ Ø§Ù„Ø®Ø¯Ù…Ø©:</label>
                <div class="api-selector grid grid-cols-2 gap-4">
                    <div>
                        <input type="radio" id="geminiProvider" name="apiProvider" value="gemini" class="hidden" checked>
                        <label for="geminiProvider" class="block text-center p-4 border-2 border-gray-200 rounded-lg cursor-pointer transition">
                            <span class="font-bold">ğŸ¤– Google Gemini</span>
                        </label>
                    </div>
                    <div>
                        <input type="radio" id="chatgptProvider" name="apiProvider" value="chatgpt" class="hidden">
                        <label for="chatgptProvider" class="block text-center p-4 border-2 border-gray-200 rounded-lg cursor-pointer transition">
                             <span class="font-bold">ğŸ’¬ OpenAI ChatGPT</span>
                        </label>
                    </div>
                </div>
            </div>

            <div id="geminiKeyGroup" class="mb-6">
                <label for="geminiKey" class="block mb-2 font-semibold text-gray-700">Ù…ÙØªØ§Ø­ Gemini API:</label>
                <input type="password" id="geminiKey" placeholder="Ø£Ø¯Ø®Ù„ Ù…ÙØªØ§Ø­ Gemini API Ù‡Ù†Ø§" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition">
            </div>
            
            <div id="chatgptKeyGroup" class="mb-6 hidden">
                <label for="chatgptKey" class="block mb-2 font-semibold text-gray-700">Ù…ÙØªØ§Ø­ OpenAI API:</label>
                <input type="password" id="chatgptKey" placeholder="Ø£Ø¯Ø®Ù„ Ù…ÙØªØ§Ø­ OpenAI (ChatGPT) API Ù‡Ù†Ø§" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition">
            </div>

            <div class="flex items-center justify-between mb-6 bg-gray-50 p-3 rounded-lg">
                <button id="manageGlossaryBtn" type="button" class="text-indigo-600 hover:text-indigo-800 font-semibold">ğŸ“– Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚Ø§Ù…ÙˆØ³ Ø§Ù„Ù…Ø®ØµØµ</button>
                <div class="flex items-center">
                    <input id="useGlossaryCheckbox" type="checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                    <label for="useGlossaryCheckbox" class="mr-2 text-sm font-medium text-gray-900">Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù‚Ø§Ù…ÙˆØ³</label>
                </div>
            </div>

            <div class="mb-4">
                <label class="block mb-2 font-semibold text-gray-700">Ù…Ù„ÙØ§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (JSON):</label>
                <div id="fileUpload" class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:bg-indigo-50 transition">
                    <div class="text-indigo-500 text-4xl mb-2">ğŸ“¤</div>
                    <p class="font-semibold text-gray-700">Ø§Ø³Ø­Ø¨ ÙˆØ£ÙÙ„Øª Ø§Ù„Ù…Ù„ÙØ§Øª Ù‡Ù†Ø§ Ø£Ùˆ Ø§Ù†Ù‚Ø± Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±</p>
                    <p class="text-sm text-gray-500 mt-1">ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ù…Ù„ÙØ§Øª Ø¨ØµÙŠØºØ© JSON</p>
                    <input type="file" id="fileInput" multiple accept=".json" class="hidden">
                </div>
            </div>

            <div id="fileList" class="space-y-2"></div>
            
            <button id="translateBtn" class="w-full bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-indigo-700 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed disabled:transform-none">
                ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ù„ÙØ§Øª
            </button>
        </div>

        <!-- Step 2: Progress -->
        <div id="progressContainer" class="hidden bg-white p-6 rounded-2xl shadow-lg mb-6 text-center">
             <div class="w-16 h-16 border-4 border-dashed rounded-full animate-spin border-indigo-600 mx-auto"></div>
             <p id="progressText" class="mt-4 text-lg font-semibold text-gray-700">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©...</p>
        </div>


        <!-- Step 3: Preview and Edit -->
        <div id="previewSection" class="hidden">
             <div class="bg-white p-6 rounded-2xl shadow-lg mb-6">
                <h3 class="text-2xl font-bold mb-4 text-green-700 border-b-2 border-green-200 pb-2">Ø§Ù„Ø®Ø·ÙˆØ© 2: Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ±Ø¬Ù…Ø©</h3>
                <p class="text-gray-600 mb-6">ØªÙ…Øª ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù†ØµÙˆØµ. ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡Ø§ ÙˆØªØ¹Ø¯ÙŠÙ„ Ø£ÙŠ Ù†Øµ Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„ÙŠÙ‡. Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª ØªÙØ­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹.</p>
                <div id="previewContainer" class="space-y-6">
                    <!-- Preview cards will be inserted here -->
                </div>
             </div>
             <button id="generateBtn" class="w-full bg-green-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-green-700 transition-transform transform hover:scale-105">
                ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ØªØ±Ø¬Ù…Ø© (JSON)
            </button>
        </div>

    </div>

    <!-- Glossary Modal -->
    <div id="glossaryModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-2xl shadow-xl p-6 w-full max-w-2xl transform transition-all">
            <div class="flex justify-between items-center">
                <h3 class="text-2xl font-bold text-indigo-700">Ø§Ù„Ù‚Ø§Ù…ÙˆØ³ Ø§Ù„Ù…Ø®ØµØµ</h3>
                <button id="closeGlossaryModalBtn" class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
            </div>
            <p class="text-sm text-gray-500 mt-1 mb-4">Ø£Ø¶Ù Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª ÙˆØªØ±Ø¬Ù…ØªÙ‡Ø§ Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø© Ù„Ø¶Ù…Ø§Ù† Ø§Ù„Ø§ØªØ³Ø§Ù‚ ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª.</p>
            <div class="grid md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="glossaryTerm" class="block text-sm font-medium text-gray-700">Ø§Ù„Ù…ØµØ·Ù„Ø­ (Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø£ØµÙ„ÙŠØ©)</label>
                    <input type="text" id="glossaryTerm" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <div>
                    <label for="glossaryTranslation" class="block text-sm font-medium text-gray-700">Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø©</label>
                    <input type="text" id="glossaryTranslation" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
            </div>
            <button id="addGlossaryTermBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 w-full">Ø¥Ø¶Ø§ÙØ© Ù…ØµØ·Ù„Ø­</button>
            <hr class="my-4">
            <h4 class="text-lg font-semibold mb-2">Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©</h4>
            <div id="glossaryListContainer" class="max-h-60 overflow-y-auto p-2 bg-gray-50 rounded-md">
                <!-- Glossary items will be rendered here -->
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const fileUpload = document.getElementById('fileUpload');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const translateBtn = document.getElementById('translateBtn');
        const geminiKeyInput = document.getElementById('geminiKey');
        const chatgptKeyInput = document.getElementById('chatgptKey');
        const geminiKeyGroup = document.getElementById('geminiKeyGroup');
        const chatgptKeyGroup = document.getElementById('chatgptKeyGroup');
        const apiProviderRadios = document.querySelectorAll('input[name="apiProvider"]');
        
        const setupSection = document.getElementById('setupSection');
        const progressContainer = document.getElementById('progressContainer');
        const progressText = document.getElementById('progressText');
        const previewSection = document.getElementById('previewSection');
        const previewContainer = document.getElementById('previewContainer');
        const generateBtn = document.getElementById('generateBtn');

        // Glossary Elements
        const manageGlossaryBtn = document.getElementById('manageGlossaryBtn');
        const glossaryModal = document.getElementById('glossaryModal');
        const closeGlossaryModalBtn = document.getElementById('closeGlossaryModalBtn');
        const addGlossaryTermBtn = document.getElementById('addGlossaryTermBtn');
        const glossaryTermInput = document.getElementById('glossaryTerm');
        const glossaryTranslationInput = document.getElementById('glossaryTranslation');
        const glossaryListContainer = document.getElementById('glossaryListContainer');
        const useGlossaryCheckbox = document.getElementById('useGlossaryCheckbox');

        // --- State Variables ---
        let selectedFiles = [];
        let originalJsonData = [];
        let translatedJsonData = [];
        let glossary = [];

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            geminiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
            chatgptKeyInput.value = localStorage.getItem('chatgptApiKey') || '';
            loadGlossary();
        });

        apiProviderRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.value === 'gemini') {
                    geminiKeyGroup.classList.remove('hidden');
                    chatgptKeyGroup.classList.add('hidden');
                } else {
                    geminiKeyGroup.classList.add('hidden');
                    chatgptKeyGroup.classList.remove('hidden');
                }
            });
        });

        fileUpload.addEventListener('click', () => fileInput.click());
        fileUpload.addEventListener('dragover', (e) => { e.preventDefault(); fileUpload.classList.add('dragover'); });
        fileUpload.addEventListener('dragleave', () => fileUpload.classList.remove('dragover'));
        fileUpload.addEventListener('drop', handleFileDrop);
        fileInput.addEventListener('change', handleFileSelect);

        translateBtn.addEventListener('click', startTranslationProcess);
        generateBtn.addEventListener('click', generateFinalJsonFiles);

        // Glossary Listeners
        manageGlossaryBtn.addEventListener('click', () => glossaryModal.classList.remove('hidden'));
        closeGlossaryModalBtn.addEventListener('click', () => glossaryModal.classList.add('hidden'));
        addGlossaryTermBtn.addEventListener('click', addGlossaryTerm);

        // --- Functions ---

        function handleFileDrop(e) {
            e.preventDefault();
            fileUpload.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files).filter(file => file.name.endsWith('.json'));
            addFiles(files);
        }

        function handleFileSelect(e) {
            const files = Array.from(e.target.files).filter(file => file.name.endsWith('.json'));
            addFiles(files);
        }

        function addFiles(newFiles) {
            newFiles.forEach(file => {
                if (!selectedFiles.some(f => f.name === file.name)) {
                    selectedFiles.push(file);
                }
            });
            renderFileList();
        }

        function renderFileList() {
            fileList.innerHTML = '';
            if (selectedFiles.length === 0) return;

            const listContainer = document.createElement('ul');
            listContainer.className = 'my-4 space-y-2';
            selectedFiles.forEach((file, index) => {
                const listItem = document.createElement('li');
                listItem.className = 'flex justify-between items-center bg-gray-100 p-2 rounded-lg';
                listItem.innerHTML = `
                    <span class="font-medium text-gray-800">${file.name}</span>
                    <button onclick="removeFile(${index})" class="text-red-500 hover:text-red-700 font-bold text-xl">&times;</button>
                `;
                listContainer.appendChild(listItem);
            });
            fileList.appendChild(listContainer);
        }

        function removeFile(index) {
            selectedFiles.splice(index, 1);
            renderFileList();
        }

        function showAlert(message, type = 'error') {
            const color = type === 'error' ? 'red' : 'green';
            const alertBox = document.createElement('div');
            alertBox.className = `fixed top-5 right-5 bg-${color}-500 text-white p-4 rounded-lg shadow-xl animate-pulse z-50`;
            alertBox.textContent = message;
            document.body.appendChild(alertBox);
            setTimeout(() => alertBox.remove(), 4000);
        }

        // --- Glossary Functions ---
        function loadGlossary() {
            const savedGlossary = localStorage.getItem('customGlossary');
            if (savedGlossary) {
                glossary = JSON.parse(savedGlossary);
            }
            renderGlossaryList();
        }

        function saveGlossary() {
            localStorage.setItem('customGlossary', JSON.stringify(glossary));
        }

        function addGlossaryTerm() {
            const term = glossaryTermInput.value.trim();
            const translation = glossaryTranslationInput.value.trim();

            if (term && translation) {
                if (glossary.some(entry => entry.term.toLowerCase() === term.toLowerCase())) {
                    showAlert('Ù‡Ø°Ø§ Ø§Ù„Ù…ØµØ·Ù„Ø­ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ø§Ù„Ù‚Ø§Ù…ÙˆØ³.');
                    return;
                }
                glossary.push({ term, translation });
                glossaryTermInput.value = '';
                glossaryTranslationInput.value = '';
                saveGlossary();
                renderGlossaryList();
            } else {
                showAlert('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…ØµØ·Ù„Ø­ ÙˆØªØ±Ø¬Ù…ØªÙ‡.');
            }
        }

        function deleteGlossaryTerm(index) {
            glossary.splice(index, 1);
            saveGlossary();
            renderGlossaryList();
        }

        function renderGlossaryList() {
            glossaryListContainer.innerHTML = '';
            if (glossary.length === 0) {
                glossaryListContainer.innerHTML = '<p class="text-center text-gray-500">Ø§Ù„Ù‚Ø§Ù…ÙˆØ³ ÙØ§Ø±Øº Ø­Ø§Ù„ÙŠÙ‹Ø§.</p>';
                return;
            }
            const list = document.createElement('ul');
            list.className = 'space-y-2';
            glossary.forEach((entry, index) => {
                const listItem = document.createElement('li');
                listItem.className = 'flex justify-between items-center p-2 bg-white rounded-md border';
                listItem.innerHTML = `
                    <div>
                        <span class="font-semibold">${entry.term}</span>
                        <span class="text-gray-500 mx-2">â†’</span>
                        <span>${entry.translation}</span>
                    </div>
                    <button onclick="deleteGlossaryTerm(${index})" class="text-red-500 hover:text-red-700 font-bold">&times;</button>
                `;
                list.appendChild(listItem);
            });
            glossaryListContainer.appendChild(list);
        }
        
        function applyGlossary(text, currentGlossary) {
            if (!text || !currentGlossary || currentGlossary.length === 0) {
                return { modifiedText: text, placeholders: {} };
            }

            let modifiedText = text;
            const placeholders = {};
            let placeholderIndex = 0;

            // Sort glossary by length descending to match longer phrases first
            const sortedGlossary = [...currentGlossary].sort((a, b) => b.term.length - a.term.length);

            sortedGlossary.forEach(entry => {
                // Use a regex to find the term as a whole word, case-insensitive
                const regex = new RegExp(`\\b${entry.term}\\b`, 'gi');
                modifiedText = modifiedText.replace(regex, (match) => {
                    const placeholder = `__GLOSSARY_${placeholderIndex}__`;
                    placeholders[placeholder] = entry.translation;
                    placeholderIndex++;
                    return placeholder;
                });
            });

            return { modifiedText, placeholders };
        }

        function revertPlaceholders(text, placeholders) {
            if (Object.keys(placeholders).length === 0) return text;
            let resultText = text;
            for (const placeholder in placeholders) {
                resultText = resultText.replaceAll(placeholder, placeholders[placeholder]);
            }
            return resultText;
        }


        async function startTranslationProcess() {
            const apiProvider = document.querySelector('input[name="apiProvider"]:checked').value;
            const apiKey = (apiProvider === 'gemini' ? geminiKeyInput.value : chatgptKeyInput.value).trim();

            if (!apiKey) {
                showAlert(`Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù…ÙØªØ§Ø­ API Ù„Ù€ ${apiProvider === 'gemini' ? 'Gemini' : 'ChatGPT'}.`);
                return;
            }
            if (selectedFiles.length === 0) {
                showAlert('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù JSON ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„.');
                return;
            }

            if (apiProvider === 'gemini') {
                localStorage.setItem('geminiApiKey', apiKey);
            } else {
                localStorage.setItem('chatgptApiKey', apiKey);
            }
            
            // UI transition
            setupSection.classList.add('hidden');
            progressContainer.classList.remove('hidden');
            previewSection.classList.add('hidden');
            translateBtn.disabled = true;

            try {
                // 1. Read files
                progressText.textContent = 'Ø¬Ø§Ø±ÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„ÙØ§Øª...';
                originalJsonData = [];
                for (const file of selectedFiles) {
                    const content = await file.text();
                    originalJsonData.push({ name: file.name, data: JSON.parse(content) });
                }

                // 2. Translate content
                translatedJsonData = JSON.parse(JSON.stringify(originalJsonData)); // Deep copy
                let totalTasks = originalJsonData.reduce((acc, file) => acc + countTranslationTasks(file.data), 0);
                let completedTasks = 0;

                const useGlossary = useGlossaryCheckbox.checked;

                for (const file of translatedJsonData) {
                    const tasks = [];
                    if (file.data.statement) {
                        tasks.push(
                            translateText(file.data.statement, apiKey, apiProvider, useGlossary ? glossary : null).then(t => {
                                file.data.statement = t;
                                completedTasks++;
                                progressText.textContent = `Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©... (${Math.round((completedTasks/totalTasks)*100)}%)`;
                            })
                        );
                    }
                    if (file.data.parts && Array.isArray(file.data.parts)) {
                        for (const part of file.data.parts) {
                            if (part.stem) {
                                tasks.push(
                                    translateText(part.stem, apiKey, apiProvider, useGlossary ? glossary : null).then(t => {
                                        part.stem = t;
                                        completedTasks++;
                                        progressText.textContent = `Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©... (${Math.round((completedTasks/totalTasks)*100)}%)`;
                                    })
                                );
                            }
                            if (part.answer) {
                                tasks.push(
                                    translateText(part.answer, apiKey, apiProvider, useGlossary ? glossary : null).then(t => {
                                        part.answer = t;
                                        completedTasks++;
                                        progressText.textContent = `Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©... (${Math.round((completedTasks/totalTasks)*100)}%)`;
                                    })
                                );
                            }
                            if(part.choices && Array.isArray(part.choices)){
                                for(let i = 0; i < part.choices.length; i++){
                                    if(part.choices[i].html_content){
                                        tasks.push(
                                            translateText(part.choices[i].html_content, apiKey, apiProvider, useGlossary ? glossary : null).then(t => {
                                                part.choices[i].html_content = t;
                                                completedTasks++;
                                                progressText.textContent = `Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©... (${Math.round((completedTasks/totalTasks)*100)}%)`;
                                            })
                                        );
                                    }
                                }
                            }
                        }
                    }
                    await Promise.all(tasks);
                }

                // 3. Render preview
                progressText.textContent = 'Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„ØªØ±Ø¬Ù…Ø©! Ø¬Ø§Ø±ÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬...';
                renderPreview();
                progressContainer.classList.add('hidden');
                previewSection.classList.remove('hidden');

            } catch (error) {
                console.error('Translation process failed:', error);
                showAlert(`Ø­Ø¯Ø« Ø®Ø·Ø£: ${error.message}`);
                // Revert UI
                setupSection.classList.remove('hidden');
                progressContainer.classList.add('hidden');
            } finally {
                translateBtn.disabled = false;
            }
        }
        
        function countTranslationTasks(data) {
            let count = 0;
            if (data.statement) count++;
            if (data.parts && Array.isArray(data.parts)) {
                data.parts.forEach(part => {
                    if (part.stem) count++;
                    if (part.answer) count++;
                    if (part.choices && Array.isArray(part.choices)) {
                        part.choices.forEach(choice => {
                            if (choice.html_content) count++;
                        });
                    }
                });
            }
            return count;
        }

        async function translateText(text, apiKey, provider, currentGlossary) {
            if (!text || !text.trim()) return text;
            
            const { modifiedText, placeholders } = applyGlossary(text, currentGlossary);

            let translatedText;
            if (provider === 'gemini') {
                translatedText = await translateWithGemini(modifiedText, apiKey);
            } else {
                translatedText = await translateWithChatGPT(modifiedText, apiKey);
            }
            
            return revertPlaceholders(translatedText, placeholders);
        }

        async function translateWithGemini(text, apiKey) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: `Translate the following text to Arabic. Keep any HTML tags, LaTeX equations, or placeholders like __GLOSSARY_0__ unchanged:\n\n${text}` }] }]
                    })
                });
                if (!response.ok) {
                    const errorBody = await response.json();
                    throw new Error(`Gemini API Error: ${errorBody.error?.message || response.statusText}`);
                }
                const data = await response.json();
                const translated = data.candidates?.[0]?.content?.parts?.[0]?.text;
                return translated ? translated.trim() : text;
            } catch (error) {
                console.error("Gemini API call failed:", error);
                throw error;
            }
        }

        async function translateWithChatGPT(text, apiKey) {
            const apiUrl = 'https://api.openai.com/v1/chat/completions';

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o', // Using a modern model
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a professional translator. Translate the following text to Modern Standard Arabic. Keep any HTML tags, LaTeX equations, or placeholders like __GLOSSARY_0__ unchanged.'
                            },
                            {
                                role: 'user',
                                content: text
                            }
                        ],
                        temperature: 0.3
                    })
                });
                 if (!response.ok) {
                    const errorBody = await response.json();
                    throw new Error(`ChatGPT API Error: ${errorBody.error?.message || response.statusText}`);
                }
                const data = await response.json();
                const translated = data.choices?.[0]?.message?.content;
                return translated ? translated.trim() : text;
            } catch (error) {
                console.error("ChatGPT API call failed:", error);
                throw error;
            }
        }

        function renderPreview() {
            previewContainer.innerHTML = '';
            translatedJsonData.forEach((file, fileIndex) => {
                const card = document.createElement('div');
                card.className = 'preview-card bg-gray-50 p-4 rounded-lg border';
                card.dir = 'rtl'; // Set direction for the entire card
                
                let content = `<h3 class="text-xl font-bold text-gray-800 mb-4 text-right">ğŸ“„ ${file.name}</h3>`;
                
                if (file.data.statement) {
                    content += `
                        <div class="mb-4">
                            <h4 class="font-semibold text-indigo-700 text-right">Ø§Ù„Ø¨ÙŠØ§Ù† (Statement)</h4>
                            <div contenteditable="true" oninput="updateData(${fileIndex}, 'statement', null, this.innerHTML)" class="editable-content mt-1 p-2 bg-white rounded border border-gray-200 text-right">${file.data.statement}</div>
                        </div>`;
                }

                if (file.data.parts && Array.isArray(file.data.parts)) {
                    file.data.parts.forEach((part, partIndex) => {
                        content += `<div class="border-t pt-4 mt-4">`;
                        content += `<h5 class="font-semibold text-md text-gray-700 mb-2 text-right">Ø§Ù„Ø¬Ø²Ø¡ ${partIndex + 1}</h5>`;
                        if (part.stem) {
                             content += `
                                <div class="mb-3">
                                    <p class="font-semibold text-right">Ø§Ù„Ø³Ø¤Ø§Ù„ (Stem):</p>
                                    <div contenteditable="true" oninput="updateData(${fileIndex}, 'parts', ${partIndex}, this.innerHTML, 'stem')" class="editable-content mt-1 p-2 bg-white rounded border border-gray-200 text-right">${part.stem}</div>
                                </div>`;
                        }
                        if (part.answer) {
                             content += `
                                <div class="mb-3">
                                    <p class="font-semibold text-right">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer):</p>
                                    <div contenteditable="true" oninput="updateData(${fileIndex}, 'parts', ${partIndex}, this.innerHTML, 'answer')" class="editable-content mt-1 p-2 bg-white rounded border border-gray-200 text-right">${part.answer}</div>
                                </div>`;
                        }
                        if (part.choices && Array.isArray(part.choices)) {
                            content += `<div class="mb-3"><p class="font-semibold text-right">Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª (Choices):</p><ul class="list-disc list-inside mt-2 space-y-2 mr-4">`;
                            part.choices.forEach((choice, choiceIndex) => {
                                content += `<li class="text-right"><div contenteditable="true" oninput="updateData(${fileIndex}, 'parts', ${partIndex}, this.innerHTML, 'choice', ${choiceIndex})" class="editable-content inline-block w-11/12 p-1 bg-white rounded border border-gray-200">${choice.html_content}</div></li>`;
                            });
                            content += `</ul></div>`;
                        }
                        content += `</div>`;
                    });
                }
                card.innerHTML = content;
                previewContainer.appendChild(card);
            });
        }

        function updateData(fileIndex, key, partIndex, value, subKey = null, choiceIndex = null) {
            // When using contenteditable with innerHTML, browsers might add their own styling.
            // This is a simple update. For complex scenarios, a library or more robust handling would be needed.
            if (key === 'statement') {
                translatedJsonData[fileIndex].data.statement = value;
            } else if (key === 'parts') {
                const part = translatedJsonData[fileIndex].data.parts[partIndex];
                if (subKey === 'stem') part.stem = value;
                if (subKey === 'answer') part.answer = value;
                if (subKey === 'choice') part.choices[choiceIndex].html_content = value;
            }
        }

        async function generateFinalJsonFiles() {
            const zip = new JSZip();
            
            translatedJsonData.forEach(file => {
                // Reconstruct the original structure before stringifying
                const finalData = JSON.parse(JSON.stringify(originalJsonData.find(f => f.name === file.name).data));

                // Update the finalData object with the translated (and possibly edited) text
                if (finalData.statement && file.data.statement) {
                    finalData.statement = file.data.statement;
                }
                if (finalData.parts && Array.isArray(finalData.parts)) {
                    finalData.parts.forEach((part, partIndex) => {
                        const translatedPart = file.data.parts[partIndex];
                        if (part.stem && translatedPart.stem) {
                            part.stem = translatedPart.stem;
                        }
                        if (part.answer && translatedPart.answer) {
                            part.answer = translatedPart.answer;
                        }
                        if (part.choices && Array.isArray(part.choices)) {
                            part.choices.forEach((choice, choiceIndex) => {
                                if (choice.html_content && translatedPart.choices[choiceIndex]) {
                                    choice.html_content = translatedPart.choices[choiceIndex].html_content;
                                }
                            });
                        }
                    });
                }
                
                zip.file(file.name, JSON.stringify(finalData, null, 2));
            });

            try {
                const content = await zip.generateAsync({ type: "blob" });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(content);
                link.download = "translated_questions.zip";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showAlert('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ZIP Ø¨Ù†Ø¬Ø§Ø­!', 'success');
            } catch (error) {
                console.error("Failed to generate zip file:", error);
                showAlert('ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ZIP.');
            }
        }
    </script>
</body>
</html>
