<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ูุชุฑุฌู ุงูุฃุณุฆูุฉ ุงููุญุชุฑู</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Cairo', sans-serif;
        }
        .dragover {
            border-color: #4f46e5;
            background-color: #e0e7ff;
        }
        .preview-card h4 {
            border-bottom: 2px solid #6366f1;
            padding-bottom: 8px;
            margin-bottom: 12px;
        }
        [contenteditable]:focus {
            outline: 2px solid #818cf8;
            background-color: #f0f9ff;
            border-radius: 4px;
        }
        .api-selector input[type="radio"]:checked + label {
            border-color: #4f46e5;
            background-color: #eef2ff;
            color: #4338ca;
        }
        .editable-content {
            white-space: pre-wrap;
        }
        /* Styles for the new alert system */
        .alert {
            transition: all 0.5s ease-in-out;
            opacity: 1;
            transform: translateX(0);
        }
        .alert.fade-out {
            opacity: 0;
            transform: translateX(100%);
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Container for alerts -->
    <div id="alertContainer" class="fixed top-0 right-0 p-4 w-full max-w-md z-50 space-y-3"></div>

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <div class="flex justify-between items-center mb-4">
             <h1 class="text-4xl md:text-5xl font-bold text-indigo-600">๐ ูุชุฑุฌู ุงูุฃุณุฆูุฉ ุงููุญุชุฑู</h1>
             <button id="newSessionBtn" class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition">
                ุจุฏุก ุฌูุณุฉ ุฌุฏูุฏุฉ
            </button>
        </div>
        <p class="text-gray-600 mt-2 mb-8 text-center text-lg">ุชุฑุฌูุฉ ูููุงุช JSONุ ูุน ุฅููุงููุฉ ุงููุนุงููุฉ ูุงูุชุนุฏูู ูุจู ุงูุชุตุฏูุฑ</p>
        

        <!-- Step 1: Settings and Upload -->
        <div id="setupSection" class="bg-white p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4 text-indigo-700 border-b-2 border-indigo-200 pb-2">ุงูุฎุทูุฉ 1: ุงูุฅุนุฏุงุฏุงุช ูุฑูุน ุงููููุงุช</h3>
            
            <div class="mb-6">
                <label class="block mb-2 font-semibold text-gray-700">ุงุฎุชุฑ ููุฒููุฏ ุงูุฎุฏูุฉ:</label>
                <div class="api-selector grid grid-cols-2 gap-4">
                    <div>
                        <input type="radio" id="geminiProvider" name="apiProvider" value="gemini" class="hidden" checked>
                        <label for="geminiProvider" class="block text-center p-4 border-2 border-gray-200 rounded-lg cursor-pointer transition">
                            <span class="font-bold">๐ค Google Gemini</span>
                        </label>
                    </div>
                    <div>
                        <input type="radio" id="chatgptProvider" name="apiProvider" value="chatgpt" class="hidden">
                        <label for="chatgptProvider" class="block text-center p-4 border-2 border-gray-200 rounded-lg cursor-pointer transition">
                             <span class="font-bold">๐ฌ OpenAI ChatGPT</span>
                        </label>
                    </div>
                </div>
            </div>

            <div id="geminiKeyGroup" class="mb-6">
                <label for="geminiKey" class="block mb-2 font-semibold text-gray-700">ููุชุงุญ Gemini API:</label>
                <input type="password" id="geminiKey" placeholder="ุฃุฏุฎู ููุชุงุญ Gemini API ููุง" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition">
            </div>
            
            <div id="chatgptKeyGroup" class="mb-6 hidden">
                <label for="chatgptKey" class="block mb-2 font-semibold text-gray-700">ููุชุงุญ OpenAI API:</label>
                <input type="password" id="chatgptKey" placeholder="ุฃุฏุฎู ููุชุงุญ OpenAI (ChatGPT) API ููุง" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition">
            </div>

            <div class="flex items-center justify-between mb-6 bg-gray-50 p-3 rounded-lg">
                <button id="manageGlossaryBtn" type="button" class="text-indigo-600 hover:text-indigo-800 font-semibold">๐ ุฅุฏุงุฑุฉ ุงููุงููุณ ุงููุฎุตุต</button>
                <div class="flex items-center">
                    <input id="useGlossaryCheckbox" type="checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                    <label for="useGlossaryCheckbox" class="mr-2 text-sm font-medium text-gray-900">ุงุณุชุฎุฏุงู ุงููุงููุณ</label>
                </div>
            </div>

            <div class="mb-4">
                <label class="block mb-2 font-semibold text-gray-700">ูููุงุช ุงูุฃุณุฆูุฉ (JSON):</label>
                <div id="fileUpload" class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:bg-indigo-50 transition">
                    <div class="text-indigo-500 text-4xl mb-2">๐ค</div>
                    <p class="font-semibold text-gray-700">ุงุณุญุจ ูุฃููุช ุงููููุงุช ููุง ุฃู ุงููุฑ ููุงุฎุชูุงุฑ</p>
                    <p class="text-sm text-gray-500 mt-1">ูุฌุจ ุฃู ุชููู ุงููููุงุช ุจุตูุบุฉ JSON</p>
                    <input type="file" id="fileInput" multiple accept=".json" class="hidden">
                </div>
            </div>

            <div id="fileList" class="space-y-2"></div>
            
            <button id="translateBtn" class="w-full bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-indigo-700 transition-transform transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed disabled:transform-none">
                ุชุฑุฌูุฉ ุงููููุงุช
            </button>
        </div>

        <!-- Step 2: Progress -->
        <div id="progressContainer" class="hidden bg-white p-6 rounded-2xl shadow-lg mb-6 text-center">
             <div class="w-16 h-16 border-4 border-dashed rounded-full animate-spin border-indigo-600 mx-auto"></div>
             <p id="progressText" class="mt-4 text-lg font-semibold text-gray-700">ุฌุงุฑู ุงูุชุฑุฌูุฉ...</p>
        </div>


        <!-- Step 3: Preview and Edit -->
        <div id="previewSection" class="hidden">
             <div class="bg-white p-6 rounded-2xl shadow-lg mb-6">
                 <h3 class="text-2xl font-bold mb-4 text-green-700 border-b-2 border-green-200 pb-2">ุงูุฎุทูุฉ 2: ูุนุงููุฉ ูุชุนุฏูู ุงูุชุฑุฌูุฉ</h3>
                 <p class="text-gray-600 mb-6">ุชูุช ุชุฑุฌูุฉ ุงููุตูุต. ููููู ุงูุขู ูุฑุงุฌุนุชูุง ูุชุนุฏูู ุฃู ูุต ูุจุงุดุฑุฉ ุจุงูุถุบุท ุนููู. ุงูุชุนุฏููุงุช ุชูุญูุธ ุชููุงุฆูุงู.</p>
                 <div id="previewContainer" class="space-y-6">
                     <!-- Preview cards will be inserted here -->
                 </div>
             </div>
             <button id="generateBtn" class="w-full bg-green-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-green-700 transition-transform transform hover:scale-105">
                 ุชุตุฏูุฑ ุงููููุงุช ุงููุชุฑุฌูุฉ (JSON)
             </button>
        </div>

    </div>

    <!-- Glossary Modal -->
    <div id="glossaryModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-2xl shadow-xl p-6 w-full max-w-2xl transform transition-all">
            <div class="flex justify-between items-center">
                <h3 class="text-2xl font-bold text-indigo-700">ุงููุงููุณ ุงููุฎุตุต</h3>
                <button id="closeGlossaryModalBtn" class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
            </div>
            <p class="text-sm text-gray-500 mt-1 mb-4">ุฃุถู ุงููุตุทูุญุงุช ูุชุฑุฌูุชูุง ุงููุนุชูุฏุฉ ูุถูุงู ุงูุงุชุณุงู ูู ุฌููุน ุงููููุงุช.</p>
            <div class="grid md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="glossaryTerm" class="block text-sm font-medium text-gray-700">ุงููุตุทูุญ (ุจุงููุบุฉ ุงูุฃุตููุฉ)</label>
                    <input type="text" id="glossaryTerm" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <div>
                    <label for="glossaryTranslation" class="block text-sm font-medium text-gray-700">ุงูุชุฑุฌูุฉ ุงููุนุชูุฏุฉ</label>
                    <input type="text" id="glossaryTranslation" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
            </div>
            <button id="addGlossaryTermBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 w-full">ุฅุถุงูุฉ ูุตุทูุญ</button>
            <hr class="my-4">
            <h4 class="text-lg font-semibold mb-2">ุงููุตุทูุญุงุช ุงููุญููุธุฉ</h4>
            <div id="glossaryListContainer" class="max-h-60 overflow-y-auto p-2 bg-gray-50 rounded-md">
                <!-- Glossary items will be rendered here -->
            </div>
        </div>
    </div>

    <script>
        const TranslatorApp = {
            // --- STATE ---
            state: {
                selectedFilesInfo: [],
                originalJsonData: [],
                translatedJsonData: [],
                glossary: [],
                activeScreen: 'setup',
                translationCache: new Map(),
            },

            // --- DOM ELEMENTS ---
            dom: {},

            // --- INITIALIZATION ---
            init() {
                this.cacheDomElements();
                this.bindEvents();
                this.session.load();
            },

            cacheDomElements() {
                const elementMap = {
                    alertContainer: 'alertContainer', newSessionBtn: 'newSessionBtn',
                    fileUpload: 'fileUpload', fileInput: 'fileInput', fileList: 'fileList',
                    translateBtn: 'translateBtn', geminiKeyInput: 'geminiKey', chatgptKeyInput: 'chatgptKey',
                    geminiKeyGroup: 'geminiKeyGroup', chatgptKeyGroup: 'chatgptKeyGroup',
                    setupSection: 'setupSection', progressContainer: 'progressContainer', progressText: 'progressText',
                    previewSection: 'previewSection', previewContainer: 'previewContainer', generateBtn: 'generateBtn',
                    manageGlossaryBtn: 'manageGlossaryBtn', glossaryModal: 'glossaryModal',
                    closeGlossaryModalBtn: 'closeGlossaryModalBtn', addGlossaryTermBtn: 'addGlossaryTermBtn',
                    glossaryTermInput: 'glossaryTerm', glossaryTranslationInput: 'glossaryTranslation',
                    glossaryListContainer: 'glossaryListContainer', useGlossaryCheckbox: 'useGlossaryCheckbox'
                };
                for (const key in elementMap) { this.dom[key] = document.getElementById(elementMap[key]); }
                this.dom.apiProviderRadios = document.querySelectorAll('input[name="apiProvider"]');
            },
            
            // --- EVENTS ---
            bindEvents() {
                this.dom.newSessionBtn.addEventListener('click', this.session.clear.bind(this));
                this.dom.apiProviderRadios.forEach(radio => radio.addEventListener('change', this.events.onApiProviderChange.bind(this)));
                this.dom.fileUpload.addEventListener('click', () => this.dom.fileInput.click());
                this.dom.fileUpload.addEventListener('dragover', this.events.onDragOver);
                this.dom.fileUpload.addEventListener('dragleave', this.events.onDragLeave);
                this.dom.fileUpload.addEventListener('drop', this.events.onFileDrop.bind(this));
                this.dom.fileInput.addEventListener('change', this.events.onFileSelect.bind(this));
                this.dom.translateBtn.addEventListener('click', this.startTranslationProcess.bind(this));
                this.dom.generateBtn.addEventListener('click', this.generateFinalJsonFiles.bind(this));
                this.dom.manageGlossaryBtn.addEventListener('click', () => this.ui.showGlossaryModal(true));
                this.dom.closeGlossaryModalBtn.addEventListener('click', () => this.ui.showGlossaryModal(false));
                this.dom.addGlossaryTermBtn.addEventListener('click', this.glossary.add.bind(this));
                this.dom.geminiKeyInput.addEventListener('change', this.session.save.bind(this));
                this.dom.chatgptKeyInput.addEventListener('change', this.session.save.bind(this));
            },
            
            events: {
                onApiProviderChange(e) {
                    const isGemini = e.target.value === 'gemini';
                    this.dom.geminiKeyGroup.classList.toggle('hidden', !isGemini);
                    this.dom.chatgptKeyGroup.classList.toggle('hidden', isGemini);
                    this.session.save();
                },
                onDragOver(e) { e.preventDefault(); e.currentTarget.classList.add('dragover'); },
                onDragLeave(e) { e.currentTarget.classList.remove('dragover'); },
                onFileDrop(e) { e.preventDefault(); this.dom.fileUpload.classList.remove('dragover'); this.fileHandler.addFiles(e.dataTransfer.files); },
                onFileSelect(e) { this.fileHandler.addFiles(e.target.files); }
            },

            // --- SESSION MANAGEMENT ---
            session: {
                save() {
                    const sessionData = {
                        apiKeys: {
                            gemini: btoa(TranslatorApp.dom.geminiKeyInput.value), // Obfuscate key
                            chatgpt: btoa(TranslatorApp.dom.chatgptKeyInput.value), // Obfuscate key
                        },
                        selectedProvider: document.querySelector('input[name="apiProvider"]:checked').value,
                        selectedFilesInfo: TranslatorApp.state.selectedFilesInfo,
                        originalJsonData: TranslatorApp.state.originalJsonData,
                        translatedJsonData: TranslatorApp.state.translatedJsonData,
                        glossary: TranslatorApp.state.glossary,
                        activeScreen: TranslatorApp.state.activeScreen,
                    };
                    localStorage.setItem('translatorSession', JSON.stringify(sessionData));
                },
                load() {
                    const savedSession = localStorage.getItem('translatorSession');
                    if (!savedSession) return;
                    const sessionData = JSON.parse(savedSession);
                    try {
                        TranslatorApp.dom.geminiKeyInput.value = sessionData.apiKeys?.gemini ? atob(sessionData.apiKeys.gemini) : '';
                        TranslatorApp.dom.chatgptKeyInput.value = sessionData.apiKeys?.chatgpt ? atob(sessionData.apiKeys.chatgpt) : '';
                    } catch (e) {
                        console.error("Failed to decode API keys, clearing them.", e);
                        TranslatorApp.dom.geminiKeyInput.value = '';
                        TranslatorApp.dom.chatgptKeyInput.value = '';
                    }
                    TranslatorApp.state.selectedFilesInfo = sessionData.selectedFilesInfo || [];
                    TranslatorApp.state.originalJsonData = sessionData.originalJsonData || [];
                    TranslatorApp.state.translatedJsonData = sessionData.translatedJsonData || [];
                    TranslatorApp.state.glossary = sessionData.glossary || [];
                    TranslatorApp.state.activeScreen = sessionData.activeScreen || 'setup';
                    if (sessionData.selectedProvider) {
                        document.querySelector(`input[name="apiProvider"][value="${sessionData.selectedProvider}"]`).checked = true;
                        TranslatorApp.events.onApiProviderChange({ target: { value: sessionData.selectedProvider } });
                    }
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.glossary.render();
                    if (TranslatorApp.state.activeScreen === 'preview' && TranslatorApp.state.translatedJsonData.length > 0) {
                        TranslatorApp.ui.renderPreview();
                        TranslatorApp.ui.showScreen('preview');
                    } else {
                        TranslatorApp.ui.showScreen('setup');
                    }
                    TranslatorApp.ui.showAlert('ุชู ุงุณุชุนุงุฏุฉ ุงูุฌูุณุฉ ุงูุณุงุจูุฉ ุจูุฌุงุญ.', 'success');
                },
                clear() {
                    localStorage.removeItem('translatorSession');
                    location.reload();
                }
            },

            // --- FILE HANDLING ---
            fileHandler: {
                addFiles(files) {
                    const fileList = Array.from(files).filter(f => f.name.endsWith('.json'));
                    fileList.forEach(file => {
                        if (!TranslatorApp.state.selectedFilesInfo.some(f => f.name === file.name)) {
                            TranslatorApp.state.selectedFilesInfo.push({ name: file.name, size: file.size });
                        }
                    });
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.session.save();
                },
                removeFile(index) {
                    TranslatorApp.state.selectedFilesInfo.splice(index, 1);
                    TranslatorApp.state.originalJsonData.splice(index, 1);
                    TranslatorApp.state.translatedJsonData.splice(index, 1);
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.session.save();
                },
                async readFilesFromInput() {
                    const fileInputFiles = TranslatorApp.dom.fileInput.files;
                    if (fileInputFiles.length === 0 && TranslatorApp.state.originalJsonData.length === 0) {
                         throw new Error("ุงูุฑุฌุงุก ุชุญุฏูุฏ ุงููููุงุช ูุฑุฉ ุฃุฎุฑู ูุจุฏุก ุงูุชุฑุฌูุฉ.");
                    }
                    TranslatorApp.state.originalJsonData = [];
                    for (const fileInfo of TranslatorApp.state.selectedFilesInfo) {
                       const file = Array.from(fileInputFiles).find(f => f.name === fileInfo.name);
                       if(file) {
                           const content = await file.text();
                           TranslatorApp.state.originalJsonData.push({ name: file.name, data: JSON.parse(content) });
                       } else if (!TranslatorApp.state.originalJsonData.find(d => d.name === fileInfo.name)) {
                           throw new Error(`ูู ูุชู ุงูุนุซูุฑ ุนูู ุงูููู ${fileInfo.name}. ูุฑุฌู ุฅุนุงุฏุฉ ุชุญุฏูุฏู.`);
                       }
                    }
                }
            },

            // --- GLOSSARY ---
            glossary: {
                add() {
                    const term = TranslatorApp.dom.glossaryTermInput.value.trim();
                    const translation = TranslatorApp.dom.glossaryTranslationInput.value.trim();
                    if (!term || !translation) return TranslatorApp.ui.showAlert('ูุฑุฌู ุฅุฏุฎุงู ุงููุตุทูุญ ูุชุฑุฌูุชู.', 'error');
                    if (TranslatorApp.state.glossary.some(e => e.term.toLowerCase() === term.toLowerCase())) return TranslatorApp.ui.showAlert('ูุฐุง ุงููุตุทูุญ ููุฌูุฏ ุจุงููุนู ูู ุงููุงููุณ.', 'error');
                    TranslatorApp.state.glossary.push({ term, translation });
                    TranslatorApp.dom.glossaryTermInput.value = '';
                    TranslatorApp.dom.glossaryTranslationInput.value = '';
                    this.render();
                    TranslatorApp.session.save();
                },
                delete(index) {
                    TranslatorApp.state.glossary.splice(index, 1);
                    this.render();
                    TranslatorApp.session.save();
                },
                render() { TranslatorApp.ui.renderGlossaryList(); },
                apply(text) {
                    const { glossary } = TranslatorApp.state;
                    if (!text || !glossary || glossary.length === 0) return { modifiedText: text, placeholders: {} };
                    let modifiedText = text;
                    const placeholders = {};
                    let placeholderIndex = 0;
                    const sortedGlossary = [...glossary].sort((a, b) => b.term.length - a.term.length);
                    sortedGlossary.forEach(entry => {
                        const regex = new RegExp(`\\b${entry.term}\\b`, 'gi');
                        modifiedText = modifiedText.replace(regex, () => {
                            const placeholder = `__GLOSSARY_${placeholderIndex}__`;
                            placeholders[placeholder] = entry.translation;
                            placeholderIndex++;
                            return placeholder;
                        });
                    });
                    return { modifiedText, placeholders };
                },
                revert(text, placeholders) {
                    if (Object.keys(placeholders).length === 0) return text;
                    return Object.entries(placeholders).reduce((acc, [key, value]) => acc.replaceAll(key, value), text);
                }
            },

            // --- API & TRANSLATION ---
            api: {
                async translateBatch(texts, apiKey, provider) {
                    const BATCH_SEPARATOR = "\n|||---|||\n";
                    const prompt = `Translate each of the following texts to Arabic, separated by "${BATCH_SEPARATOR}". Keep any HTML tags, LaTeX equations, or placeholders like __GLOSSARY_0__ unchanged. Maintain the exact number of separated texts in your response.\n\n${texts.join(BATCH_SEPARATOR)}`;
                    
                    let responseText;
                    if (provider === 'gemini') {
                        responseText = await this.withGemini(prompt, apiKey);
                    } else {
                        responseText = await this.withChatGPT(prompt, apiKey);
                    }
                    
                    const translatedTexts = responseText.split(BATCH_SEPARATOR.trim()); // trim to handle potential whitespace issues
                    if (translatedTexts.length !== texts.length) {
                        console.error("Mismatch in translated texts count.", { sent: texts.length, received: translatedTexts.length });
                        throw new Error("ุญุฏุซ ุฎุทุฃ ุฃุซูุงุก ูุนุงูุฌุฉ ุงูุชุฑุฌูุฉ ุงููุฌูุนุฉุ ุนุฏุฏ ุงููุตูุต ุงููุชุฑุฌูุฉ ูุง ูุชุทุงุจู.");
                    }
                    return translatedTexts.map(t => t.trim());
                },
                async withGemini(prompt, apiKey) {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    const response = await fetch(apiUrl, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    });
                    if (!response.ok) { const err = await response.json(); throw new Error(`Gemini API Error: ${err.error?.message || response.statusText}`); }
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                },
                async withChatGPT(prompt, apiKey) {
                    const apiUrl = 'https://api.openai.com/v1/chat/completions';
                    const response = await fetch(apiUrl, {
                        method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                        body: JSON.stringify({
                            model: 'gpt-4o',
                            messages: [
                                { role: 'system', content: 'You are a professional translator. You will receive a batch of texts separated by a unique delimiter. Translate each text to Modern Standard Arabic and return them separated by the same delimiter. Do not alter the number of texts.' },
                                { role: 'user', content: prompt }
                            ],
                            temperature: 0.3
                        })
                    });
                    if (!response.ok) { const err = await response.json(); throw new Error(`ChatGPT API Error: ${err.error?.message || response.statusText}`); }
                    const data = await response.json();
                    return data.choices?.[0]?.message?.content || '';
                }
            },

            // --- MAIN PROCESS ---
            async startTranslationProcess() {
                const apiProvider = document.querySelector('input[name="apiProvider"]:checked').value;
                const apiKey = (apiProvider === 'gemini' ? this.dom.geminiKeyInput.value : this.dom.chatgptKeyInput.value).trim();
                if (!apiKey) return this.ui.showAlert(`ุงูุฑุฌุงุก ุฅุฏุฎุงู ููุชุงุญ API ูู ${apiProvider === 'gemini' ? 'Gemini' : 'ChatGPT'}.`);
                if (this.state.selectedFilesInfo.length === 0) return this.ui.showAlert('ุงูุฑุฌุงุก ุงุฎุชูุงุฑ ููู JSON ูุงุญุฏ ุนูู ุงูุฃูู.');

                this.ui.showScreen('progress');
                this.dom.translateBtn.disabled = true;
                this.state.translationCache.clear(); // Clear cache for new batch

                try {
                    this.ui.updateProgress('ุฌุงุฑู ูุฑุงุกุฉ ุงููููุงุช...');
                    await this.fileHandler.readFilesFromInput();
                    this.state.translatedJsonData = JSON.parse(JSON.stringify(this.state.originalJsonData));

                    this.ui.updateProgress('ุฌุงุฑู ุชุฌููุน ุงููุตูุต ููุชุฑุฌูุฉ...');
                    const textsToTranslate = [];
                    const textPointers = [];
                    const useGlossary = this.dom.useGlossaryCheckbox.checked;

                    this.state.translatedJsonData.forEach((file, fileIndex) => {
                        const processText = (text, pointer) => {
                            if (!text || !text.trim()) return;
                            const { modifiedText, placeholders } = useGlossary ? this.glossary.apply(text) : { modifiedText: text, placeholders: {} };
                            pointer.placeholders = placeholders;
                            
                            if (this.state.translationCache.has(modifiedText)) {
                                pointer.cached = true;
                                pointer.text = this.state.translationCache.get(modifiedText);
                            } else {
                                textsToTranslate.push(modifiedText);
                                textPointers.push(pointer);
                            }
                        };
                        
                        const addPointer = (key, partIndex = null, choiceIndex = null) => ({ fileIndex, key, partIndex, choiceIndex });
                        
                        processText(file.data.statement, addPointer('statement'));
                        file.data.parts?.forEach((part, partIndex) => {
                            processText(part.stem, addPointer('stem', partIndex));
                            processText(part.answer, addPointer('answer', partIndex));
                            part.choices?.forEach((choice, choiceIndex) => processText(choice.html_content, addPointer('choice', partIndex, choiceIndex)));
                        });
                    });

                    this.ui.updateProgress(`ุฌุงุฑู ุชุฑุฌูุฉ ${textsToTranslate.length} ูุต ูุฑูุฏ...`);
                    if (textsToTranslate.length > 0) {
                        const translatedTexts = await this.api.translateBatch(textsToTranslate, apiKey, apiProvider);
                        translatedTexts.forEach((translatedText, i) => {
                            const originalText = textsToTranslate[i];
                            this.state.translationCache.set(originalText, translatedText);
                            textPointers[i].text = translatedText;
                        });
                    }

                    this.ui.updateProgress('ุฌุงุฑู ุชุญุฏูุซ ุงูุจูุงูุงุช...');
                    [...textPointers, ...this.state.translatedJsonData.flatMap((f, fi) => this.findCachedPointers(fi))].forEach(pointer => {
                        this.updateDataPointer(pointer);
                    });

                    this.state.activeScreen = 'preview';
                    this.session.save();
                    this.ui.renderPreview();
                    this.ui.showScreen('preview');
                    this.ui.showAlert('ุชูุช ุงูุชุฑุฌูุฉ ุจูุฌุงุญ!', 'success');

                } catch (error) {
                    console.error('Translation process failed:', error);
                    this.ui.showAlert(error.message, 'error');
                    this.ui.showScreen('setup');
                } finally {
                    this.dom.translateBtn.disabled = false;
                }
            },
            
            findCachedPointers(fileIndex) {
                 const pointers = [];
                 const file = this.state.translatedJsonData[fileIndex];
                 const useGlossary = this.dom.useGlossaryCheckbox.checked;
                 
                 const checkCache = (text, pointer) => {
                     if (!text) return;
                     const { modifiedText, placeholders } = useGlossary ? this.glossary.apply(text) : { modifiedText: text, placeholders: {} };
                     if (this.state.translationCache.has(modifiedText)) {
                         pointer.text = this.state.translationCache.get(modifiedText);
                         pointer.placeholders = placeholders;
                         pointers.push(pointer);
                     }
                 };
                 
                 checkCache(file.data.statement, {fileIndex, key: 'statement'});
                 file.data.parts?.forEach((part, partIndex) => {
                     checkCache(part.stem, {fileIndex, key: 'stem', partIndex});
                     checkCache(part.answer, {fileIndex, key: 'answer', partIndex});
                     part.choices?.forEach((choice, choiceIndex) => checkCache(choice.html_content, {fileIndex, key: 'choice', partIndex, choiceIndex}));
                 });
                 
                 return pointers;
            },

            updateDataPointer(pointer) {
                const { fileIndex, key, partIndex, choiceIndex, text, placeholders } = pointer;
                const final_text = this.glossary.revert(text, placeholders);
                const fileData = this.state.translatedJsonData[fileIndex].data;

                if (key === 'statement') fileData.statement = final_text;
                else if (key === 'parts' && partIndex !== null) {
                    const part = fileData.parts[partIndex];
                    if (subKey === 'stem') part.stem = final_text;
                    if (subKey === 'answer') part.answer = final_text;
                    if (subKey === 'choice' && choiceIndex !== null) part.choices[choiceIndex].html_content = final_text;
                }
            },

            // --- UI & RENDER ---
            ui: {
                showScreen(screenName) { TranslatorApp.state.activeScreen = screenName; ['setupSection', 'progressContainer', 'previewSection'].forEach(id => TranslatorApp.dom[id].classList.add('hidden')); TranslatorApp.dom[screenName].classList.remove('hidden'); },
                updateProgress(text) { TranslatorApp.dom.progressText.textContent = text; },
                showAlert(message, type = 'error', duration = 5000) {
                    const colors = { error: 'bg-red-500', success: 'bg-green-500', info: 'bg-blue-500' };
                    const alertBox = document.createElement('div');
                    alertBox.className = `alert flex justify-between items-center text-white p-4 rounded-lg shadow-xl ${colors[type] || 'bg-gray-500'}`;
                    alertBox.innerHTML = `<span>${message}</span><button class="mr-2 text-xl font-bold">&times;</button>`;
                    alertBox.querySelector('button').onclick = () => alertBox.remove();
                    TranslatorApp.dom.alertContainer.appendChild(alertBox);
                    if (duration) { setTimeout(() => { alertBox.classList.add('fade-out'); alertBox.addEventListener('transitionend', () => alertBox.remove()); }, duration); }
                },
                renderFileList() {
                    const { fileList } = TranslatorApp.dom;
                    fileList.innerHTML = '';
                    if (TranslatorApp.state.selectedFilesInfo.length === 0) return;
                    const listContainer = document.createElement('ul');
                    listContainer.className = 'my-4 space-y-2';
                    TranslatorApp.state.selectedFilesInfo.forEach((fileInfo, index) => {
                        const li = document.createElement('li');
                        li.className = 'flex justify-between items-center bg-gray-100 p-2 rounded-lg';
                        li.innerHTML = `<span class="font-medium text-gray-800">${fileInfo.name}</span><button data-index="${index}" class="remove-file-btn text-red-500 hover:text-red-700 font-bold text-xl">&times;</button>`;
                        listContainer.appendChild(li);
                    });
                    fileList.appendChild(listContainer);
                    fileList.querySelectorAll('.remove-file-btn').forEach(btn => { btn.onclick = () => TranslatorApp.fileHandler.removeFile(parseInt(btn.dataset.index)); });
                },
                showGlossaryModal(show) { TranslatorApp.dom.glossaryModal.classList.toggle('hidden', !show); },
                renderGlossaryList() {
                    const { glossaryListContainer } = TranslatorApp.dom;
                    glossaryListContainer.innerHTML = '';
                    if (TranslatorApp.state.glossary.length === 0) return glossaryListContainer.innerHTML = '<p class="text-center text-gray-500">ุงููุงููุณ ูุงุฑุบ ุญุงูููุง.</p>';
                    const list = document.createElement('ul');
                    list.className = 'space-y-2';
                    TranslatorApp.state.glossary.forEach((entry, index) => {
                        const li = document.createElement('li');
                        li.className = 'flex justify-between items-center p-2 bg-white rounded-md border';
                        li.innerHTML = `<div><span class="font-semibold">${entry.term}</span><span class="text-gray-500 mx-2">โ</span><span>${entry.translation}</span></div><button data-index="${index}" class="remove-glossary-btn text-red-500 hover:text-red-700 font-bold">&times;</button>`;
                        list.appendChild(li);
                    });
                    glossaryListContainer.appendChild(list);
                    glossaryListContainer.querySelectorAll('.remove-glossary-btn').forEach(btn => { btn.onclick = () => TranslatorApp.glossary.delete(parseInt(btn.dataset.index)); });
                },
                renderPreview() {
                    const { previewContainer } = TranslatorApp.dom;
                    previewContainer.innerHTML = '';
                    TranslatorApp.state.translatedJsonData.forEach((file, fileIndex) => {
                        const card = document.createElement('div');
                        card.className = 'preview-card bg-gray-50 p-4 rounded-lg border';
                        card.dir = 'rtl';
                        const createEditableField = (label, value, onUpdate) => {
                            if (value === undefined) return '';
                            return `<div class="mb-3"><p class="font-semibold text-right">${label}:</p><div contenteditable="true" onblur="${onUpdate}" class="editable-content mt-1 p-2 bg-white rounded border border-gray-200 text-right">${value}</div></div>`;
                        };
                        let content = `<h3 class="text-xl font-bold text-gray-800 mb-4 text-right">๐ ${file.name}</h3>`;
                        content += createEditableField('ุงูุจูุงู (Statement)', file.data.statement, `TranslatorApp.updateData(${fileIndex}, 'statement', null, this.innerHTML)`);
                        file.data.parts?.forEach((part, partIndex) => {
                            content += `<div class="border-t pt-4 mt-4"><h5 class="font-semibold text-md text-gray-700 mb-2 text-right">ุงูุฌุฒุก ${partIndex + 1}</h5>`;
                            content += createEditableField('ุงูุณุคุงู (Stem)', part.stem, `TranslatorApp.updateData(${fileIndex}, 'parts', ${partIndex}, this.innerHTML, 'stem')`);
                            content += createEditableField('ุงูุฅุฌุงุจุฉ (Answer)', part.answer, `TranslatorApp.updateData(${fileIndex}, 'parts', ${partIndex}, this.innerHTML, 'answer')`);
                            if (part.choices) {
                                content += `<div class="mb-3"><p class="font-semibold text-right">ุงูุฎูุงุฑุงุช (Choices):</p><ul class="list-disc list-inside mt-2 space-y-2 mr-4">`;
                                part.choices.forEach((choice, choiceIndex) => {
                                    content += `<li class="text-right"><div contenteditable="true" onblur="TranslatorApp.updateData(${fileIndex}, 'parts', ${partIndex}, this.innerHTML, 'choice', ${choiceIndex})" class="editable-content inline-block w-11/12 p-1 bg-white rounded border border-gray-200">${choice.html_content}</div></li>`;
                                });
                                content += `</ul></div>`;
                            }
                            content += `</div>`;
                        });
                        card.innerHTML = content;
                        previewContainer.appendChild(card);
                    });
                }
            },

            // --- HELPERS ---
            updateData(fileIndex, key, partIndex, value, subKey = null, choiceIndex = null) {
                const fileData = this.state.translatedJsonData[fileIndex].data;
                if (key === 'statement') fileData.statement = value;
                else if (key === 'parts') {
                    const part = fileData.parts[partIndex];
                    if (subKey === 'stem') part.stem = value;
                    if (subKey === 'answer') part.answer = value;
                    if (subKey === 'choice') part.choices[choiceIndex].html_content = value;
                }
                this.session.save();
            },
            async generateFinalJsonFiles() {
                const zip = new JSZip();
                this.state.translatedJsonData.forEach(file => {
                    const originalFile = this.state.originalJsonData.find(f => f.name === file.name);
                    const finalData = JSON.parse(JSON.stringify(originalFile.data));
                    if (finalData.statement !== undefined) finalData.statement = file.data.statement;
                    if (finalData.parts) {
                        finalData.parts.forEach((part, partIndex) => {
                            const translatedPart = file.data.parts[partIndex];
                            if (part.stem !== undefined) part.stem = translatedPart.stem;
                            if (part.answer !== undefined) part.answer = translatedPart.answer;
                            if (part.choices) {
                                part.choices.forEach((choice, choiceIndex) => {
                                    if (choice.html_content !== undefined) choice.html_content = translatedPart.choices[choiceIndex].html_content;
                                });
                            }
                        });
                    }
                    zip.file(file.name, JSON.stringify(finalData, null, 2));
                });
                try {
                    const content = await zip.generateAsync({ type: "blob" });
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(content);
                    link.download = "translated_questions.zip";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    this.ui.showAlert('ุชู ุฅูุดุงุก ููู ZIP ุจูุฌุงุญ!', 'success');
                } catch (error) {
                    console.error("Failed to generate zip file:", error);
                    this.ui.showAlert('ูุดู ุฅูุดุงุก ููู ZIP.', 'error');
                }
            }
        };

        document.addEventListener('DOMContentLoaded', () => TranslatorApp.init());
    </script>
</body>
</html>
